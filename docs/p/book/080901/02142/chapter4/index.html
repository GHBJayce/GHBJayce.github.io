<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 涉及知识点 数学知识 对数 概要 树 概念 结构 森林 相关术语和计算 基本运算的功能描述 二叉树 概念 左、右子树 基本运算 性质特征 满二叉树 完全二叉树 存储结构 顺序存储 链式存储 用C语言描述 遍历算法 递归实现 先序遍历 中序遍历 后序遍历 层次遍历 非递归实现 树和森林 树的存储结构 孩子链表表示法 孩子兄弟链表表示法 双亲表示法 树、森林和二叉树的关系与转换 树转二叉树 森林转二叉树 二叉树转森林 遍历 判定树和哈夫曼树 概念 判定树 哈夫曼树 哈夫曼编码 分类和判定树的关系 哈夫曼树构造过程 哈夫曼算法 树 概念 树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。'>
<title>第四章 树和二叉树 - 《数据结构导论》笔记</title>

<link rel='canonical' href='https://ghjayce.github.io/p/book/080901/02142/chapter4/'>

<link rel="stylesheet" href="/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css"><meta property='og:title' content='第四章 树和二叉树 - 《数据结构导论》笔记'>
<meta property='og:description' content='目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 涉及知识点 数学知识 对数 概要 树 概念 结构 森林 相关术语和计算 基本运算的功能描述 二叉树 概念 左、右子树 基本运算 性质特征 满二叉树 完全二叉树 存储结构 顺序存储 链式存储 用C语言描述 遍历算法 递归实现 先序遍历 中序遍历 后序遍历 层次遍历 非递归实现 树和森林 树的存储结构 孩子链表表示法 孩子兄弟链表表示法 双亲表示法 树、森林和二叉树的关系与转换 树转二叉树 森林转二叉树 二叉树转森林 遍历 判定树和哈夫曼树 概念 判定树 哈夫曼树 哈夫曼编码 分类和判定树的关系 哈夫曼树构造过程 哈夫曼算法 树 概念 树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。'>
<meta property='og:url' content='https://ghjayce.github.io/p/book/080901/02142/chapter4/'>
<meta property='og:site_name' content='GHJayce'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据结构导论' /><meta property='article:tag' content='计算机科学与技术' /><meta property='article:tag' content='笔记' /><meta property='article:published_time' content='2023-09-26T09:47:20&#43;08:00'/><meta property='article:modified_time' content='2023-09-26T09:47:20&#43;08:00'/><meta property='og:image' content='https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png' />
<meta name="twitter:title" content="第四章 树和二叉树 - 《数据结构导论》笔记">
<meta name="twitter:description" content="目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 涉及知识点 数学知识 对数 概要 树 概念 结构 森林 相关术语和计算 基本运算的功能描述 二叉树 概念 左、右子树 基本运算 性质特征 满二叉树 完全二叉树 存储结构 顺序存储 链式存储 用C语言描述 遍历算法 递归实现 先序遍历 中序遍历 后序遍历 层次遍历 非递归实现 树和森林 树的存储结构 孩子链表表示法 孩子兄弟链表表示法 双亲表示法 树、森林和二叉树的关系与转换 树转二叉树 森林转二叉树 二叉树转森林 遍历 判定树和哈夫曼树 概念 判定树 哈夫曼树 哈夫曼编码 分类和判定树的关系 哈夫曼树构造过程 哈夫曼算法 树 概念 树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png' />
    <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/17669653" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    <img src="https://avatars.githubusercontent.com/u/17669653" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
                
                </a>
                
                    <span class="emoji">😆</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">GHJayce</a></h1>
            <h2 class="site-description">十年饮冰，难凉热血。</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/GHJayce'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于我</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archive/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#目录">目录</a></li>
    <li><a href="#阅读说明">阅读说明</a>
      <ol>
        <li><a href="#涉及知识点">涉及知识点</a></li>
      </ol>
    </li>
    <li><a href="#概要">概要</a></li>
    <li><a href="#树">树</a>
      <ol>
        <li><a href="#概念">概念</a></li>
        <li><a href="#基本运算的功能描述">基本运算的功能描述</a></li>
      </ol>
    </li>
    <li><a href="#二叉树">二叉树</a>
      <ol>
        <li><a href="#概念-1">概念</a></li>
        <li><a href="#性质特征">性质特征</a></li>
        <li><a href="#基本运算的功能描述-1">基本运算的功能描述</a></li>
        <li><a href="#存储结构">存储结构</a>
          <ol>
            <li><a href="#顺序存储">顺序存储</a></li>
            <li><a href="#链式存储">链式存储</a></li>
          </ol>
        </li>
        <li><a href="#用c语言描述">用C语言描述</a>
          <ol>
            <li><a href="#二叉树-1">二叉树</a></li>
            <li><a href="#三叉树">三叉树</a></li>
          </ol>
        </li>
        <li><a href="#遍历">遍历</a>
          <ol>
            <li><a href="#递归实现">递归实现</a></li>
            <li><a href="#层次遍历">层次遍历</a></li>
            <li><a href="#非递归实现">非递归实现</a></li>
            <li><a href="#应用">应用</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#树和森林">树和森林</a>
      <ol>
        <li><a href="#树的存储结构">树的存储结构</a>
          <ol>
            <li><a href="#孩子链表表示法">孩子链表表示法</a></li>
            <li><a href="#孩子兄弟链表表示法">孩子兄弟链表表示法</a></li>
            <li><a href="#双亲表示法">双亲表示法</a></li>
          </ol>
        </li>
        <li><a href="#树森林和二叉树之间的转换">树、森林和二叉树之间的转换</a>
          <ol>
            <li><a href="#树转换成二叉树">树转换成二叉树</a></li>
            <li><a href="#森林转换成二叉树">森林转换成二叉树</a></li>
            <li><a href="#二叉树转换成森林">二叉树转换成森林</a></li>
          </ol>
        </li>
        <li><a href="#树和森林的遍历">树和森林的遍历</a>
          <ol>
            <li><a href="#树-1">树</a></li>
            <li><a href="#森林">森林</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#判定树和哈夫曼树">判定树和哈夫曼树</a>
      <ol>
        <li><a href="#分类和判定树">分类和判定树</a></li>
        <li><a href="#哈夫曼树和哈夫曼算法">哈夫曼树和哈夫曼算法</a></li>
        <li><a href="#哈夫曼编码">哈夫曼编码</a></li>
      </ol>
    </li>
    <li><a href="#参考">参考</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/book/080901/02142/chapter4/">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" alt="Featured image of post 第四章 树和二叉树 - 《数据结构导论》笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E4%B9%A6%E7%B1%8D/" >
                书籍
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/book/080901/02142/chapter4/">第四章 树和二叉树 - 《数据结构导论》笔记</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2023-09-26</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 7 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="目录">目录</h2>
<ul>
<li><a class="link" href="../chapter1" >第一章 概论</a> <small>P21 ~ 34（13页）</small></li>
<li><a class="link" href="../chapter2" >第二章 线性表</a> <small>P35 ~ 58（23页）</small></li>
<li><a class="link" href="../chapter3" >第三章 栈、队列和数组</a> <small>P59 ~ 92（33页）</small></li>
<li><a class="link" href="../chapter4" ><strong>第四章 树和二叉树</strong></a> <small>P93 ~ 128（35页）</small></li>
<li><a class="link" href="../chapter5" >第五章 图</a> <small>P129 ~ 160（31页）</small></li>
<li><a class="link" href="../chapter6" >第六章 查找</a> <small>P161 ~ 182（21页）</small></li>
<li><a class="link" href="../chapter7" >第七章 排序</a> <small>P183 ~ 204（27页）</small></li>
<li><a class="link" href="../exam-focus" >考试重点</a></li>
</ul>
<h2 id="阅读说明">阅读说明</h2>
<h3 id="涉及知识点">涉及知识点</h3>
<ul>
<li>数学知识
<ul>
<li><a class="link" href="https://ghjayce.github.io/p/subject/math/sequence/logarithm/"  target="_blank" rel="noopener"
    >对数</a></li>
</ul>
</li>
</ul>
<h2 id="概要">概要</h2>
<ol>
<li>树
<ol>
<li>概念
<ul>
<li>结构</li>
<li>森林</li>
<li>相关术语和计算</li>
</ul>
</li>
<li>基本运算的功能描述</li>
</ol>
</li>
<li>二叉树
<ol>
<li>概念
<ul>
<li>左、右子树</li>
</ul>
</li>
<li>基本运算</li>
<li>性质特征
<ul>
<li>满二叉树</li>
<li>完全二叉树</li>
</ul>
</li>
<li>存储结构
<ul>
<li>顺序存储</li>
<li>链式存储</li>
</ul>
</li>
<li>用C语言描述</li>
<li>遍历算法
<ul>
<li><strong>递归实现</strong>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>层次遍历</li>
<li>非递归实现</li>
</ul>
</li>
</ol>
</li>
<li>树和森林
<ol>
<li>树的存储结构
<ul>
<li>孩子链表表示法</li>
<li>孩子兄弟链表表示法</li>
<li>双亲表示法</li>
</ul>
</li>
<li>树、森林和二叉树的关系与转换
<ul>
<li>树转二叉树</li>
<li>森林转二叉树</li>
<li>二叉树转森林</li>
</ul>
</li>
<li>遍历</li>
<li>判定树和哈夫曼树
<ul>
<li>概念
<ul>
<li>判定树</li>
<li>哈夫曼树</li>
<li>哈夫曼编码</li>
</ul>
</li>
<li>分类和判定树的关系</li>
<li>哈夫曼树构造过程</li>
<li>哈夫曼算法</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="树">树</h2>
<h3 id="概念">概念</h3>
<p>树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。</p>
<p>特征：树形结构结点之间具有一对多的关系，一个结点可以有一个或多个直接后继。</p>
<p><img src="https://ghjayce.github.io/asset/blog/spkdu2ZEy2QZwqcpUbdHMjAyNDAyMjVfMTU0MDQx.png"
	width="701"
	height="629"
	
	loading="lazy"
	
		alt="什么是树？"
	
	
		class="gallery-image" 
		data-flex-grow="111"
		data-flex-basis="267px"
	
></p>
<ul>
<li>双亲：指父结点，parent node翻译过来的意思。
<ul>
<li>例，如图a)：
<ul>
<li>A没有双亲。</li>
<li>B、C、D的双亲是A。</li>
<li>E、F的双亲是B。</li>
</ul>
</li>
</ul>
</li>
<li>直接孩子：指结点的孩子，孩子的孩子不算，只是为了方便区分，一般简称孩子。
<ul>
<li>例，如图a)：
<ul>
<li>A的孩子有B、C、D。</li>
<li>B的孩子有E、F。</li>
</ul>
</li>
</ul>
</li>
<li>祖先：沿着某个结点向上追溯，直到根结点结束，路径上的所有结点都是祖先。
<ul>
<li>例，如图a)：
<ul>
<li>A没有祖先。</li>
<li>B的祖先是A。</li>
<li>H的祖先分别是G、D、A。</li>
</ul>
</li>
</ul>
</li>
<li>子孙：除了根结点以外的其他结点。
<ul>
<li>例，如图a)：
<ul>
<li>B的子孙分别是E、F。</li>
<li>D的子孙分别是G、H、I、J。</li>
</ul>
</li>
</ul>
</li>
<li>兄弟结点：某个结点的直接孩子们，它们之间是兄弟关系，拥有同一个父结点。
<ul>
<li>例，如图a)：
<ul>
<li>B、C、D它们之间是兄弟。</li>
<li>E、F是兄弟。</li>
</ul>
</li>
</ul>
</li>
<li>叶子：没有孩子的结点，也称叶子结点、终端结点。
<ul>
<li>例，如图a)：E、F、C、H、I、J都是叶子。</li>
</ul>
</li>
<li>子树：某个结点的所有子孙（后代结点）所构成的树结构。
<ul>
<li>例，如图a)：
<ul>
<li>D、G、H、I、J所构成的树结构是根结点A的子树。</li>
<li>C不算子树，因为它没有子孙。</li>
<li>B、E、F这棵树是根结点A的子树。</li>
</ul>
</li>
</ul>
</li>
<li>结点的度：某一个结点有多少个直接孩子。
<ul>
<li>例，如图a)：
<ul>
<li>A结点的度为3。</li>
<li>B结点的度为2。</li>
<li>D结点的度为1。</li>
</ul>
</li>
</ul>
</li>
<li>树的度：结点的度的最大值，也就是所有结点里直接孩子最多的那个。
<ul>
<li>例，如图a)：树的度为3。</li>
</ul>
</li>
<li>结点的层次：把一棵树比作一个层级金字塔，从根结点为1，每下一层+1，数到结点所在的层级。
<ul>
<li>例，如图a)：
<ul>
<li>B的层次是2。</li>
<li>E的层次是3。</li>
<li>H的层次是4。</li>
</ul>
</li>
</ul>
</li>
<li>树的高度/深度：结点的层次的最大值，也就是树一共有多少层。
<ul>
<li>例，如图a)：树高为4。</li>
</ul>
</li>
<li>有序树：结点的孩子之间的按照一定的顺序排序，典型的例子是二叉树。</li>
<li>无序树：结点的孩子之间的顺序可以任意排列，典型的例子是普通树，也称自由树。</li>
</ul>
<p>一棵树需要满足的条件：</p>
<ol>
<li>当n=0时，称为空树。</li>
<li>当n&gt;0时：
<ul>
<li>仅有一个称为根的结点，简称根结点。</li>
<li>根结点有它的直接孩子，构成父子关系，直接孩子也有自己的孩子，构成根结点的子树。</li>
<li>孩子之间没有关联，互不相交，把孩子作为一个单独的根结点时，以上条件同样适用。</li>
</ul>
</li>
</ol>
<p>上图b)、c)不是一棵树，存在两个根节点，d)也都不是一棵树，因为孩子之间相交了。</p>
<blockquote>
<p>以上第2个条件是我个人方便理解的总结，贴上书上原话：有且仅有一个称为根的结点，除根节点外，其余结点分为m(m≥0)个互不相交的非空集合T<sub>1</sub>，T<sub>2</sub>，&hellip;，T<sub>m</sub>，这些集合中的每一个都是一棵树，称为根的子树。</p>
</blockquote>
<p>森林Forest是m(m≥0)棵互不相交的树的集合，简单点说就是有多棵树，且它们之间互不相交，例如图b)、c)。</p>
<h3 id="基本运算的功能描述">基本运算的功能描述</h3>
<ol>
<li>求根<code>Root(T)</code>：求树T的根节点。</li>
<li>求双亲<code>Parent(T, X)</code>：求结点X在树T上的双亲节点，若X是根结点或不在T上，则返回特殊标志。</li>
<li>求孩子<code>Child(T, X, i)</code>：求结点X的第i个孩子结点，若X不在T上或X上没有i孩子，则返回特殊标志。</li>
<li>建树Create(X, T<sub>1</sub>, &hellip;, T<sub>k</sub>)，k&gt;1：建立一棵以X为根，以T<sub>1</sub>，&hellip;，T<sub>k</sub>为第1，&hellip;，k棵子树的树。</li>
<li>剪枝<code>Delete(T, X, i)</code>：删除树T上结点X的第i棵子树，若T无第i棵子树，则为空操作。</li>
<li>遍历<code>TraverseTree(T)</code>：遍历树，即访问树中每个结点，且每个结点仅被访问一次。</li>
</ol>
<h2 id="二叉树">二叉树</h2>
<h3 id="概念-1">概念</h3>
<p>二叉树Binary Tree是n(n≥0)个元素的有限集合，即在树的基础上，一棵二叉树需要满足其中一个条件：</p>
<ol>
<li>空树，什么结点都没有。</li>
<li>只有一个根结点，即左右子树均为空。</li>
<li>右子树为空。</li>
<li>左子树为空。</li>
<li>由一个根结点和两棵互不相交的左子树和右子树组成，子树之间是有次序关系的，且均是一棵二叉树。</li>
</ol>
<p><img src="https://ghjayce.github.io/asset/blog/hlscD7f58TUm3T55ZxEIMjAyNDAyMjVfMTU0MjIy.png"
	width="808"
	height="721"
	
	loading="lazy"
	
		alt="二叉树"
	
	
		class="gallery-image" 
		data-flex-grow="112"
		data-flex-basis="268px"
	
></p>
<p>$$图4.2$$</p>
<h3 id="性质特征">性质特征</h3>
<p>二叉树的5个性质特征：</p>
<ul>
<li>性质1：<strong>二叉树第i（i≥1）层上至多有2<sup>i-1</sup>个结点</strong>，也就是：
<ul>
<li>第一层最多有1个结点。</li>
<li>第二层最多有2个结点。</li>
<li>第三层最多有4个结点。</li>
<li>第四层最多有8个结点，以此类推。</li>
</ul>
</li>
<li>性质2：<strong>深度为k（k≥1）的二叉树至多有2<sup>k-1</sup>个结点</strong>，也就是例如二叉树高为3，那么最多有4个结点。
<ul>
<li>符合该性质的称为<strong>满二叉树</strong>。</li>
</ul>
</li>
<li>性质3：<strong>对任何一棵二叉树，若度数为0的结点个数为$n_0$，度数为2的结点个数为$n_2$，则 $n_0=n_2+1$</strong>。
<ul>
<li>例如上图c)，度数为0的结点个数是3（D、G、F），度数为2的结点个数是2（A、B）。</li>
</ul>
</li>
</ul>
<p><strong>完全二叉树</strong>：如果对满二叉树按从上到下，从左到右的顺序编号，并在树的最后一层删去部分结点（最后一层至少还剩一个结点），删完以后整棵树的结点还是顺序的排列，这就是棵完全二叉树，其性质有：</p>
<ul>
<li>性质4：<strong>含有n个结点的完全二叉树的深度为$⌊log_2n⌋+1$</strong>。
<ul>
<li>其中<code>⌊x⌋</code>表示不大于x的最大整数，即向下取整函数，指⌊$log_2n$⌋，$log_2n$是对数，<a class="link" href="https://ghjayce.github.io/p/subject/math/sequence/logarithm/"  target="_blank" rel="noopener"
    >什么是对数？</a></li>
<li>例如上图b)，共有10个结点，即⌊log<sub>2</sub>10⌋+1，对数结果是<code>3.32..</code>向下取整后是3，最终深度是4。</li>
</ul>
</li>
<li>性质5：<strong>按上面完全二叉树的定义对结点进行顺序编号，对任意一编号为i(1 ≤ i ≤ n)的结点x，性质有</strong>：
<ul>
<li>若<code>i = 1</code>，结点x是根。</li>
<li>若<code>i &gt; 1</code>，结点x的双亲的编号为：<code>⌊i / 2⌋</code>。</li>
<li>若<code>2 * i ＞ n</code>，结点x无左和右孩子；若有左孩子，其编号为<code>2 * i</code>。</li>
<li>若<code>2 * i + 1 ＞ n</code>，结点x无右孩子，若有右孩子，其编号为<code>2 * i + 1</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>书上原话：二叉树不是完全二叉树，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。</p>
</blockquote>
<h3 id="基本运算的功能描述-1">基本运算的功能描述</h3>
<ol>
<li>初始化<code>Initiate(BT)</code>：建立一棵空二叉树，BT=∅。</li>
<li>求双亲<code>Parent(BT, X)</code>：找出结点X的双亲结点，若X是根结点或X不在BT上，返回NULL。</li>
<li>求左孩子<code>Lchild(BT, X)</code>：求X结点的左孩子，若X是叶子结点或X不在BT上，返回NULL。</li>
<li>求右孩子<code>Rchild(BT, X)</code>：与求左孩子逻辑一样，区别是求X结点的右孩子。</li>
<li>建二叉树<code>Create(BT)</code>：建立一棵二叉树BT。</li>
<li>先序遍历<code>PreOrder(BT)</code>：按先序对二叉树BT进行遍历，每个结点仅被访问一次。BT为空不操作。</li>
<li>中序遍历<code>InOrder(BT)</code>：与先序遍历逻辑一样，区别是以中序进行。</li>
<li>后序遍历<code>PostOrder(BT)</code>：与先序遍历逻辑一样，区别是以后序进行。</li>
<li>层次遍历<code>LevelOrder(BT)</code>：按层从上往下，每层从左往右对二叉树进行遍历，每个结点仅被访问一次。BT为空不操作。</li>
</ol>
<h3 id="存储结构">存储结构</h3>
<p>二叉树通常有两种存储结构：顺序存储和链式存储结构。</p>
<h4 id="顺序存储">顺序存储</h4>
<p>二叉树的顺序存储可以用一维数组来实现，按照性质5的特性，对结点进行从上到下从左到右的顺序进行编号，从根结点1开始，将结点顺序地存进数组的对应下标位置，下标0不使用。</p>
<p>顺序存储分为两种情况：</p>
<ol>
<li>如果二叉树是完全二叉树，如下图a)、b)的方式进行存储。</li>
<li>如果二叉树非完全二叉树：
<ol>
<li>首先必须用某种方法将其转换成完全二叉树。</li>
<li>对不存在的结点的位置可增设虚拟结点（阴影表示）的方式，如下图e)。</li>
<li>对应虚拟结点下标的位置使用特殊记号∧表示。</li>
</ol>
</li>
</ol>
<p><img src="https://ghjayce.github.io/asset/blog/n4LTWDMnPdgKdymM20F9MjAyNDAyMjVfMTU0MzUw.png"
	width="961"
	height="959"
	
	loading="lazy"
	
		alt="完全二叉树的顺序存储"
	
	
		class="gallery-image" 
		data-flex-grow="100"
		data-flex-basis="240px"
	
></p>
<p>非完全二叉树的顺序存储虽然可以用转换完全二叉树，以完全二叉树的顺序存储进行处理，这样只要是一棵二叉树（不管是哪种类型）都能够用同一种运算方式进行处理，<strong>但这种方法最大的缺点是造成了空间的浪费</strong>。</p>
<h4 id="链式存储">链式存储</h4>
<p>二叉树最常用的是链式存储结构，其中又分为二叉链表和三叉链表。</p>
<p><img src="https://ghjayce.github.io/asset/blog/Ro3LJ2kEYGY7ZsaykKa3MjAyNDAyMjVfMTU0NDM4.png"
	width="1016"
	height="791"
	
	loading="lazy"
	
		alt="二叉树的链式存储"
	
	
		class="gallery-image" 
		data-flex-grow="128"
		data-flex-basis="308px"
	
></p>
<p>其中：</p>
<ul>
<li>lchild表示指向左孩子的指针，即左指针。
<ul>
<li>没有左孩子时左指针域的值为NULL。</li>
</ul>
</li>
<li>rchild表示指向右孩子的指针，即右指针。
<ul>
<li>没有右孩子时右指针域的值为NULL。</li>
</ul>
</li>
<li>每个二叉链表必须有一个指向根结点的指针，即根指针，例如上图 c) 中的root，与链表头指针类似。
<ul>
<li>访问二叉链表只能从根指针开始。</li>
<li>若二叉树为空，则<code>root = NULL</code>。</li>
</ul>
</li>
<li>三叉链表在每个结点增加了一个指针域parent，用于指向该结点的双亲。</li>
<li>因此总结出规律，在具有 n 个结点的二叉树中，有<code>2n</code>个指针域：
<ul>
<li>其中只有<code>n - 1</code>个用来指向结点的左、右孩子。</li>
<li>其余的<code>n + 1</code>个指针域为NULL。</li>
</ul>
</li>
</ul>
<h3 id="用c语言描述">用C语言描述</h3>
<h4 id="二叉树-1">二叉树</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">binaryTreeNode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">binaryTreeNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">binaryTree</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="三叉树">三叉树</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">TBNode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">TBNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">ThreeBinaryTree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ThreeBinaryTree</span> <span class="n">root</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="遍历">遍历</h3>
<p>二叉树的遍历是指按某种次序访问二叉树上的所有结点，且每个结点仅访问一次。</p>
<p>一棵二叉树由三部分组成：根、根的左子树、根的右子树。</p>
<p>因此遍历二叉树总共有三个步骤：</p>
<ul>
<li>访问根结点。</li>
<li>遍历根的左子树。</li>
<li>遍历根的右子树。</li>
</ul>
<p>遍历共有三种次序，不同的次序只是三个步骤的顺序不同：</p>
<blockquote>
<p>下面会以图4.2中的c)二叉树为例，分别说明对应次序的序列。</p>
</blockquote>
<ul>
<li>先序遍历。
<ul>
<li>步骤顺序，简记为：根左右。
<ul>
<li>访问根结点。</li>
<li>先序遍历根的左子树。</li>
<li>先序遍历根的右子树。</li>
</ul>
</li>
<li>先序遍历结点的序列为：ABDEGCF，以下是遍历过程：
<ol>
<li>访问A。</li>
<li>先序遍历A的左子树（BDEG）。
<ol>
<li>访问B。</li>
<li>先序遍历B的左子树（D）。
<ol>
<li>访问D。</li>
<li>先序遍历D的左子树（空）。</li>
<li>先序遍历D的右子树（空）。</li>
</ol>
</li>
<li>先序遍历B的右子树（EG）。
<ol>
<li>访问E。</li>
<li>先序遍历E的左子树（G）。
<ol>
<li>访问G。</li>
<li>先序遍历G的左子树（空）。</li>
<li>先序遍历G的右子树（空）。</li>
</ol>
</li>
<li>先序遍历E的右子树（空）。</li>
</ol>
</li>
</ol>
</li>
<li>先序遍历A的右子树（CF）。
<ol>
<li>访问C。</li>
<li>先序遍历C的左子树（空）。</li>
<li>先序遍历C的右子树（F）。
<ol>
<li>访问F。</li>
<li>先序遍历F的左子树（空）。</li>
<li>先序遍历F的右子树（空）。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>中序遍历。
<ul>
<li>步骤顺序，简记为：左根右。
<ul>
<li>中序遍历根的左子树。</li>
<li>访问根结点。</li>
<li>中序遍历根的右子树。</li>
</ul>
</li>
<li>结点的序列为：DBGEACF。</li>
</ul>
</li>
<li>后序遍历。
<ul>
<li>步骤顺序，简记为：左右根。
<ul>
<li>后序遍历根的左子树。</li>
<li>后序遍历根的右子树。</li>
<li>访问根结点。</li>
</ul>
</li>
<li>结点的序列为：DGEBFCA。</li>
</ul>
</li>
</ul>
<h4 id="递归实现">递归实现</h4>
<p>先序、中序和后序都是基于递归的实现，下面给出各次序具体的算法。</p>
<p>假设<code>visit(bt)</code>函数是访问指针bt所指结点。</p>
<h5 id="先序遍历">先序遍历</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">binaryTree</span> <span class="n">bt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">bt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">visit</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">preorder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">preorder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="中序遍历">中序遍历</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">binaryTree</span> <span class="n">bt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">bt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">inorder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">visit</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">inorder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="后序遍历">后序遍历</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">binaryTree</span> <span class="n">bt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">bt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">postorder</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">postorder</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">visit</span><span class="p">(</span><span class="n">bt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="层次遍历">层次遍历</h4>
<p>不是重点，待补充&hellip;</p>
<h4 id="非递归实现">非递归实现</h4>
<p>不是重点，待补充&hellip;</p>
<h4 id="应用">应用</h4>
<p>1、根据先序遍历和中序遍历次序创建一棵二叉树。</p>
<ul>
<li>先序遍历次序：ABDEGCF。</li>
<li>中序遍历次序：DBGEACF。</li>
</ul>
<p>算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">binaryTree</span> <span class="nf">createByPreInOrder</span><span class="p">(</span><span class="kt">char</span> <span class="n">preArr</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">inArr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">preArrMinIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preArrMaxIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inArrMinIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inArrMaxIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">inArrMaxIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如下申请内存的方式出自书上，是高度概括的，会存在内存越界导致结果出现一些不可预料的问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// binaryTree bt = malloc(sizeof(binaryTree));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以下是正确的申请方式，两者之间在64位机器上相差16字节，前者8字节，后者24字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">binaryTree</span> <span class="n">bt</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">binaryTreeNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">bt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">preArr</span><span class="p">[</span><span class="n">preArrMinIndex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">inArrMinIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">inArrMaxIndex</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inArr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">preArr</span><span class="p">[</span><span class="n">preArrMinIndex</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">inArrMaxIndex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">bt</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="nf">createByPreInOrder</span><span class="p">(</span><span class="n">preArr</span><span class="p">,</span> <span class="n">inArr</span><span class="p">,</span> <span class="n">preArrMinIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preArrMinIndex</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="n">inArrMinIndex</span><span class="p">,</span> <span class="n">inArrMinIndex</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bt</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="nf">createByPreInOrder</span><span class="p">(</span><span class="n">preArr</span><span class="p">,</span> <span class="n">inArr</span><span class="p">,</span> <span class="n">preArrMinIndex</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="n">inArrMinIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preArrMaxIndex</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inArrMaxIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实现思路：</p>
<ol>
<li>以递归的方式，逐个将先序遍历次序的结点在中序遍历次序范围中查找，简称在中序遍历中找根结点。</li>
<li>找到根节点以后，在中序遍历次序中分出该根节点的左子树（根结点的左边）和右子树（根结点的右边）的范围。
<ul>
<li>以A根结点为例，在中序遍历次序中：
<ul>
<li>A的左子树即DBGE。</li>
<li>A的右子树即CF。</li>
</ul>
</li>
</ul>
</li>
<li>在左子树和右子树的范围中，再重复步骤1，在范围中寻找先序遍历次序的下一个结点，从而得到完整的左右子树。</li>
</ol>
<p>2、根据中序遍历和后序遍历次序创建一棵二叉树。</p>
<ul>
<li>中序遍历次序：BACDEFGH。</li>
<li>后序遍历次序：BCAEDGHF。</li>
</ul>
<p>思路：与先序遍历和中序遍历一样，都是从中序遍历中找到左右子树。</p>
<p>步骤：</p>
<ol>
<li>由后序遍历次序确定F是根结点，那么在中序遍历次序中，F的左子树是BACDE，右子树是GH。
<ul>
<li>即得出后序遍历次序中，BCAED是F的左子树，GH是F的右子树。</li>
</ul>
</li>
<li>那么从后序遍历次序的左子树范围中确定左子树的根结点是D，重复步骤1。
<ul>
<li>在中序遍历次序中：
<ul>
<li>D的左子树是：BAC。</li>
<li>D的右子树是：E。</li>
</ul>
</li>
<li>在后序遍历次序中即：
<ul>
<li>D的左子树是：BCA。</li>
<li>D的右子树是：E。</li>
</ul>
</li>
</ul>
</li>
<li>继续下一个根节点A，A的左孩子是B，右孩子树C。</li>
<li>回到F的右子树：GH，H是根结点，H的左孩子是G。</li>
</ol>
<p>算法：</p>
<p>待补充&hellip;</p>
<h2 id="树和森林">树和森林</h2>
<h3 id="树的存储结构">树的存储结构</h3>
<p><img src="https://ghjayce.github.io/asset/blog/jH0sxIct2yzmRztDnKApMjAyNDAyMjVfMTU0NjE5.png"
	width="1261"
	height="1841"
	
	loading="lazy"
	
		alt="树的存储结构示例图"
	
	
		class="gallery-image" 
		data-flex-grow="68"
		data-flex-basis="164px"
	
></p>
<p>$$图4.5$$</p>
<h4 id="孩子链表表示法">孩子链表表示法</h4>
<p>用C语言表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_NODE_NUM</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dataType</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dataType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">childLink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">childLinkArr</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">childLink</span> <span class="n">firstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">childLinkArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">childLinkArr</span> <span class="n">link</span><span class="p">[</span><span class="n">MAX_NODE_NUM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合C语言定义和上图b)所示，其中：</p>
<ul>
<li>childLinkArr是一个数组，数组元素个数与上图a)树T的结点的数量相同，结点存放的顺序按树T从上到下从左到右依次排列。</li>
<li>数组元素由数据域 + 首个孩子指针域组成。
<ul>
<li>数据域：用于存放结点值。</li>
<li>首个孩子指针域：指向从左到右的第一个孩子。</li>
<li>首个孩子指针域可以看作是头结点，其所指向的孩子链表（childLink）是一个单链表，分别是结点的第一个孩子、第二个孩子、第三个孩子以此类推。</li>
</ul>
</li>
<li>孩子链表也由数据域 + 指针域组成。
<ul>
<li>数据域：存放孩子在数组childLinkArr中的下标位置。</li>
<li>指针域：指向下一个孩子，也是当前孩子的兄弟结点。</li>
</ul>
</li>
</ul>
<p>为了便于找到双亲，对childLinkArr结构体改进一下：</p>
<p>增加一个双亲域parentIndex，存储结点双亲在数组childLinkArr中的下标位置，如上图c)。</p>
<p>用C语言表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">childLinkArr</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">childLink</span> <span class="n">firstChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">parentIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">childLinkArr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="孩子兄弟链表表示法">孩子兄弟链表表示法</h4>
<p>如上图d)、e)所示，孩子兄弟链表的结构表示形式和二叉链表完全相同，只是结点含义不同：</p>
<ul>
<li>二叉链表，当前结点分为左孩子指针和右孩子指针。</li>
<li>孩子兄弟链表，当前结点分为首个左孩子指针（简称孩子指针）和兄弟结点指针，剩下的孩子通过遍历孩子指针的兄弟结点指针找到。</li>
</ul>
<p>用C语言表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">brotherNode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">brotherNode</span> <span class="o">*</span><span class="n">son</span><span class="p">,</span> <span class="o">*</span><span class="n">brother</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">treeLink</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="双亲表示法">双亲表示法</h4>
<p>如上图f)所示，是当中存储结构最简单的一种，同样也是采取数组的方式，由数据域+双亲域组成：</p>
<ul>
<li>数据域：将树T所有的结点按从上到下从左到右的顺序，结点从下标0开始，一一存进数组。</li>
<li>双亲域：存储双亲结点在数组中的下标位置，没有双亲存储-1。</li>
</ul>
<p>用C语言表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">parentIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Node</span> <span class="n">treeParentArr</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>疑问：</p>
<ol>
<li>只靠双亲怎么知道有哪些孩子？以及孩子的顺序？
<ul>
<li>答：
<ul>
<li>双亲parentIndex是同一个值的，就表示这些都是孩子。</li>
<li>因为存储已经按从左到右顺序存储，把同一个双亲的所有结点找出来，数组下标的顺序就是孩子直接的顺序，即保证了孩子之间的逻辑结构。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="树森林和二叉树之间的转换">树、森林和二叉树之间的转换</h3>
<h4 id="树转换成二叉树">树转换成二叉树</h4>
<p>转换方法：</p>
<ol>
<li>加线，所有兄弟结点之间加一条线，彼此连接起来。</li>
<li>抹线，除了结点的第一个左孩子，其他孩子与结点的连线全部抹掉。</li>
<li>旋转，以根节点为轴心，对树进行顺时针的适当旋转。</li>
</ol>
<h4 id="森林转换成二叉树">森林转换成二叉树</h4>
<p>转换方法：</p>
<ol>
<li>将森林中的每棵树转换成二叉树。</li>
<li>加线，转换以后的二叉树，从第二棵二叉树开始，将其根节点作为前一棵二叉树根结点的右子树，以此类推。</li>
</ol>
<h4 id="二叉树转换成森林">二叉树转换成森林</h4>
<p>转换方法：</p>
<ol>
<li>抹线，断开根结点与右孩子的连线，此时得到两棵二叉树。</li>
<li>抹线再加线，二叉树根节点的左子树的右子树们均断开连接，改成均与根节点之间连接，如果根节点有右子树，重复步骤1的操作。</li>
<li>剩下的二叉树重复按以上步骤进行处理。</li>
</ol>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<h4 id="树-1">树</h4>
<p>以图4.5的a)树为例。</p>
<h5 id="先序遍历-1">先序遍历</h5>
<ol>
<li>访问根结点</li>
<li>从左往右依次遍历孩子，以孩子为根节点，重复步骤1和步骤2。</li>
</ol>
<p>先序遍历次序为：HABEGFDC。</p>
<h5 id="后序遍历-1">后序遍历</h5>
<ol>
<li>后序遍历根的孩子子树。</li>
<li>访问根结点。</li>
</ol>
<p>后序遍历次序：BGFDEACH。</p>
<h5 id="层次遍历-1">层次遍历</h5>
<ol>
<li>访问根结点。</li>
<li>逐层往下遍历，每层从左到右依次访问结点。</li>
</ol>
<p>层次遍历次序：HACBEGFD。</p>
<h4 id="森林">森林</h4>
<p>森林有两种遍历方法：</p>
<h5 id="先序遍历-2">先序遍历</h5>
<ol>
<li>从左到右访问第一棵树的根结点。</li>
<li>先序遍历根结点的子树。</li>
<li>先序遍历森林中的其他树，重复以上步骤。</li>
</ol>
<h5 id="中序遍历-1">中序遍历</h5>
<ol>
<li>从左到右中序遍历第一棵树根结点的第一个孩子的子树。</li>
<li>访问第一棵树的根节点。</li>
<li>中序遍历剩下的孩子的子树。</li>
<li>中序遍历森林中的其他树，重复以上步骤。</li>
</ol>
<h2 id="判定树和哈夫曼树">判定树和哈夫曼树</h2>
<h3 id="分类和判定树">分类和判定树</h3>
<p>树有广泛的应用，其中一种重要的应用是描述分类的过程。</p>
<p>分类是一种常用的运算，将输入数据按照标准划分成不同的种类，例如：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>类别</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>年龄值 age</td>
<td>age &lt; 18</td>
<td>18 ≤ age ＜ 45</td>
<td>45 ≤ age ＜ 60</td>
<td>age ≥ 60</td>
</tr>
<tr>
<td>百分比</td>
<td>0.2</td>
<td>0.3</td>
<td>0.25</td>
<td>0.25</td>
</tr>
</tbody>
</table></div>
<p>插图..</p>
<p>用于描述分类过程的二叉树称为判定树，其中上图a)的分类算法为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="nf">classify</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">45</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设人口有N=10000人，C类别人口占25%，根据a)的判断树，区分1个人是否属于C类别需要进行3次比较，那么10000个人就需要$10000 \times 0.25 \times 3$，即7500次。</p>
<p>所有类别总共需要的比较次数就是：23000次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SUM = (N × 0.2 × 1) + (N × 0.3 × 2) + (N × 0.25 × 3) + (N × 0.25 × 3)
</span></span><span class="line"><span class="cl">    = N × (0.2 + 0.6 + 0.75 + 0.75)
</span></span><span class="line"><span class="cl">    = 10000 × 2.3
</span></span><span class="line"><span class="cl">    = 23000
</span></span></code></pre></td></tr></table>
</div>
</div><p>平均比较次数是：$SUM \div N$ 即$23000 \div 10000 = 2.3$次。</p>
<p>而如果是b)的判断树，区分1人属于C类别则只需要2次比较，10000个人则需要5000次。</p>
<p>所有类别总共需要比较20000次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SUM = (N × 0.2 × 2) + (N × 0.3 × 2) + (N × 0.25 × 2) + (N × 0.25 × 2)
</span></span><span class="line"><span class="cl">    = N × (0.4 + 0.6 + 0.5 + 0.5)
</span></span><span class="line"><span class="cl">    = 10000 × 2
</span></span><span class="line"><span class="cl">    = 20000
</span></span></code></pre></td></tr></table>
</div>
</div><p>平均比较次数是2次，相较a)，总共减少了3000次比较，平均比较次数减少了0.3次。</p>
<p>这说明，按不同判定树进行分类的计算量是不同的，有时可以相差很大，怎样才能构造出像b)一样，平均比较次数最少的判定树呢？</p>
<p>没错，可以用到哈夫曼树和哈夫曼算法。</p>
<h3 id="哈夫曼树和哈夫曼算法">哈夫曼树和哈夫曼算法</h3>
<p>以上面的例子为例，给定一组权值为{p<sub>1</sub>, &hellip;, p<sub>k</sub>}的序列，如何构造出一棵有k个叶子结点分别以权为值的判定树，并且平均比较次数是最小的？</p>
<p>步骤如下：</p>
<ol>
<li>根据一组权值为{p<sub>1</sub>, &hellip;, p<sub>k</sub>}的序列，构造森林F={T<sub>1</sub>, &hellip;, T<sub>k</sub>}，其中T<sub>i</sub>是一棵只有根结点，权为p<sub>i</sub>的二叉树。
<ul>
<li>如图a)。</li>
</ul>
</li>
<li>从F中选取两个权最小的两棵二叉树，组成一棵新的二叉树，左右孩子分别是两个权最小的二叉树
<ul>
<li>如图b)。</li>
</ul>
</li>
<li>从F中删掉步骤2已经合并的两棵二叉树，并将新的二叉树加入F，如图c)。</li>
<li>此时再看是否还有多个二叉树。
<ul>
<li>如果是，继续重复步骤2。</li>
<li><strong>直到只剩下一棵二叉树，这棵二叉树就是哈夫曼树</strong>，如图d)。</li>
</ul>
</li>
</ol>
<p><img src="https://ghjayce.github.io/asset/blog/4OiUp1uzsdo6MZlK1djyMjAyNDAyMjVfMTU0NzIz.png"
	width="666"
	height="511"
	
	loading="lazy"
	
		alt="哈夫曼树构建过程"
	
	
		class="gallery-image" 
		data-flex-grow="130"
		data-flex-basis="312px"
	
></p>
<p>从中得出规律：</p>
<ul>
<li>需要经过$n-1$次合并，最终得出一棵哈夫曼树，其中n是指权值的数目，以上面的例子，权值数目为4。</li>
<li>最终得到的哈夫曼树共有$2n-1$个结点，其中：
<ul>
<li>哈夫曼树没有度数为 1 的分支结点。</li>
</ul>
</li>
</ul>
<p>用C语言实现，即哈夫曼算法，采用顺序存储，大小是2n-1的数组，数组中的元素有四个域，分别是：</p>
<ul>
<li>权值。</li>
<li>双亲下标值。</li>
<li>左孩下标值。</li>
<li>右孩下标值。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;float.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">weigh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="n">lchild</span><span class="p">,</span> <span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">node</span> <span class="n">huffmanTree</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">huffman</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">weigh</span><span class="p">[],</span> <span class="n">huffmanTree</span> <span class="n">tree</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">lchild</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">rchild</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">weigh</span> <span class="o">=</span> <span class="n">weigh</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">weigh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">=</span> <span class="n">FLT_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="n">FLT_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">((</span><span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">weigh</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">parent</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">m</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">weigh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">weigh</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">parent</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">n</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">weigh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">].</span><span class="n">weigh</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">].</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="p">[</span><span class="n">size</span> <span class="o">+</span> <span class="n">index</span><span class="p">].</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="哈夫曼编码">哈夫曼编码</h3>
<p>在通信领域中，通常希望字符在传输过程中总的编码长度越短越好，即对字符的存储进行压缩，能否找到最短的编码方案呢？</p>
<p>没错，还是哈夫曼树，不过要加点编码。</p>
<p>思路：</p>
<ul>
<li>通过对字符出现次数进行统计，字符是值，权是出现次数或者叫出现频率。</li>
<li>让出现频率较多的字符采用较短的编码。</li>
<li>出现频率较少的字符采用较长的编码。</li>
</ul>
<p><strong>哈夫曼二叉树的每个结点的左分支标记为0，右分支为1（如下图f)），这样，从根结点到每个叶子结点的路径，把路径所在的分支标记全部加起来就是对应字符的编码，这些编码就称为哈夫曼编码</strong>。</p>
<p>例如：某个通信系统需要传输一个字符串”aaa bb cccc dd e“，它们出现的频率分别是：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>字符</th>
<th>a</th>
<th>&rsquo;&rsquo; (空)</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>频率</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table></div>
<p>频率序列从小到大排列后是：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>字符</th>
<th>e</th>
<th>b</th>
<th>d</th>
<th>a</th>
<th>&rsquo;&rsquo; (空)</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>频率</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table></div>
<p><img src="https://ghjayce.github.io/asset/blog/iIZT70Z6hkDVPzfarTAvMjAyNDAyMjVfMTU0ODM4.png"
	width="822"
	height="1100"
	
	loading="lazy"
	
		alt="哈夫曼树编码构建过程"
	
	
		class="gallery-image" 
		data-flex-grow="74"
		data-flex-basis="179px"
	
></p>
<p>经过哈夫曼树编码后，如上图f)，字符对应的编码分别是：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>字符</th>
<th>a</th>
<th>&rsquo;&rsquo; (空)</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>00</td>
<td>01</td>
<td>110</td>
<td>10</td>
<td>1111</td>
<td>1110</td>
</tr>
</tbody>
</table></div>
<p>即字符串”aaa bb cccc dd e“对应的编码序列为”0000000111011001101010100111111111011110“。</p>
<p>为了方便大家查看比对，用<code>|</code>对每个字符编码进行分开：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00|00|00|01|110|110|01|10|10|10|10|01|1111|1111|01|1110
</span></span></code></pre></td></tr></table>
</div>
</div><p>哈夫曼编码序列在还原成字符串的过程是，以上面的序列为例：</p>
<ol>
<li>拿接下来的第一个编码，即0，在哈夫曼树中寻找。</li>
<li>未找到，则把第一个编码和下一个编码加在一起，即00（a），继续在哈夫曼树中寻找。
<ul>
<li>没找到则一直重复步骤2。</li>
<li>找到了，即拿到了编码对应的字符串。</li>
</ul>
</li>
<li>重置这个过程，继续走步骤1，直至结束。</li>
</ol>
<h2 id="参考">参考</h2>
<ol>
<li><a class="link" href="https://blog.csdn.net/qq_42698422/article/details/105367284"  target="_blank" rel="noopener"
    >4.树与二叉树的转换</a></li>
<li><a class="link" href="https://blog.csdn.net/A12115419/article/details/126759251"  target="_blank" rel="noopener"
    >树与二叉树的转换</a></li>
<li><a class="link" href="https://zhuanlan.zhihu.com/p/415467000"  target="_blank" rel="noopener"
    >数据结构——哈夫曼树（Huffman Tree）</a></li>
<li><a class="link" href="https://blog.csdn.net/FX677588/article/details/70767446"  target="_blank" rel="noopener"
    >详细图解哈夫曼Huffman编码树</a></li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AE%BA/">数据结构导论</a>
        
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/">计算机科学与技术</a>
        
            <a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://unpkg.com/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://unpkg.com/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://unpkg.com/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/book/080901/02142/exam-focus/">
        
        
            <div class="article-image">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" data-key="book/080901/02142/exam-focus" data-hash="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">《数据结构导论》考试重点</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/book/080901/02142/chapter7/">
        
        
            <div class="article-image">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" data-key="book/080901/02142/chapter7" data-hash="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">第七章 排序 - 《数据结构导论》笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/book/080901/02142/chapter6/">
        
        
            <div class="article-image">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" data-key="book/080901/02142/chapter6" data-hash="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">第六章 查找 - 《数据结构导论》笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/book/080901/02142/chapter5/">
        
        
            <div class="article-image">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" data-key="book/080901/02142/chapter5" data-hash="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">第五章 图 - 《数据结构导论》笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/book/080901/02142/chapter3/">
        
        
            <div class="article-image">
                
                    <img src="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png" loading="lazy" data-key="book/080901/02142/chapter3" data-hash="https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">第三章 栈、队列和数组 - 《数据结构导论》笔记</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2023 - 
        
        2024 GHJayce
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.21.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://unpkg.com/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://unpkg.com/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://unpkg.com/photoswipe@4.1.3/dist/default-skin/default-skin.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://unpkg.com/photoswipe@4.1.3/dist/photoswipe.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://unpkg.com/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
