[{"content":"阅读说明 软件版本 Laravel v11.9.2 前言 主要介绍singleton做了哪些事情、作用、为什么要这么做以及最终调用时（make）的过程。\n涉及到singleton和make的源码过程。\nIlluminate\\Container\\Container::singleton 绑定一个单例，官方文档的解释：\nsingleton 方法（绑定单例）将类或接口绑定到容器中，该类或接口只能解析一次。一旦解决了单一实例绑定，在对容器的后续调用中，将返回相同的对象实例：\n看完本文以后好好细品这段解释。\n1 2 3 4 5 6 7 use App\\Services\\Transistor; use App\\Services\\PodcastParser; use Illuminate\\Contracts\\Foundation\\Application; $this-\u0026gt;app-\u0026gt;singleton(Transistor::class, function (Application $app) { return new Transistor($app-\u0026gt;make(PodcastParser::class)); }); 上源码Illuminate\\Container\\Container：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 /** * The container\u0026#39;s bindings. * * @var array[] */ protected $bindings = []; /** * The container\u0026#39;s shared instances. * * @var object[] */ protected $instances = []; /** * The registered type aliases. * * @var string[] */ protected $aliases = []; /** * An array of the types that have been resolved. * * @var bool[] */ protected $resolved = []; /** * All of the registered rebound callbacks. * * @var array[] */ protected $reboundCallbacks = []; /** * Register a shared binding in the container. * * @param string $abstract * @param \\Closure|string|null $concrete * @return void */ public function singleton($abstract, $concrete = null) { $this-\u0026gt;bind($abstract, $concrete, true); } /** * Register a binding with the container. * * @param string $abstract * @param \\Closure|string|null $concrete * @param bool $shared * @return void * * @throws \\TypeError */ public function bind($abstract, $concrete = null, $shared = false) { $this-\u0026gt;dropStaleInstances($abstract); // If no concrete type was given, we will simply set the concrete type to the // abstract type. After that, the concrete type to be registered as shared // without being forced to state their classes in both of the parameters. if (is_null($concrete)) { $concrete = $abstract; } // If the factory is not a Closure, it means it is just a class name which is // bound into this container to the abstract type and we will just wrap it // up inside its own Closure to give us more convenience when extending. if (! $concrete instanceof Closure) { if (! is_string($concrete)) { throw new TypeError(self::class.\u0026#39;::bind(): Argument #2 ($concrete) must be of type Closure|string|null\u0026#39;); } $concrete = $this-\u0026gt;getClosure($abstract, $concrete); } $this-\u0026gt;bindings[$abstract] = compact(\u0026#39;concrete\u0026#39;, \u0026#39;shared\u0026#39;); // If the abstract type was already resolved in this container we\u0026#39;ll fire the // rebound listener so that any objects which have already gotten resolved // can have their copy of the object updated via the listener callbacks. if ($this-\u0026gt;resolved($abstract)) { $this-\u0026gt;rebound($abstract); } } /** * Drop all of the stale instances and aliases. * * @param string $abstract * @return void */ protected function dropStaleInstances($abstract) { unset($this-\u0026gt;instances[$abstract], $this-\u0026gt;aliases[$abstract]); } /** * Get the Closure to be used when building a type. * * @param string $abstract * @param string $concrete * @return \\Closure */ protected function getClosure($abstract, $concrete) { return function ($container, $parameters = []) use ($abstract, $concrete) { if ($abstract == $concrete) { return $container-\u0026gt;build($concrete); } return $container-\u0026gt;resolve( $concrete, $parameters, $raiseEvents = false ); }; } /** * Determine if the given abstract type has been resolved. * * @param string $abstract * @return bool */ public function resolved($abstract) { if ($this-\u0026gt;isAlias($abstract)) { $abstract = $this-\u0026gt;getAlias($abstract); } return isset($this-\u0026gt;resolved[$abstract]) || isset($this-\u0026gt;instances[$abstract]); } /** * Determine if a given string is an alias. * * @param string $name * @return bool */ public function isAlias($name) { return isset($this-\u0026gt;aliases[$name]); } /** * Get the alias for an abstract if available. * * @param string $abstract * @return string */ public function getAlias($abstract) { return isset($this-\u0026gt;aliases[$abstract]) ? $this-\u0026gt;getAlias($this-\u0026gt;aliases[$abstract]) : $abstract; } /** * Fire the \u0026#34;rebound\u0026#34; callbacks for the given abstract type. * * @param string $abstract * @return void */ protected function rebound($abstract) { $instance = $this-\u0026gt;make($abstract); foreach ($this-\u0026gt;getReboundCallbacks($abstract) as $callback) { $callback($this, $instance); } } /** * Get the rebound callbacks for a given type. * * @param string $abstract * @return array */ protected function getReboundCallbacks($abstract) { return $this-\u0026gt;reboundCallbacks[$abstract] ?? []; } 在这里你可以把make想象成一个黑匣子，它会把你给的抽象处理成实例返回给你，并且这个过程中会替你解决抽象所需的各种依赖参数（这就是依赖注入dependency injection）。\n重点看bind()方法做的事情：\nP1：删除过时的实例。 P2：具体（concrete）是空时，具体就是抽象（abstract）。 P3：具体不是匿名函数，而是字符串时，将具体处理成匿名函数。 P4：将抽象和具体（此时是匿名函数）作为key value，设置到正在绑定中的对象（bindings）。 P5：当抽象已被解决（resolved）或者已有实例（instances）时，进行篮板球（rebound）处理，将抽象重新实例化并调用抽象设置的回调函数（reboundCallbacks）。 疑问 Q1：P1为什么需要从已有实例和别名中删除抽象？ Q2：P2什么情况下具体可以是空的？ Q3：P3为什么要将具体处理成匿名函数，目的是什么？ Q4：P4设置到正在绑定中的对象的目的是什么？ Q5：P5什么场景下需要执行篮板球？ Q6：绑定的单例什么时候会被调用？ 例子 来看具体的调用例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use Illuminate\\Foundation\\PackageManifest; use Illuminate\\Foundation\\Mix; use Illuminate\\Filesystem\\Filesystem; // 例子A $this-\u0026gt;singleton(PackageManifest::class, fn () =\u0026gt; new PackageManifest( new Filesystem, $this-\u0026gt;basePath(), $this-\u0026gt;getCachedPackagesPath() )); // 例子B $this-\u0026gt;singleton(Mix::class); // 例子C $this-\u0026gt;app-\u0026gt;singleton( \\Illuminate\\Contracts\\Http\\Kernel::class, \\Illuminate\\Foundation\\Http\\Kernel::class, ); 例子A 定义处\\Illuminate\\Foundation\\Application：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Register the basic bindings into the container. * * @return void */ protected function registerBaseBindings() { static::setInstance($this); $this-\u0026gt;instance(\u0026#39;app\u0026#39;, $this); $this-\u0026gt;instance(Container::class, $this); $this-\u0026gt;singleton(Mix::class); $this-\u0026gt;singleton(PackageManifest::class, fn () =\u0026gt; new PackageManifest( new Filesystem, $this-\u0026gt;basePath(), $this-\u0026gt;getCachedPackagesPath() )); } 调用有两处：\nA1：\\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::bootstrap。 A2：\\Illuminate\\Foundation\\Application::registerConfiguredProviders。 A1要比A2先调用。\nA1 先来看A1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Bootstrap the given application. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @return void */ public function bootstrap(Application $app) { Facade::clearResolvedInstances(); Facade::setFacadeApplication($app); AliasLoader::getInstance(array_merge( $app-\u0026gt;make(\u0026#39;config\u0026#39;)-\u0026gt;get(\u0026#39;app.aliases\u0026#39;, []), $app-\u0026gt;make(PackageManifest::class)-\u0026gt;aliases() ))-\u0026gt;register(); } 可以看到调用了make进行实例化。\nmake关键代码\\Illuminate\\Foundation\\Application：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Resolve the given type from the container. * * @param string $abstract * @param array $parameters * @return mixed */ public function make($abstract, array $parameters = []) { $this-\u0026gt;loadDeferredProviderIfNeeded($abstract = $this-\u0026gt;getAlias($abstract)); return parent::make($abstract, $parameters); } \\Illuminate\\Container\\Container：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 /** * Resolve the given type from the container. * * @param string|callable $abstract * @param array $parameters * @return mixed * * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException */ public function make($abstract, array $parameters = []) { return $this-\u0026gt;resolve($abstract, $parameters); } /** * Resolve the given type from the container. * * @param string|callable $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException * @throws \\Illuminate\\Contracts\\Container\\CircularDependencyException */ protected function resolve($abstract, $parameters = [], $raiseEvents = true) { ... if (is_null($concrete)) { $concrete = $this-\u0026gt;getConcrete($abstract); } // We\u0026#39;re ready to instantiate an instance of the concrete type registered for // the binding. This will instantiate the types, as well as resolve any of // its \u0026#34;nested\u0026#34; dependencies recursively until all have gotten resolved. $object = $this-\u0026gt;isBuildable($concrete, $abstract) ? $this-\u0026gt;build($concrete) : $this-\u0026gt;make($concrete); ... // If the requested type is registered as a singleton we\u0026#39;ll want to cache off // the instances in \u0026#34;memory\u0026#34; so we can return it later without creating an // entirely new instance of an object on each subsequent request for it. if ($this-\u0026gt;isShared($abstract) \u0026amp;\u0026amp; ! $needsContextualBuild) { $this-\u0026gt;instances[$abstract] = $object; } ... // Before returning, we will also set the resolved flag to \u0026#34;true\u0026#34; and pop off // the parameter overrides for this build. After those two things are done // we will be ready to return back the fully constructed class instance. $this-\u0026gt;resolved[$abstract] = true; return $object; } /** * Get the concrete type for a given abstract. * * @param string|callable $abstract * @return mixed */ protected function getConcrete($abstract) { // If we don\u0026#39;t have a registered resolver or concrete for the type, we\u0026#39;ll just // assume each type is a concrete name and will attempt to resolve it as is // since the container should be able to resolve concretes automatically. if (isset($this-\u0026gt;bindings[$abstract])) { return $this-\u0026gt;bindings[$abstract][\u0026#39;concrete\u0026#39;]; } return $abstract; } /** * Determine if the given concrete is buildable. * * @param mixed $concrete * @param string $abstract * @return bool */ protected function isBuildable($concrete, $abstract) { return $concrete === $abstract || $concrete instanceof Closure; } /** * Instantiate a concrete instance of the given type. * * @param \\Closure|string $concrete * @return mixed * * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException * @throws \\Illuminate\\Contracts\\Container\\CircularDependencyException */ public function build($concrete) { // If the concrete type is actually a Closure, we will just execute it and // hand back the results of the functions, which allows functions to be // used as resolvers for more fine-tuned resolution of these objects. if ($concrete instanceof Closure) { return $concrete($this, $this-\u0026gt;getLastParameterOverride()); } ... } 例子A经过绑定单例处理后，bindings对应结构在make调用时大致如下：\n1 2 3 4 5 6 7 8 [ \u0026#39;Illuminate\\Foundation\\PackageManifest\u0026#39; =\u0026gt; [ \u0026#39;shared\u0026#39; =\u0026gt; true, \u0026#39;concrete\u0026#39; =\u0026gt; function () { return new PackageMainifest(new Filesystem, \u0026#39;/system_path/path/your_project\u0026#39;, \u0026#39;/system_path/path/your_project/bootstrap/cache/packages.php\u0026#39;) } ] ] 注意这里concrete展示的匿名函数为了方便演示稍作了处理。\nmake从bindings.Illuminate\\Foundation\\PackageManifest.concrete取出匿名函数，再进到build()函数中执行了该匿名函数。\n因为singleton（shared: true）的缘故，首次make时（指A1）会把实例（concrete匿名函数的调用结果）设置到容器的instances成员属性中，后续再make的时候（指A2）会直接从instances中取出。\n这样实现的好处：\n可以在需要用到抽象的时候再从bindings中取出提前预定义好实例化的方式进行实例化（回答Q3、Q6）。 统一处理成匿名函数（第一个参数是Illuminate\\Foundation\\Application容器，第二个参数则是传递给make的第二个参数），统一口径方便make时处理（回答Q3）。就好比有了SAPI接口规范，就能通过不同的方式实现PHP与各种web服务器或服务打交道，比如CLI、CGI和FastCGI都是根据规范实现的模块。 设置到bindings是为了在make的时候可以取到预定义的绑定。（回答Q4）\nA2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Register all of the configured providers. * * @return void */ public function registerConfiguredProviders() { $providers = Collection::make($this-\u0026gt;make(\u0026#39;config\u0026#39;)-\u0026gt;get(\u0026#39;app.providers\u0026#39;)) -\u0026gt;partition(fn ($provider) =\u0026gt; str_starts_with($provider, \u0026#39;Illuminate\\\\\u0026#39;)); $providers-\u0026gt;splice(1, 0, [$this-\u0026gt;make(PackageManifest::class)-\u0026gt;providers()]); (new ProviderRepository($this, new Filesystem, $this-\u0026gt;getCachedServicesPath())) -\u0026gt;load($providers-\u0026gt;collapse()-\u0026gt;toArray()); $this-\u0026gt;fireAppCallbacks($this-\u0026gt;registeredCallbacks); } 关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected function resolve($abstract, $parameters = [], $raiseEvents = true) { ... // If an instance of the type is currently being managed as a singleton we\u0026#39;ll // just return an existing instance instead of instantiating new instances // so the developer can keep using the same objects instance every time. if (isset($this-\u0026gt;instances[$abstract]) \u0026amp;\u0026amp; ! $needsContextualBuild) { return $this-\u0026gt;instances[$abstract]; } ... if (is_null($concrete)) { $concrete = $this-\u0026gt;getConcrete($abstract); } ... } 例子B 定义处在例子A已经贴过了，这里就不重复贴了。\n调用处：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 if (! function_exists(\u0026#39;mix\u0026#39;)) { /** * Get the path to a versioned Mix file. * * @param string $path * @param string $manifestDirectory * @return \\Illuminate\\Support\\HtmlString|string * * @throws \\Exception */ function mix($path, $manifestDirectory = \u0026#39;\u0026#39;) { return app(Mix::class)(...func_get_args()); } } if (! function_exists(\u0026#39;app\u0026#39;)) { /** * Get the available container instance. * * @param string|null $abstract * @param array $parameters * @return \\Illuminate\\Contracts\\Foundation\\Application|\\Illuminate\\Foundation\\Application|mixed */ function app($abstract = null, array $parameters = []) { if (is_null($abstract)) { return Container::getInstance(); } return Container::getInstance()-\u0026gt;make($abstract, $parameters); } } 经过singleton处理以后，bindings结构大致如下：\n1 2 3 4 5 6 7 8 [ \u0026#39;Illuminate\\Foundation\\Mix\u0026#39; =\u0026gt; [ \u0026#39;shared\u0026#39; =\u0026gt; true, \u0026#39;concrete\u0026#39; =\u0026gt; function ($container, $parameters = []) { return $container-\u0026gt;build(\u0026#39;Illuminate\\Foundation\\Mix\u0026#39;); } ] ] 注意这里的concrete匿名函数为了演示稍加处理。\n和例子A类似，不多做赘述，只讲差异的地方。\nconcrete匿名函数被build调用，然后又执行匿名函数中的build，即\\Illuminate\\Foundation\\Application::build即\\Illuminate\\Container\\Container::build ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public function build($concrete) { ... try { $reflector = new ReflectionClass($concrete); } catch (ReflectionException $e) { throw new BindingResolutionException(\u0026#34;Target class [$concrete] does not exist.\u0026#34;, 0, $e); } // If the type is not instantiable, the developer is attempting to resolve // an abstract type such as an Interface or Abstract Class and there is // no binding registered for the abstractions so we need to bail out. if (! $reflector-\u0026gt;isInstantiable()) { return $this-\u0026gt;notInstantiable($concrete); } ... $constructor = $reflector-\u0026gt;getConstructor(); // If there are no constructors, that means there are no dependencies then // we can just resolve the instances of the objects right away, without // resolving any other types or dependencies out of these containers. if (is_null($constructor)) { ... return new $concrete; } ... } 做了以下几件事：\n用ReflectionClass反射Illuminate\\Foundation\\Mix类。 检查类是否可实例化，不能就会抛Illuminate\\Contracts\\Container\\BindingResolutionException异常。 然后再检查是否有构造函数，Mix类没有，所以最后用new进行实例化。 如果有构造函数会怎样？看接下来的例子C。 如果你提供的类非常简单，甚至都没有构造函数，抽象即具体，而且需要单例的情况下，就可以使用singleton只传一个参数（回答Q2）。\n例子C 定义处Illuminate\\Foundation\\Configuration\\ApplicationBuilder：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Register the standard kernel classes for the application. * * @return $this */ public function withKernels() { $this-\u0026gt;app-\u0026gt;singleton( \\Illuminate\\Contracts\\Http\\Kernel::class, \\Illuminate\\Foundation\\Http\\Kernel::class, ); $this-\u0026gt;app-\u0026gt;singleton( \\Illuminate\\Contracts\\Console\\Kernel::class, \\Illuminate\\Foundation\\Console\\Kernel::class, ); return $this; } 调用处Illuminate\\Foundation\\Application：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use Illuminate\\Contracts\\Http\\Kernel as HttpKernelContract; /** * Handle the incoming HTTP request and send the response to the browser. * * @param \\Illuminate\\Http\\Request $request * @return void */ public function handleRequest(Request $request) { $kernel = $this-\u0026gt;make(HttpKernelContract::class); $response = $kernel-\u0026gt;handle($request)-\u0026gt;send(); $kernel-\u0026gt;terminate($request, $response); } 经过singleton处理以后，bindings结构大致如下：\n1 2 3 4 5 6 7 8 [ \u0026#39;Illuminate\\Contracts\\Http\\Kernel::class\u0026#39; =\u0026gt; [ \u0026#39;shared\u0026#39; =\u0026gt; true, \u0026#39;concrete\u0026#39; =\u0026gt; function ($container, $parameters = []) { return $container-\u0026gt;resolve(\u0026#39;Illuminate\\Foundation\\Http\\Kernel\u0026#39;, [], false); } ] ] 注意这里的concrete匿名函数为了演示稍加处理。\n看一眼Illuminate\\Foundation\\Http\\Kernel：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use Illuminate\\Contracts\\Foundation\\Application; use Illuminate\\Routing\\Router; /** * Create a new HTTP kernel instance. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @param \\Illuminate\\Routing\\Router $router * @return void */ public function __construct(Application $app, Router $router) { $this-\u0026gt;app = $app; $this-\u0026gt;router = $router; $this-\u0026gt;syncMiddlewareToRouter(); } 同样只讲差异的部分。\n和例子A、B一样，经过make-\u0026gt;resolve，concrete匿名函数被build调用。\n然后会执行匿名函数中的resolve，即Illuminate\\Foundation\\Application::resolve然后Illuminate\\Container\\Container::resolve：\n可以看到第三个参数raiseEvents为false，作用是不会经过头尾的钩子函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 protected function resolve($abstract, $parameters = [], $raiseEvents = true) { ... if (is_null($concrete)) { $concrete = $this-\u0026gt;getConcrete($abstract); } $object = $this-\u0026gt;isBuildable($concrete, $abstract) ? $this-\u0026gt;build($concrete) : $this-\u0026gt;make($concrete); ... if ($this-\u0026gt;isShared($abstract) \u0026amp;\u0026amp; ! $needsContextualBuild) { $this-\u0026gt;instances[$abstract] = $object; } ... $this-\u0026gt;resolved[$abstract] = true; ... return $object; } Illuminate\\Foundation\\Http\\Kernel最终会被build调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public function build($concrete) { ... try { $reflector = new ReflectionClass($concrete); } catch (ReflectionException $e) { throw new BindingResolutionException(\u0026#34;Target class [$concrete] does not exist.\u0026#34;, 0, $e); } ... $this-\u0026gt;buildStack[] = $concrete; $constructor = $reflector-\u0026gt;getConstructor(); ... $dependencies = $constructor-\u0026gt;getParameters(); // Once we have all the constructor\u0026#39;s parameters we can create each of the // dependency instances and then use the reflection instances to make a // new instance of this class, injecting the created dependencies in. try { $instances = $this-\u0026gt;resolveDependencies($dependencies); } catch (BindingResolutionException $e) { array_pop($this-\u0026gt;buildStack); throw $e; } array_pop($this-\u0026gt;buildStack); return $reflector-\u0026gt;newInstanceArgs($instances); } 区别例子B的地方在于，这次是有构造函数了，而且有两个类参数Illuminate\\Contracts\\Foundation\\Application和Illuminate\\Routing\\Router。在经过依赖注入处理以后（依赖注入不在本文讨论范文内，不过多开展），会将实例化好的参数传给Kernel的反射类的newInstanceArgs进行实例化。\n到这里阅读基本结束了，三种情况基本都能覆盖到关键的地方。\n回答一下Q1的疑问，需要从instances删除抽象答案很明显，因为make完以后会将实例设置到instances中。至于为什么要从aliases中删除抽象，是因为make中有从aliases获取抽象，这个和aliases的作用有关，也不开展了，不删的话肯定会干扰到make的逻辑。\n至于Q5，暂时还没找到例子，留点优化空间（狗头，后面遇到了再做补充）。\n总结 singleton、make大致逻辑和使用过程：\n将你提供的抽象（abstract）和具体（concrete），将具体统一处理成匿名函数（Closure），绑定（抽象 =\u0026gt; 具体）在容器的bindings成员属性（数组）中，后续你想用的时候，通过make调用，从bindings属性中取出匿名函数，如果匿名函数是你提供的，就按你定义的来实例化，否则会先反射该类（ReflectionClass），检查类是否可实例化（isInstantiable()），不能会抛异常（BindingResolutionException），再检查是否有构造函数（getConstructor()），没有会通过new实例化返回，有则再根据构造函数的参数（getParameters()）通过依赖注入（resolveDependencies()）解决参数依赖问题，最后调用反射类的newInstanceArgs()的方式实例化。最后将实例化的类（抽象=\u0026gt;实例）设置到容器的instances成员属性（数组）中，并且将resolved成员属性（数组）中将抽象标记为true，代表着该抽象已完成了实例化处理，下次再make时可以直接从instances（通过isset该属性来判断）中取出。\n","date":"2024-08-15T15:08:14+08:00","permalink":"/p/language/php/laravel/container-singleton/","title":"Laravel源码阅读之Container singleton与make"},{"content":"前言 软件版本 Laravel v11.9.2 PHP v8.2.8 疑问 Q1：访问入口文件时做了哪些事情？ Q2：首次和非首次的访问，做的事情有什么区别？ Q3：php artisan做了哪些事情？ Q4：php artisan serve做了哪些事情？ 入口文件 先看下入口文件代码public/index.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php use Illuminate\\Http\\Request; define(\u0026#39;LARAVEL_START\u0026#39;, microtime(true)); // Determine if the application is in maintenance mode... if (file_exists($maintenance = __DIR__.\u0026#39;/../storage/framework/maintenance.php\u0026#39;)) { require $maintenance; } // Register the Composer autoloader... require __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; // Bootstrap Laravel and handle the request... (require_once __DIR__.\u0026#39;/../bootstrap/app.php\u0026#39;) -\u0026gt;handleRequest(Request::capture()); 分为4个部分：\nLARAVEL_START常量声明，猜测和记录运行时间有关。 maintenance.php这块是维护模式，通过php artisan down命令生成文件并启用，访问应用会得到503的响应。 vendor/autoload.php则是引入composer的自动加载。 bootstrap/app.php重点之一，laravel框架的引导程序，做了初始化laravel的工作。 Request::capture()，capture捕获、数据或信息的获取，不得不说起名是真讲究。基于symfony的Request（初始化$_GET、$_POST、$_COOKIE等超全局变量）创建laravel自己的Request实例。 handleRequest重点之一，处理HTTP的请求和响应。 QE1：为什么引导程序要用require_once引入？而其他部分是require？\n引导程序 再来看bootstrap/app.php代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php use Illuminate\\Foundation\\Application; use Illuminate\\Foundation\\Configuration\\Exceptions; use Illuminate\\Foundation\\Configuration\\Middleware; return Application::configure(basePath: dirname(__DIR__)) -\u0026gt;withRouting( web: __DIR__.\u0026#39;/../routes/web.php\u0026#39;, commands: __DIR__.\u0026#39;/../routes/console.php\u0026#39;, health: \u0026#39;/up\u0026#39;, ) -\u0026gt;withMiddleware(function (Middleware $middleware) { // }) -\u0026gt;withExceptions(function (Exceptions $exceptions) { // })-\u0026gt;create(); 见码知意，一看大概也能猜到一些：\nApplication::configure，创建laravel应用实例，设置根目录路径。 withRouting注册路由服务，有web路由和终端控制台的配置文件，health是一个内置的web路由配置，主要用于监控应用程序和检查路由的状态，可以与Kubernetes结合使用。 withMiddleware注册全局中间件、中间件组和中间件别名。 withExceptions注册和配置异常处理程序。 create返回Illuminate\\Foundation\\Application实例本身。 创建Laravel应用实例 Application::configure \\Illuminate\\Foundation\\Application::configure代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Begin configuring a new Laravel application instance. * * @param string|null $basePath * @return \\Illuminate\\Foundation\\Configuration\\ApplicationBuilder */ public static function configure(?string $basePath = null) { $basePath = match (true) { is_string($basePath) =\u0026gt; $basePath, default =\u0026gt; static::inferBasePath(), }; return (new Configuration\\ApplicationBuilder(new static($basePath))) -\u0026gt;withKernels() -\u0026gt;withEvents() -\u0026gt;withCommands() -\u0026gt;withProviders(); } 设置根目录路径用了8.0的新特性match。\nApplication::__construct 后面的代码稍后再看，先看实例化自己这块，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Create a new Illuminate application instance. * * @param string|null $basePath * @return void */ public function __construct($basePath = null) { if ($basePath) { $this-\u0026gt;setBasePath($basePath); } $this-\u0026gt;registerBaseBindings(); $this-\u0026gt;registerBaseServiceProviders(); $this-\u0026gt;registerCoreContainerAliases(); } 4个部分：\nsetBasePath注册内定目录的绝对路径，例如/xxx/xxx/project/app、/xxx/xxx/project/config等。 registerBaseBindings registerBaseServiceProviders registerCoreContainerAliases 提一嘴，laravel应用继承于\\Illuminate\\Container\\Container容器。\nApplication::setBasePath 一点点来，看它是怎么设置根目录路径的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * Set the base path for the application. * * @param string $basePath * @return $this */ public function setBasePath($basePath) { $this-\u0026gt;basePath = rtrim($basePath, \u0026#39;\\/\u0026#39;); $this-\u0026gt;bindPathsInContainer(); return $this; } /** * Bind all of the application paths in the container. * * @return void */ protected function bindPathsInContainer() { $this-\u0026gt;instance(\u0026#39;path\u0026#39;, $this-\u0026gt;path()); $this-\u0026gt;instance(\u0026#39;path.base\u0026#39;, $this-\u0026gt;basePath()); $this-\u0026gt;instance(\u0026#39;path.config\u0026#39;, $this-\u0026gt;configPath()); $this-\u0026gt;instance(\u0026#39;path.database\u0026#39;, $this-\u0026gt;databasePath()); $this-\u0026gt;instance(\u0026#39;path.public\u0026#39;, $this-\u0026gt;publicPath()); $this-\u0026gt;instance(\u0026#39;path.resources\u0026#39;, $this-\u0026gt;resourcePath()); $this-\u0026gt;instance(\u0026#39;path.storage\u0026#39;, $this-\u0026gt;storagePath()); $this-\u0026gt;useBootstrapPath(value(function () { return is_dir($directory = $this-\u0026gt;basePath(\u0026#39;.laravel\u0026#39;)) ? $directory : $this-\u0026gt;basePath(\u0026#39;bootstrap\u0026#39;); })); $this-\u0026gt;useLangPath(value(function () { return is_dir($directory = $this-\u0026gt;resourcePath(\u0026#39;lang\u0026#39;)) ? $directory : $this-\u0026gt;basePath(\u0026#39;lang\u0026#39;); })); } 注册了各种目录路径，例如：\npath对应根目录的app目录，例如：/system_path/path/your_project/app。 path.base对应根目录，例如：/system_path/path/your_project。 useBootstrapPath和useLangPath同样也是注册路径，不展开赘述。 了解更多目录结构作用。\nContainer::instance 重点看\\Illuminate\\Container\\Container::instance方法，作用是将现有的实例注册为容器中的共享实例，参数分别是抽象和实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Register an existing instance as shared in the container. * * @param string $abstract * @param mixed $instance * @return mixed */ public function instance($abstract, $instance) { $this-\u0026gt;removeAbstractAlias($abstract); $isBound = $this-\u0026gt;bound($abstract); unset($this-\u0026gt;aliases[$abstract]); // We\u0026#39;ll check to determine if this type has been bound before, and if it has // we will fire the rebound callbacks registered with the container and it // can be updated with consuming classes that have gotten resolved here. $this-\u0026gt;instances[$abstract] = $instance; if ($isBound) { $this-\u0026gt;rebound($abstract); } return $instance; } 注册关键代码是：$this-\u0026gt;instances[$abstract] = $instance;由此可见，$instance并非一定是一个类对象。\nremoveAbstractAlias删除抽象别名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Remove an alias from the contextual binding alias cache. * * @param string $searched * @return void */ protected function removeAbstractAlias($searched) { if (! isset($this-\u0026gt;aliases[$searched])) { return; } foreach ($this-\u0026gt;abstractAliases as $abstract =\u0026gt; $aliases) { foreach ($aliases as $index =\u0026gt; $alias) { if ($alias == $searched) { unset($this-\u0026gt;abstractAliases[$abstract][$index]); } } } } 有两个抽象别名的对象属性，分别是aliases和abstractAliases。\naliases数据结构参考如下：\n1 2 3 4 5 [ \u0026#39;namespace\\\\xxx\\\\classA1\u0026#39; =\u0026gt; \u0026#39;abstract_nameA\u0026#39;, \u0026#39;namespace\\\\xxx\\\\classA2\u0026#39; =\u0026gt; \u0026#39;abstract_nameA\u0026#39;, ... ] abstractAliases数据结构参考如下：\n1 2 3 4 5 [ \u0026#39;abstract_nameA\u0026#39; =\u0026gt; [\u0026#39;namespace\\\\xxx\\\\classA1\u0026#39;, \u0026#39;namespace\\\\xxx\\\\classA2\u0026#39;, ...], \u0026#39;abstract_nameB\u0026#39; =\u0026gt; [\u0026#39;namespace\\\\xxx\\\\classB1\u0026#39;, \u0026#39;namespace\\\\xxx\\\\classB2\u0026#39;, ...], ... ] bound检查抽象是否已被绑定过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Determine if the given abstract type has been bound. * * @param string $abstract * @return bool */ public function bound($abstract) { return isset($this-\u0026gt;bindings[$abstract]) || isset($this-\u0026gt;instances[$abstract]) || $this-\u0026gt;isAlias($abstract); } /** * Determine if a given string is an alias. * * @param string $name * @return bool */ public function isAlias($name) { return isset($this-\u0026gt;aliases[$name]); } 又有两个对象属性，bindings和instances。\nbindings数据结构参考如下：\n1 2 3 4 5 6 7 [ \u0026#39;namespace\\\\xxx\\\\class\u0026#39; =\u0026gt; [ \u0026#39;concrete\u0026#39; =\u0026gt; Closure Object, \u0026#39;shared\u0026#39; =\u0026gt; true, ], ... ] 接着是unset($this-\u0026gt;aliases[$abstract]);删除抽象别名。\nQE2：为什么不放进removeAbstractAlias方法里面进行呢？\n最后是rebound，当抽象被绑定过时，会进行重新绑定，即更新。\n这块我们后面再看，目前逻辑还走不进这里，回去做主线任务要紧。\nApplication::registerBaseBindings 将基本绑定注册到容器中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Register the basic bindings into the container. * * @return void */ protected function registerBaseBindings() { static::setInstance($this); $this-\u0026gt;instance(\u0026#39;app\u0026#39;, $this); $this-\u0026gt;instance(Container::class, $this); $this-\u0026gt;singleton(Mix::class); $this-\u0026gt;singleton(PackageManifest::class, fn () =\u0026gt; new PackageManifest( new Filesystem, $this-\u0026gt;basePath(), $this-\u0026gt;getCachedPackagesPath() )); } 设置容器的静态属性instance。 注册app、\\Illuminate\\Container\\Container抽象和实例到容器中。 注册\\Illuminate\\Foundation\\Mix类的单例绑定，最后会处理成类名（含命名空间）=\u0026gt; ['concrete' =\u0026gt; 匿名函数, 'shared' =\u0026gt; bool]的数据结构写入到容器的bindings成员属性中。 Laravel Mix是Jeffrey Way开发的一个包，通过webpack编译css和js文件。而在新版的laravel（framework v9.19.0），vite取代了mix。 既然被取代了为啥还要注册它呢？估计是为了兼容旧版本吧。 注册\\Illuminate\\Foundation\\PackageManifest类的单例绑定，该类的作用是扫描./vendor/composer/installed.json，里面的内容是项目已安装的依赖包的composer.json文件的合集，主要是收集依赖包设置extra.laravel的属性，多数是服务提供者（ServiceProvider），收集以后会处理成包名 =\u0026gt; [其在composer设置的extra.laravel]的数组，并将该数组缓存到./bootstrap/cache/packages.php中，其中bootstrap和composer的目录均可以配置。目前仅仅是注册而已，还没有执行。 Application::registerBaseServiceProviders 接着是注册基础服务提供者。\n1 2 3 4 5 6 7 8 9 10 11 12 /** * Register all of the base service providers. * * @return void */ protected function registerBaseServiceProviders() { $this-\u0026gt;register(new EventServiceProvider($this)); $this-\u0026gt;register(new LogServiceProvider($this)); $this-\u0026gt;register(new ContextServiceProvider($this)); $this-\u0026gt;register(new RoutingServiceProvider($this)); } 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 /** * Fire the \u0026#34;rebound\u0026#34; callbacks for the given abstract type. * * @param string $abstract * @return void */ protected function rebound($abstract) { $instance = $this-\u0026gt;make($abstract); foreach ($this-\u0026gt;getReboundCallbacks($abstract) as $callback) { $callback($this, $instance); } } /** * Get the rebound callbacks for a given type. * * @param string $abstract * @return array */ protected function getReboundCallbacks($abstract) { return $this-\u0026gt;reboundCallbacks[$abstract] ?? []; } /** * Resolve the given type from the container. * * @param string|callable $abstract * @param array $parameters * @return mixed * * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException */ public function make($abstract, array $parameters = []) { return $this-\u0026gt;resolve($abstract, $parameters); } /** * Resolve the given type from the container. * * @param string|callable $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \\Illuminate\\Contracts\\Container\\BindingResolutionException * @throws \\Illuminate\\Contracts\\Container\\CircularDependencyException */ protected function resolve($abstract, $parameters = [], $raiseEvents = true) { $abstract = $this-\u0026gt;getAlias($abstract); if ($raiseEvents) { $this-\u0026gt;fireBeforeResolvingCallbacks($abstract, $parameters); } $concrete = $this-\u0026gt;getContextualConcrete($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($concrete); if (isset($this-\u0026gt;instances[$abstract]) \u0026amp;\u0026amp; ! $needsContextualBuild) { return $this-\u0026gt;instances[$abstract]; } $this-\u0026gt;with[] = $parameters; if (is_null($concrete)) { $concrete = $this-\u0026gt;getConcrete($abstract); } $object = $this-\u0026gt;isBuildable($concrete, $abstract) ? $this-\u0026gt;build($concrete) : $this-\u0026gt;make($concrete); foreach ($this-\u0026gt;getExtenders($abstract) as $extender) { $object = $extender($object, $this); } if ($this-\u0026gt;isShared($abstract) \u0026amp;\u0026amp; ! $needsContextualBuild) { $this-\u0026gt;instances[$abstract] = $object; } if ($raiseEvents) { $this-\u0026gt;fireResolvingCallbacks($abstract, $object); } $this-\u0026gt;resolved[$abstract] = true; array_pop($this-\u0026gt;with); return $object; } 重点看\\Illuminate\\Container\\Container::resolve，它实现了对象实例参数的依赖注入。\n关键的几个概念\n服务容器 Service Container 依赖注入 Dependency injection 服务提供者 / 服务供应商 Service Providers 门面（国内常称） Facades ","date":"2024-08-07T18:36:58+08:00","permalink":"/p/language/php/laravel/index-work-principle/","title":"Laravel入口文件工作原理"},{"content":"阅读说明 软件版本 PHP v8.2.8 Composer v2.7.7 问题过程 背景 最近在给Laravel v11.1.4安装依赖的时候遇到如下报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 Downloading https://mirrors.aliyun.com/composer/p2/fruitcake/php-cors~dev.json if modified [304] https://mirrors.aliyun.com/composer/p2/fruitcake/php-cors~dev.json Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors.json from cache Reading /Users/jayce/Library/Caches/composer/repo/https---mirrors.aliyun.com-composer/provider-fruitcake~php-cors~dev.json from cache Your requirements could not be resolved to an installable set of packages. Problem 1 - laravel/framework[v11.9.0, v11.9.1, v11.9.2] require fruitcake/php-cors ^1.3 -\u0026gt; found fruitcake/php-cors[dev-feat-setOptions, dev-master, dev-main, dev-test-8.2, v0.1.0, v0.1.1, v0.1.2, v1.0-alpha1, v1.0-alpha2, v1.0-beta1, v1.0.0, v1.0.1, v1.1.0, 1.1.x-dev (alias of dev-main), v1.2.0, 1.2.x-dev (alias of dev-master)] but it does not match the constraint. - Root composer.json requires laravel/framework ^11.9 -\u0026gt; satisfiable by laravel/framework[v11.9.0, v11.9.1, v11.9.2]. 说是fruitcake/php-cors的包找不到v1.3.0的版本，laravel/framework依赖了这个包，对应依赖如下：\n1 2 3 \u0026#34;require\u0026#34;: { \u0026#34;fruitcake/php-cors\u0026#34;: \u0026#34;^1.3\u0026#34; } 通过命令进行检查：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 composer show --latest -a fruitcake/php-cors # 以下为输出结果 name : fruitcake/php-cors descrip. : Cross-origin resource sharing library for the Symfony HttpFoundation keywords : symfony, cors, laravel versions : dev-master, 1.2.x-dev, v1.2.0, 1.1.x-dev, v1.1.0, v1.0.1, v1.0.0, v1.0-beta1, v1.0-alpha2, v1.0-alpha1, v0.1.2, v0.1.1, v0.1.0, dev-main, dev-test-8.2, dev-feat-setOptions latest : v1.2.0 released 2022-02-20, 2 years ago type : library license : MIT License (MIT) (OSI approved) https://spdx.org/licenses/MIT.html#licenseText homepage : https://github.com/fruitcake/php-cors source : [git] https://github.com/fruitcake/php-cors.git c70ea7b05b9a1b13d3196f235d5995b3deb93ae8 dist : [zip] https://api.github.com/repos/fruitcake/php-cors/zipball/c70ea7b05b9a1b13d3196f235d5995b3deb93ae8 c70ea7b05b9a1b13d3196f235d5995b3deb93ae8 names : fruitcake/php-cors support issues : https://github.com/fruitcake/php-cors/issues source : https://github.com/fruitcake/php-cors/tree/master autoload psr-4 Fruitcake\\Cors\\ =\u0026gt; src/ requires php ^7.4|^8.0 symfony/http-foundation ^4.4|^5.4|^6|^7 requires (dev) phpunit/phpunit ^9 squizlabs/php_codesniffer ^3.5 phpstan/phpstan ^1.4 检查阿里云镜像fruitcake/php-cors包的json，同样也是包的最新版本是v1.2.0（2022-02-20），该包在23年10月12日就发布了v1.3.0的版本，看来是阿里云已经很长时间没更新这个包了。\n解决方法一 最简单直接的方式是换源，点我更换镜像源。\n这里以腾讯云为例：\n1 composer config -g repos.packagist composer https://mirrors.tencent.com/composer/ 对应~/.composer/config.json配置被修改如下：\n1 2 3 4 5 6 7 8 { \u0026#34;repositories\u0026#34;: { \u0026#34;packagist\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://mirrors.tencent.com/composer/\u0026#34; } } } 该方式的缺点是，万一腾讯云也没更新该包的最新版本的话，问题依旧。\n解决方法二 阿里云镜像源文档提到了canonical参数，配置如下：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;repositories\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;阿里云镜像\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://mirrors.aliyun.com/composer/\u0026#34;, \u0026#34;canonical\u0026#34;: false } ] } 解释是阿里云镜像站下载文件出错（例如404或者超时的情况等）或者包不是最新时，再从官方源上下载，这样确实能够解决阿里云包不是最新的问题。\n但这个参数是怎么起作用的？怎么工作的呢？来细细研究一下。\ncomposer在解决包依赖的时候，会从repositories数组中上到下从镜像源中寻找包。\n这里还有一个默认行为，packagist.org官方源会被隐式的添加到repositories的最后一个，如果要禁用该行为，设置如下：\n1 2 3 4 5 6 7 { \u0026#34;repositories\u0026#34;: [ { \u0026#34;packagist.org\u0026#34;: false } ] } 回到正题，canonical参数的官方解释，我大概复述一下，我们所说的镜像，其实在官方是指存储库，即repositories属性中的配置，存储库又分为规范存储库（Canonical repositories）和非规范存储库（repositories non-canonical）。\n在composer v2.x的版本中，默认所有存储库都是规范的（即\u0026quot;canonical\u0026quot;: true）。\n而composer v1.x所有存储库都视为非规范存储库（即\u0026quot;canonical\u0026quot;: false）。\n规范存储库有两个好处：\n性能好，一旦在某个存储库中找到包以后，就会停止去扫描别的存储库去寻找包。 更安全，假设你设置了一个非规范的私有存储库，当你的项目中依赖一个私有包foo/bar ^2.0（假设版本是v2.4.3），之后当有人在packagist.org发布了一个foo/bar v2.999的话，那么composer会读取到该包，因为v2.999的包更新，并且符合^2.0的约束，那么你的项目可能会安装到预期以外的东西。规范存储库就不会有这个问题，因为在规范存储库中找到包以后就不会再去扫描别的存储库了。 解决方法三 正如上面所提到的，设置成非规范存储库是有风险的，并且安装过程会更慢。\n解决办法也不是没有，可以多个镜像源混合使用，修改~/.composer/config.json如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://mirrors.aliyun.com/composer/\u0026#34;, \u0026#34;exclude\u0026#34;: [\u0026#34;fruitcake/php-cors\u0026#34;] }, { \u0026#34;type\u0026#34;: \u0026#34;composer\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://mirrors.tencent.com/composer/\u0026#34; } ] } exclude的作用是排除寻找某个包，这样它就会从下一个规范仓库的镜像源中去寻找包。\n缺点： 配置麻烦，如果出现正源有很多包都没更新的情况下，配置是个噩梦，这种情况下还是建议换源。 备用镜像源也没有最新包的情况下，问题依旧，还需再另外配置备用镜像源。 好处：性能更好，更安全。 解决方法四 自己搭建源，暂不开展\n缺点：增加维护包的成本、搭建服务成本。\n解决方法五 修改项目的composer.json，设置查找包的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;package\u0026#34;, \u0026#34;package\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;wppd/aliyun-log-php-sdk\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.4\u0026#34;, \u0026#34;dist\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/aliyun/aliyun-log-php-sdk/archive/refs/tags/v1.0.zip\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;zip\u0026#34; } } }\t] } 或者将包下载到本地，直接引用本地路径：\n1 2 3 4 5 6 { \u0026#34;repositories\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/your_local_path/fruitcake/php-cors\u0026#34; }] } 缺点：需要额外配置项目的composer.json以及维护包的版本。\n镜像源 列一下常用的几个镜像源，请自行设置：\n阿里云：https://mirrors.aliyun.com/composer/ 华为云：https://mirrors.huaweicloud.com/repository/php/ 腾讯云：https://mirrors.tencent.com/composer/ 上海交通大学：https://packagist.mirrors.sjtug.sjtu.edu.cn 中国全量镜像：https://packagist.phpcomposer.com 官方源：https://repo.packagist.org 官方全球镜像：https://packagist.pages.dev 参考 Packagist mirrors 国内composer镜像有哪些_composer国内镜像-CSDN博客 Composer 国内全量镜像大全 | PHP 技术论坛 ","date":"2024-08-07T10:54:39+08:00","permalink":"/p/language/php/composer/repositories-not-found-version/","title":"composer国内源找不到包版本的解决方法"},{"content":"阅读说明 软件版本 vite v5.3.1 vue v3.4.29 rollup-plugin-external-globals v0.11.0 vite-plugin-external v4.3.1 背景 最近在将基于vite、vue的前端项目中的依赖包改成CDN外部形式。\n打包完以后访问页面，遇到了如题的报错，完整报错如下：\n1 Uncaught TypeError: Failed to resolve module specifier \u0026#34;vue\u0026#34;. Relative references must start with either \u0026#34;/\u0026#34;, \u0026#34;./\u0026#34;, or \u0026#34;../\u0026#34;. 该报错会在不同的使用场景下会出现，我的场景是打包成CDN外部依赖的时候遇到的。\n问题过程 处理成外部CDN我用到的是fengxinming/vite-plugins vite-plugin-external插件包的形式，根据文档介绍，采用了常规使用的写法。\nvite.config.ts关键配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import createExternal from \u0026#39;vite-plugin-external\u0026#39; /** @type {import(\u0026#39;vite\u0026#39;).UserConfig} */ export default defineConfig({ root: \u0026#39;app\u0026#39;, plugins: [ vue(), createExternal({ externals: { vue: \u0026#39;Vue\u0026#39;, \u0026#39;vue-router\u0026#39;: \u0026#39;VueRouter\u0026#39; //... } }) ] }) 打包前的index.html如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vite App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3.4.35/dist/vue.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue-router@4.4.2/dist/vue-router.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;./src/main.ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打包以后的index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;./favicon.ico\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vite App\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; crossorigin src=\u0026#34;./assets/index-Bc_167s1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; crossorigin href=\u0026#34;./assets/index-B9wcSffo.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3.4.35/dist/vue.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue-router@4.4.2/dist/vue-router.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 访问该页面以后，遇到了如标题的报错内容。\n然后查看打包以后的index.js（index-Bc_167s1.js），只放关键内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 const __vite__mapDeps = ( i, m = __vite__mapDeps, d = m.f || (m.f = [ \u0026#39;./page1-Da4j-Y0r.js\u0026#39;, \u0026#39;./page2-XQJYOUa2.js\u0026#39;, \u0026#39;./page3-DXfHDBAk.js\u0026#39; ]) ) =\u0026gt; i.map((i) =\u0026gt; d[i]) import { defineComponent as P, openBlock as w, createElementBlock as O, Fragment as R, createElementVNode as p, createVNode as m, unref as d, withCtx as h, createTextVNode as _, createApp as A } from \u0026#39;vue\u0026#39; import { RouterLink as g, RouterView as V, createRouter as S, createWebHistory as k } from \u0026#39;vue-router\u0026#39; // ... const B = { class: \u0026#39;wrapper\u0026#39; }, C = P({ __name: \u0026#39;App\u0026#39;, setup(c) { return (o, n) =\u0026gt; ( w(), O( R, null, [ p(\u0026#39;header\u0026#39;, null, [ p(\u0026#39;div\u0026#39;, B, [ p(\u0026#39;nav\u0026#39;, null, [ m(d(g), { to: \u0026#39;/path/page1\u0026#39; }, { default: h(() =\u0026gt; [_(\u0026#39;page1\u0026#39;)]), _: 1 }), m(d(g), { to: \u0026#39;/path/page2\u0026#39; }, { default: h(() =\u0026gt; [_(\u0026#39;page2\u0026#39;)]), _: 1 }), m(d(g), { to: \u0026#39;/path/page3\u0026#39; }, { default: h(() =\u0026gt; [_(\u0026#39;page3\u0026#39;)]), _: 1 }) ]) ]) ]), m(d(V)) ], 64 ) ) } }), // ... 可以看到这里有引入vue和vue-router，当注释imoprt {xxx} from vue以后，可以看到报错内容变成了：\n1 Uncaught TypeError: Failed to resolve module specifier \u0026#34;vue-router\u0026#34;. Relative references must start with either \u0026#34;/\u0026#34;, \u0026#34;./\u0026#34;, or \u0026#34;../\u0026#34;. 说明就是这里import的问题，直接注释只是屏蔽了该报错，并不能解决问题，因为在index.js下面有使用到import进来的相关模块。\n那怎么解决呢？\n一番捣鼓以后，解决方式有两种。\n解决方法一 关键属性是interop:'auto'，先放上解决方法：\n修改你的vite.config.ts文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import createExternal from \u0026#39;vite-plugin-external\u0026#39; /** @type {import(\u0026#39;vite\u0026#39;).UserConfig} */ export default defineConfig({ root: \u0026#39;app\u0026#39;, plugins: [ vue(), createExternal({ interop:\u0026#39;auto\u0026#39;, // 加入这行 externals: { vue: \u0026#39;Vue\u0026#39;, \u0026#39;vue-router\u0026#39;: \u0026#39;VueRouter\u0026#39; //... } }) ] }) 重新打包即可。\nfengxinming/vite-plugins vite-plugin-external的文档其实是有介绍的，称之为使用兼容的方式读取外部依赖，并说明了参数加与不加的区别，但对于我个人来说并不是很醒目和清晰，并且文档对于interop的作用也没有过多的介绍，虽然在折腾的情况下解决了问题，但只知道它能解决问题，并不知其作用。\n知其然而不知其所以然对我这种强迫症来说是不能忍受的。\n但毕竟前端水平有限，仅浅浅捣鼓一下，底层原理先不深究，日后再说，这里当抛砖引玉，留给读者琢磨了。\n首先查看vite-plugin-external配置项的interop参数定义：\n1 2 3 4 export interface Options extends BasicOptions { interop?: \u0026#39;auto\u0026#39;; enforce?: \u0026#39;pre\u0026#39; | \u0026#39;post\u0026#39;; } 可以看出是一个可选参数，但默认值并不是auto，只是声明了其参数可能的值。\n通过修改./node_modules/.pnpm/vite-plugin-external@4.3.1/node_modules/vite-plugin-external/dist/index.mjs文件关键位置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function createPlugin(opts) { let libNames; return { name: \u0026#34;vite-plugin-external\u0026#34;, enforce: opts.enforce, async config(config, { mode, command }) { const { cacheDir, externals, interop } = buildOptions(opts, mode); // 加入以下行 console.log([65435345, cacheDir, externals, interop]) libNames = !externals ? [] : Object.keys(externals); let externalLibs = libNames; let globals = externals; if (command === \u0026#34;serve\u0026#34; || interop === \u0026#34;auto\u0026#34;) { await addAliases(config, cacheDir, globals, libNames); externalLibs = []; globals = void 0; } // ... } } } 的方式进行确认，interop的默认值是undefined。\n1 2 3 4 5 6 7 8 9 [ 65435345, \u0026#39;/xxx/xxx/project-name/node_modules/.vite_external\u0026#39;, { vue: \u0026#39;Vue\u0026#39;, \u0026#39;vue-router\u0026#39;: \u0026#39;VueRouter\u0026#39; }, undefined ] 当设置interop的值为auto，重新打包，观察一下index.js文件前后的变化，关键内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 const __vite__mapDeps = ( i, m = __vite__mapDeps, d = m.f || (m.f = [ \u0026#39;./page1-Da4j-Y0r.js\u0026#39;, \u0026#39;./page2-XQJYOUa2.js\u0026#39;, \u0026#39;./page3-DXfHDBAk.js\u0026#39; ]) ) =\u0026gt; i.map((i) =\u0026gt; d[i]) // ... var e = Vue var l = VueRouter const V = { class: \u0026#39;wrapper\u0026#39; }, L = e.defineComponent({ __name: \u0026#39;App\u0026#39;, setup(n) { return (i, s) =\u0026gt; ( e.openBlock(), e.createElementBlock( e.Fragment, null, [ e.createElementVNode(\u0026#39;header\u0026#39;, null, [ e.createElementVNode(\u0026#39;div\u0026#39;, V, [ e.createElementVNode(\u0026#39;nav\u0026#39;, null, [ e.createVNode( e.unref(l.RouterLink), { to: \u0026#39;/path/page1\u0026#39; }, { default: e.withCtx(() =\u0026gt; [e.createTextVNode(\u0026#39;page1\u0026#39;)]), _: 1 } ), e.createVNode( e.unref(l.RouterLink), { to: \u0026#39;/path/page2\u0026#39; }, { default: e.withCtx(() =\u0026gt; [e.createTextVNode(\u0026#39;page2\u0026#39;)]), _: 1 } ), e.createVNode( e.unref(l.RouterLink), { to: \u0026#39;/path/page3\u0026#39; }, { default: e.withCtx(() =\u0026gt; [e.createTextVNode(\u0026#39;page3\u0026#39;)]), _: 1 } ) ]) ]) ]), e.createVNode(e.unref(l.RouterView)) ], 64 ) ) } }) // ... 可以清晰观察到，未设置interop的情况下，vue依赖需要通过import {xxx} vue的方式进行引入，而当设置interop:'auto'的情况下，vue依赖变成了var e=Vue全局的方式进行引入，问题得到解决。\n解决方法二 需要用到rollup-plugin-external-globals包，修改rollup配置的方式。\nvite.config.ts关键内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import externalGlobals from \u0026#39;rollup-plugin-external-globals\u0026#39; /** @type {import(\u0026#39;vite\u0026#39;).UserConfig} */ export default defineConfig({ build: { rollupOptions: { external: [ \u0026#39;vue\u0026#39;, \u0026#39;vue-router\u0026#39; ], plugins: [ externalGlobals({ vue: \u0026#39;Vue\u0026#39;, \u0026#39;vue-router\u0026#39;: \u0026#39;VueRouter\u0026#39; }) ] } } }) 重新打包即可。\n该方式暂时不深入，以记录为主。\n参考 vite3 + vue3 + pinia 配置 CDN 后打包部署后出现 Failed to resolve module specifier “vue“ 报错处理-CSDN博客 vue动态路由异步加载import组件，加载不到module的问题_sync recursive-CSDN博客 vue.js - Error resolving module specifier “vue”. Relative module specifiers must start with “./”, “../” or “/” - Stack Overflow vite2如何使用cdn加载vue等包 前端新工具\u0026ndash;vite从入门到实战（一） HTML文档引入JS模块出现路径问题 ","date":"2024-08-06T14:28:05+08:00","permalink":"/p/language/javascript/package/vite/vite-cdn-external-build-fail/","title":"Failed to resolve module specifier 'vue' Relative references xxx 报错处理过程"},{"content":"背景 最近在发布j-weapons前端包的时候遇到了一个问题，引入CDN编译以后的JS文件，在浏览器中查看该脚本文件实际并没有执行。\n问题过程 代码文件如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;testing\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios@1.7.2/dist/browser/axios.cjs\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;console.log(axios)\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里以axios为例，情况是如出一辙的。\n控制台得到一个错误：\n1 2 Uncaught ReferenceError: axios is not defined at dist/:14:21 script src文件并没有被执行。\n赶紧看Network对应资源文件的请求，如下图：\n可以看到这里的Status显示了(failed) net::ERR_BLOCKED_BY_ORB（而General.Status Code是200正常的）一番搜寻没找到有用的信息，AI介绍是浏览器应用层处理网络请求时的错误，既不属于HTTP也不是TCP的错误，暂不展开讨论这块。\n接着看响应头，如图：\n重点在Content-Type，返回的竟然是text/plain？\n接着换另一个CDN：jsdelivr再试试：\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios@1.7.2/dist/browser/axios.cjs\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 同样，脚本也并没有被执行，查看响应头，如图：\nStatus Code也是200，并没有出现(failed) net::ERR_BLOCKED_BY_ORB，而响应类型变成了：Content-Type: application/node。\n我在本地用Nginx引入本地文件，试了一下，响应类型是Content-Type: application/javascript，能够正常执行脚本。\n证明文件本身没有问题，问题在于响应头的响应类型。\n另外在Console有一个错误：\n1 Refused to execute script from \u0026#39;https://cdn.jsdelivr.net/npm/axios@1.7.2/dist/browser/axios.cjs\u0026#39; because its MIME type (\u0026#39;application/node\u0026#39;) is not executable, and strict MIME type checking is enabled. 这个错误就比较有意思。\nMIME 它说CDN文件的MIME type，也就是指响应头里的Content-Type，是application/node类型，不可以执行，并且启用了严格检查MIME type类型的模式，应该就是指响应头返回的X-Content-Type-Options: nosniff。\n稍加解释一下：\nMIME type也称为IANA媒体类型，是一种标准，用来表示文档、文件或一组数据的性质和格式，它在IETF的RFC 6838中进行了定义和标准化。它一般包含两个部分：类型和子类型，中间用/分割，不能有空格，例如：text/plain、text/javascript等。 而Content-Type则表示标头用于指定资源的原始媒体类型，就是指上面说的MIME类型，它是由服务端返回的。 它们都属于HTTP的知识。\nMIME嗅探 假设我们有一个HTML标签：\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios@1.7.2/dist/browser/axios.cjs\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 当然你可能会看到有使用type=\u0026quot;application/javascript\u0026quot;的，不过该MIME类型已被弃用。\n一般情况下，我们是不需要加type=\u0026quot;text/javascript\u0026quot;的attributes，浏览器会默认将它视为text/javascript。\n浏览器在获取标签上的文件时，如果该文件的响应头没有Content-Type或者是Content-type: application/octet-stream的时候，就会通过读取文件的前几个字节（通常是512字节）分析文件内容的特征从而猜测MIME的类型，这个过程称为MIME嗅探。\nMIME嗅探会带来安全问题，虽然我们给script src标签指定了type=\u0026quot;text/javascript\u0026quot;，但是浏览器一般会根据服务端返回的MIME类型来处理资源，用户可能会因此在不知情的情况下，遭受到XSS攻击。\n防御的措施一般有：\n服务端始终响应正确的Content-Type，避免浏览器MIME嗅探的触发。 服务端携带X-Content-Type-Options: nosniff响应头，明确告知浏览器不要进行MIME嗅探。 总结 回归正题，也就是说报错是因为CDN返回的Content-Type的MIME类型不是text/application或者不是application/javascript才导致script src标签不执行的，猜测CDN是根据不同的文件后缀给出不同的Content-Type：\nunpkg： .cjs的文件，Content-Type是text/plain，通过brose axios files文件右侧可以进一步确认。 .map，Content-Type是application/json。 jsdelivr： .cjs，Content-Type是application/node。 这也解释了为什么我在本地用nginx打开页面是能够正常执行脚本的原因。\n那为什么我打包以后的文件会是index.umd.cjs的后缀的？\n简单提一下，我用的是Vite打包工具，配置项如下：\n1 2 3 4 5 6 7 8 9 ... build: { lib: { entry: \u0026#39;src/index.ts\u0026#39;, formats: [\u0026#39;umd\u0026#39;], fileName: \u0026#39;index\u0026#39; }, } ... 正是fileName和formats含umd的情况下，它会默认将entry入口文件处理成index.umd.cjs的后缀，解决这个问题只需要将fileName改成函数自定义返回即可，详情请自行查看文档。\n参考 MIME 类型（IANA 媒体类型） - HTTP | MDN Content-Type - HTTP | MDN RFC 6838 - Media Type Specifications and Registration Procedures MIME 类型 - MDN Web 文档术语表：Web 相关术语的定义 | MDN ","date":"2024-08-01T15:04:07+08:00","permalink":"/p/language/javascript/leadin-cdn-script-not-executable/","title":"引入CDN的JS文件为什么不可执行？"},{"content":"阅读说明 软件版本 React v18.3.1 React Dom v18.3.1 Vite v5.3.1 vitejs/plugin-react v4.3.1 TypeScript v5.2.2 @types/react v18.3.3 @types/react-dom v18.3.0 介绍 React是一个开源的前端JavaScript库，用于构建用户界面。用户界面由按钮、文本和图像等小单元内容构建而成。React帮助你把它们组合成可重用、可嵌套的组件。从we端网站到移动端应用，屏幕上的所有内容都可以被分解成组件。\n它由Facebook维护，并在2013年首次发布。React的核心特性是其组件化架构，允许开发者使用名为“React组件”的可重用代码片段构建复杂的用户界面。\n体验React 直接将以下代码保存在本地，打开页面查看效果。\n例子一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Hello World\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react@18/umd/react.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react-dom@18/umd/react-dom.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Don\u0026#39;t use this in production: --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/@babel/standalone/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; function MyApp() { return \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;; } const container = document.getElementById(\u0026#39;root\u0026#39;); const root = ReactDOM.createRoot(container); root.render(\u0026lt;MyApp /\u0026gt;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在线预览。\n例子二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- This setup is not suitable for production. --\u0026gt; \u0026lt;!-- Only use it in development! --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/@babel/standalone/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script async src=\u0026#34;https://ga.jspm.io/npm:es-module-shims@1.7.0/dist/es-module-shims.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; { \u0026#34;imports\u0026#34;: { \u0026#34;react\u0026#34;: \u0026#34;https://esm.sh/react?dev\u0026#34;, \u0026#34;react-dom/client\u0026#34;: \u0026#34;https://esm.sh/react-dom/client?dev\u0026#34; } } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34; data-type=\u0026#34;module\u0026#34;\u0026gt; import React, { StrictMode } from \u0026#39;react\u0026#39;; import { createRoot } from \u0026#39;react-dom/client\u0026#39;; function Greeting({ name }) { return \u0026lt;h1\u0026gt;Hello, {name}\u0026lt;/h1\u0026gt;; } let App = function App() { return \u0026lt;Greeting name=\u0026#34;world\u0026#34; /\u0026gt; } const root = createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/StrictMode\u0026gt; ); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在线预览。\n以上代码仅适合快速了解React的使用。为什么？你可以看到用到了\u0026lt;script type=\u0026quot;text/babel\u0026quot;\u0026gt;，它是一种在早期React和其他使用ES6模块语法的项目中使用的脚本标记方式。\nBabel是一个广泛使用的JavaScript编译器，它可以将ES6+语法转换为向后兼容的JavaScript语法（通常是 ES5），也可以将JSX解析成JavaScript，这样代码就可以在更多的环境中运行，包括旧版浏览器。 text/babel是一个自定义的MIME类型，它不是一个官方标准，而是一种约定俗成的用法，使用之前确保页面引入了Babel的polyfill和相关设置。 在页面加载时，Babel会自动检测type=\u0026quot;text/babel\u0026quot;的脚本，并将其内容转译成ES5代码，然后运行。\n这种写法并不是一个长期推荐的解决方案，因为它依赖于全局的Babel配置，可能会与其他构建工具或模块打包器冲突。\n现代前端开发通常使用构建工具（如Webpack、Rollup、Vite等）来处理代码转译和打包，这些工具提供了更高效、更灵活、更强大的配置选项和处理方式。\ndata-type=\u0026quot;module\u0026quot;是告诉Babel polyfill该脚本应该被视为模块来处理。\n使用构建工具运行React 这里使用Vite。\n1 npm create vite@latest 按照提示处理就行，我这里选的是：\nSelect a framework: React Select a variant: TypeScript 接着：\n1 2 3 cd your_react_project npm install npm run dev 将得到以下目录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ├── README.md ├── index.html ├── package.json ├── public │ └── vite.svg ├── src │ ├── App.css │ ├── App.tsx │ ├── assets │ │ └── react.svg │ ├── index.css │ ├── main.tsx │ └── vite-env.d.ts ├── tsconfig.app.json ├── tsconfig.json ├── tsconfig.node.json └── vite.config.ts 组件 组件是React的核心概念之一，它们是构建用户界面（UI）的基础。一个组件是UI（用户界面）的一部分，它拥有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。\n每个React组件都是一个JavaScript函数，它会返回一些标签，React会将这些标签渲染到浏览器上。\n是的，你没理解错，React组件会将HTML标签和逻辑耦合在一起。\n为什么？官方说法是web交互性越来越强，逻辑越来越决定页面中的内容，JavaScript控制着HTML的内容。\n乍眼一看还是很晦涩难懂的，以下是个人的理解看法：\n例如JS里可以看到createElement、innerHTML等等，都是做着渲染HTML的事情，这种写法和过程是很冗长很混乱的，React的出现，只是将这个过程用JSX更直观地放在了组件中进行，并且它做的更简单、易懂。再加上都是JavaScript的东西，不需要再学一些特有的东西，结合友好的文档，有JS基础的人，学起来会相对舒服一些。\n就像这样：\n1 2 3 function MyApp() { return \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;; } 这就是React组件的定义方式，MyApp是组件名称，名称必须以大写字母开头，换句话说你可以由此作为依据来辨别React组件，因为HTML标签必须是小写字母开头的。\n\u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt;，这段看起来像HTML，实际上是JavaScript，这种语法被称为JSX，它允许你在JavaScript中嵌入标签。JSX看起来和HTML很像，但它的语法更加严格并且可以动态展示信息。\n但JSX并不属于React，它不是React的特性，了解更多关于JSX（强烈建议先了解完再回过头来看）。\n简单的JSX写在一行没问题，但如果JSX很多，要换行应该怎么写？就像下面这样：\n1 2 3 4 5 6 7 function MyApp() { return ( \u0026lt;h1\u0026gt; Hello, world! \u0026lt;/h1\u0026gt;; ) } 当JSX和return不在同一行的时候，必须用括号把它包裹起来，否则return之后的代码都会被忽略。\n使用组件 导出和导入 要使用组件就要先将组件导出，会用到export，它是JavaScript的标准语法，这样你就能够在其他文件中使用import进行导入。\n新建一个Buttons.tsx文件。\n导出的方式有两种：\n默认导出：export default 具名导出：export 一个模块文件中可以有多个具名导出，但只允许有一个默认导出。\n默认导出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function Button({ name }: { name: string } ) { return ( \u0026lt;button\u0026gt; {name} \u0026lt;/button\u0026gt; ) } function Buttons() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;buttons\u0026lt;/h1\u0026gt; \u0026lt;Button name=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ) } export default Buttons 在另一个文件App.tsx中导入：\n1 2 3 4 5 6 7 8 import Buttons from \u0026#39;./Button.tsx\u0026#39; function App() { return ( \u0026lt;Buttons /\u0026gt; ) } 具名导出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 export function Button({ name }: { name: string } ) { return ( \u0026lt;button\u0026gt; {name} \u0026lt;/button\u0026gt; ) } export default function Buttons() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;buttons\u0026lt;/h1\u0026gt; \u0026lt;Button name=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ) } 另一个文件App.tsx中导入：\n1 2 3 4 5 6 7 8 9 10 11 import Buttons, { Button } from \u0026#39;./Button.tsx\u0026#39; function App() { return ( \u0026lt;\u0026gt; \u0026lt;Buttons /\u0026gt; \u0026lt;Button name=\u0026#34;click me\u0026#34; /\u0026gt; \u0026lt;/\u0026gt; ) } 通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。\n无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。不建议创建未命名的组件，比如 export default () =\u0026gt; {}，因为这样会使得调试变得异常困难。\n子组件 通过上面的例子可以看到，Button是一个子组件，同时也是一个函数，它返回了JSX，并嵌套进了Buttons父组件中，然后再被嵌套进App组件中。\n这个过程可以实现俄罗斯套娃式嵌套JSX，再联合{}大括号可以将组件玩出花来。\nProps React组件使用props来互相通信。每个父组件都可以提供props给它的子组件，从而将一些信息传递给它。Props可能会让你想起 HTML 属性，但你可以通过它们传递任何JavaScript值，包括对象、数组和函数。\n以\u0026lt;img\u0026gt;HTML标签举例，它的属性（在HTML标准里称为attributes）有：\nalt src width height srcset loading crossorigin 而在上面的例子中：\n1 \u0026lt;Button name=\u0026#34;submit\u0026#34; /\u0026gt; name就是组件的Props，类似于\u0026lt;img\u0026gt;标签的属性Attributes。\n获取Props 1 2 3 4 5 6 7 8 9 10 11 12 interface ButtonProps { name?: string } export function Button(props: ButtonProps) { const name = props.name return ( \u0026lt;button\u0026gt; {name} \u0026lt;/button\u0026gt; ) } 可以看到props这个形参，这样就能够接收所有赋值给Button组件的props。\n当然，你也可以这么写：\n1 2 3 4 5 6 7 8 function Button({ name }: { name: string } ) { return ( \u0026lt;button\u0026gt; {name} \u0026lt;/button\u0026gt; ) } function Button({ name })，这种形参的写法叫做解构赋值，是JavaScript的表达式。\n渲染列表 1 2 3 4 5 6 7 8 9 10 11 12 export default function Ul() { const names: string[] = [\u0026#39;jayce\u0026#39;, \u0026#39;jack\u0026#39;, \u0026#39;jay\u0026#39;]; return ( \u0026lt;ul\u0026gt; { names.map((name) =\u0026gt; ( \u0026lt;li key={name}\u0026gt;{name}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; ) } 也可以这么写：\n1 2 3 4 5 6 7 export default function Ul() { const names: string[] = [\u0026#39;jayce\u0026#39;, \u0026#39;jack\u0026#39;, \u0026#39;jay\u0026#39;]; const items = names.map(name =\u0026gt; \u0026lt;li key={name}\u0026gt;{name}\u0026lt;/li\u0026gt;); return ( \u0026lt;ul\u0026gt;{items}\u0026lt;/ul\u0026gt; ) } const items = names.map(name =\u0026gt; \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt;);这种写法叫做箭头函数表达式。\n箭头函数=\u0026gt;之后的表达式会被隐式地返回，因此可以省略return语句。 箭头函数=\u0026gt; {后面的部分被称为块函数体（Block body），它支持多行代码的写法，但必须用显式的return语句返回。 其中\u0026lt;li key={name}\u0026gt;的key属性是必须的，它的值起到唯一标识作用，实际使用不应该是name，而应是id。\n因为这些key会告诉React，每个组件对应着数组里的哪一项，所以React可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的key可以帮助React 推断发生了什么，从而得以正确地更新DOM树。\nJSX JSX和React是两个相互独立的东西，JSX是JavaScript语法扩展，是一种语法扩展，而React是一个JavaScript库。\nJSX看起来就是HTML标签，到底和HTML有什么不同？\n规则约束 标签必须闭合 \u0026lt;img\u0026gt;这种自闭和的标签，必须书写成\u0026lt;img /\u0026gt;。 \u0026lt;li\u0026gt;这种有开始标签，就必须得有结束标签。\u0026lt;li\u0026gt;\u0026lt;/li\u0026gt;。 使用驼峰命名法给属性命名 JSX最终会被转化为JavaScript，而JSX中的属性也会变成JavaScript对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。\n但JavaScript对变量的命名有限制。例如，变量名称不能包含-符号或者像class这样的保留字。\n这就是为什么在React中，大部分HTML和SVG属性都用驼峰式命名法表示。\n例如，需要用strokeWidth代替stroke-width。由于class是一个保留字，所以在React中需要用className来代替。这也是 DOM 属性中的命名。\nJSX写法：\n1 2 3 4 5 \u0026lt;img src=\u0026#34;https://i.imgur.com/yXOvdOSs.jpg\u0026#34; alt=\u0026#34;Hedy Lamarr\u0026#34; className=\u0026#34;photo\u0026#34; /\u0026gt; HTML写法：\n1 \u0026lt;img src=\u0026#34;https://i.imgur.com/yXOvdOSs.jpg\u0026#34; alt=\u0026#34;Hedy Lamarr\u0026#34; class=\u0026#34;photo\u0026#34;\u0026gt; 如果在编写JSX时有错误，React也会在编译时告诉你。\n如果你需要用到aria-和data-这样的属性时，使用驼峰命名法并不适用，这是HTML历史原因。\nJSX：\n1 2 3 \u0026lt;button dataType=\u0026#34;ac\u0026#34;\u0026gt; submit \u0026lt;/button\u0026gt; 编译以后的HTML：\n1 \u0026lt;button datatype=\u0026#34;ac\u0026#34;\u0026gt;submit\u0026lt;/button\u0026gt; 应该这么写，JSX：\n1 2 3 \u0026lt;button data-type=\u0026#34;ac\u0026#34;\u0026gt; submit \u0026lt;/button\u0026gt; 编译以后的HTML：\n1 \u0026lt;button data-type=\u0026#34;ac\u0026#34;\u0026gt;submit\u0026lt;/button\u0026gt; 只能返回一个根元素 如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来。\n例如，你可以使用一个 \u0026lt;div\u0026gt; 标签：\n1 2 3 4 5 6 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;title\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; ... \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 如果你不想在标签中增加一个额外的 \u0026lt;div\u0026gt;，可以用 \u0026lt;\u0026gt; 和 \u0026lt;/\u0026gt; 元素来代替：\n1 2 3 4 5 6 \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;title\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; ... \u0026lt;/ul\u0026gt; \u0026lt;/\u0026gt; 这个空标签被称作Fragment。React Fragment允许你将子元素分组，而不会在 HTML 结构中添加额外节点。\n为什么多个 JSX 标签需要被一个父元素包裹？\nJSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。\n以上，不符合规则的写法都不是JSX，如果你有大量的HTML需要转换成JSX，可以用在线转换器。\n在JSX中使用JavaScript 动态指定属性的值，需要用到变量，在JSX中可以用{变量名}以此来访问JavaScript变量。\n1 2 3 4 5 6 7 8 9 10 11 export default function Avatar() { const avatar = \u0026#39;https://i.imgur.com/7vQD0fPs.jpg\u0026#39;; const description = \u0026#39;Gregorio Y. Zara\u0026#39;; return ( \u0026lt;img className=\u0026#34;avatar\u0026#34; src={avatar} alt={description} /\u0026gt; ); } 在{}（大括号）中，可以使用任何JavaScript表达式，例如函数调用、三元表达式、与运算符 \u0026amp;\u0026amp;。\n这里举例函数调用：\n1 2 3 4 5 6 7 8 9 10 11 const title = \u0026#34;hello\u0026#34;; function formatDate(text) { return text + \u0026#34; world\u0026#34;; } export default function Title() { return ( \u0026lt;h1\u0026gt;To Do List for {formatText(title)}\u0026lt;/h1\u0026gt; ); } 双大括号{{}}，你可能会在别的React应用中看到这种写法，它其实是大括号里的一个对象。\n一般会用在写内联样式的时候（实际情况当然是用class类名解决样式问题才更好）：\n1 2 3 4 5 6 7 8 9 10 11 12 export default function TodoList() { return ( \u0026lt;ul style={{ backgroundColor: \u0026#39;black\u0026#39;, color: \u0026#39;pink\u0026#39; }}\u0026gt; \u0026lt;li\u0026gt;Improve the videophone\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Prepare aeronautics lectures\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Work on the alcohol-fuelled engine\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ); } 换一个写法，更容易识别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 export default function TodoList() { return ( \u0026lt;ul style={ { backgroundColor: \u0026#39;black\u0026#39;, color: \u0026#39;pink\u0026#39; } }\u0026gt; \u0026lt;li\u0026gt;Improve the videophone\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Prepare aeronautics lectures\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Work on the alcohol-fuelled engine\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ); } 样式名称background-color遵循驼峰命名规则所以是backgroundColor。\n当然，你也可以这么写，这样更简洁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const data = { text: \u0026#39;hello world\u0026#39;, style: { backgroundColor: \u0026#39;black\u0026#39;, color: \u0026#39;pink\u0026#39; } }; export default function TodoList() { return ( \u0026lt;ul style={data.style}\u0026gt; \u0026lt;li\u0026gt;{data.text}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Prepare aeronautics lectures\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Work on the alcohol-fuelled engine\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ); } 使用限制 在JSX中，只有两种情况可以使用{}大括号：\n用作JSX标签内的文本：\u0026lt;h1\u0026gt;{name}\u0026lt;/h1\u0026gt; 是有效的，但是 \u0026lt;{tag}\u0026gt;text\u0026lt;/{tag}\u0026gt; 无效。 用作紧跟在=符号后的属性：src={avatar}会读取 avatar变量，但是src=\u0026quot;{avatar}\u0026quot;只会传一个字符串{avatar}。 结尾 官方文档写的其实已经很好很全面很通俗易懂了，为什么我还会写这下一篇文章？\n官方文档乍眼一看还是比较困难的，没有一个概览，对我来说还是散乱了一些，看下来以后发现文档确实写的很好，我做的只是将这些知识重新整理了下顺序，做的相对集中一点，这个过程本身也是一种学习、吸收的方式。\n所以你可以看到，文中讲的内容并不全面，并不打算重复文档中已经的东西，虽然是个知识的搬运工，做到切合文章的主题足以。\n参考 React React Foundations | Next.js 1-7章 Vite | Next Generation Frontend Tooling script标签常用的几个type属性 - 掘金 Export and Import HTML转JSX在线转换器 JSX - a faster, safer, easier JavaScript ","date":"2024-07-04T18:36:56+08:00","image":"https://ghjayce.github.io/asset/blog/uwgqqiUfSOHwLzCqNN13MjAyNDA3MDRfMTkwNjEy.jpeg","permalink":"/p/language/javascript/package/react/quick-start/","title":"React入门"},{"content":"阅读说明 环境\u0026amp;软件版本 MacOS Big Sur v11.0.1 Homebrew v4.0.21 GNU Make v3.81 PHP v7.3.33、v7.4.33、v8.2 ICU4C v72.1、v73.2、v74.2 背景 我的Mac环境早些时候用Homebrew安装了多个php的版本，php 7.3、7.4、8.2都有，为了区分多个php版本，我在~/.bash_profile中用alias做了处理，就像这样：\n1 2 3 alias php73=\u0026#34;/usr/local/opt/php@7.3/bin/php\u0026#34; alias php74=\u0026#34;/usr/local/opt/php@7.4/bin/php\u0026#34; alias php82=\u0026#34;/usr/local/opt/php@8.2/bin/php\u0026#34; 最近要给某个php项目composer install时需要用到php7.3，结果出现了报错：\n1 2 3 4 dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.72.dylib Referenced from: /usr/local/opt/php@7.3/bin/php Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 而8.2的版本执行正常，因为此时安装的icu4c的版本是73.2的。\n7.3、7.4需要的icu4c版本是72的，所以它们在执行php --verion时都出现了报错。\n有可能是因为安装php8，或者别的软件的时候，brew把icu4c的版本给升级上去造成的。\n升级就升级呗，不曾想旧的版本也没给我留着，好好好（brew好感度-1）。\n疑问 Q1：这是个关于什么问题的错误？ Q2：这个错误是谁抛出的？操作系统还是应用程序（php）？ Q3：这个路径是写死在应用程序（php）中的吗？有办法配置或修改吗？ 解答疑问 先来说说这是个什么样的错误：\n这是应用程序依赖某个动态链接库（Dynamic Link Libraries），而这个动态链接库的加载出现了问题，也就是说在路径下找不到这个文件了，其实不查资料光看报错的内容也能猜到一些。\n那错误内容都有哪些含义或者信息呢？\ndyld: Library not loaded：表明动态链接器未能加载一个或多个指定的动态库。 Referenced from：指出哪个文件（程序或动态库）引用了缺失的动态库。 Reason：提供无法加载动态库的原因，常见的原因包括： image not found：指定的动态库在文件系统中找不到。 image not loadable：找到了动态库，但由于某些原因（如格式错误、权限问题等）无法加载。 did not find：列出了缺失的动态库的具体路径或名称。 这个错误实际上是Mac操作系统报告的错误，表明动态链接器（dynamic linker，即 dyld）在尝试加载程序所需的一个或多个动态库时遇到了问题。\n你可能会有疑问了，动态库的后缀不都是.so后缀的吗？\n查了一下资料是这么说的：\nUNIX系统动态库文件的后缀通常是.so，尽管Mac系统是基于UNIX的，但.so文件在Mac系统上不如.dylib常见。如果你发现有.so文件，那可能是从UNIX或Linux移植过来的应用程序中携带的。\n.dylib是Mac系统中最常用的动态链接库后缀，并且从macOS 10.4（Tiger）开始，.dylib取代了旧的.so后缀，成为系统的默认格式。\n解决方案 解决也是很简单，只要让程序找到动态库文件不就行了。\n我自己用的是方案二的方法二解决的，详细可看解决过程。\n方案一 解铃还须系铃人homebrew 方法一 官方的多版本 Formula Homebrew允许安装某些软件的特定版本，如果官方提供了这些版本的Formula。可以使用以下命令：\n1 brew search icu4c 如果找到了需要的版本，执行安装即可\n1 brew install icu4c@72 这方法我试了，没有旧版本，只有icu4c的最新版\n1 2 ==\u0026gt; Formulae icu4c ✔ 手贱的我试了brew reinstall icu4c。\n结果给我安装了最新版icu4c 74.2，这下好了php82也不能用了。。\n方法二 从Formula的Git历史版本安装 如果官方提供了多个版本的Formula，但需要的版本不在列表中，可以通过查看Formula的Git提交历史来找到对应版本的Formula，并检出（checkout）到那个特定的提交。\n以下操作步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1. 进入Homebrew的Formula目录： cd $(brew --prefix)/Homebrew/Library/Taps/homebrew/homebrew-core/Formula # 2. 使用`git log`查看`icu4c.rb`的提交记录： git log --follow icu4c.rb # 3. 检出到您需要的特定版本对应的提交： git checkout -b icu4c-desired-version \u0026lt;commit-hash\u0026gt; # 4. 重新安装 ICU4C brew reinstall ./icu4c.rb # 5. 如果需要，使用`brew switch`切换到该版本： brew switch icu4c \u0026lt;desired-version\u0026gt; 这个方法我没有试完，因为操作的过程很卡，有想尝试的朋友可以试一下。\n方法三 自定义本地 Formula 如果需要的版本不在Homebrew的官方仓库中，可以创建一个自定义的Formula文件。\n相关步骤：\n创建一个自定义的Formula文件，例如 icu4c@72.rb。 编写Formula文件，指定软件的描述、URL、版本号、SHA256签名等信息。可以参考现有的Formula文件来编写。 安装自定义的Formula：brew install /path/to/icu4c@72.rb 如果需要，创建软链接以解决依赖问题。 同样，没试过。\n方案二 自己下载icu4c编译安装 unicode-org/icu下载地址\n编译安装过程：\n1 2 3 4 tar -zxvf ./icu4c-72_1-src.tgz cd icu/source ./configure --prefix=/usr/local/Cellar/icu4c/72.1 make \u0026amp;\u0026amp; make install 将动态库文件拷贝到指定目录下：\n1 2 3 4 5 cd /usr/local/Cellar/icu4c/72.1/lib cp ./libicui18n.72.dylib /usr/local/opt/icu4c/lib/libicui18n.72.dylib cp ./libicuuc.72.1.dylib /usr/local/opt/icu4c/lib/libicuuc.72.dylib cp ./libicudata.72.1.dylib /usr/local/opt/icu4c/lib/libicudata.72.dylib cp ./libicuio.72.1.dylib /usr/local/opt/icu4c/lib/libicuio.72.dylib 检查一下效果\n1 2 3 4 5 6 7 8 9 php73 --version # 执行结果： dyld: Library not loaded: libicuuc.72.dylib Referenced from: /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 方法一 DYLD_LIBRARY_PATH 还是报错，还是没找到路径对吧，最简单的处理方法是，设置DYLD_LIBRARY_PATH环境变量，动态链接器搜索动态库文件时，如果在其他位置都没找到的情况下，会在你设定变量的目录下寻找动态库。\n设置在.bash_profile、.bashrc或.zshrc都可以（以下命令可直接照抄）：\n1 2 echo \u0026#39;export DYLD_LIBRARY_PATH=\u0026#34;/usr/local/opt/icu4c/lib/\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 来检查一下效果：\n1 2 3 4 5 6 php73 --version # 执行结果： PHP 7.3.33 (cli) (built: Jun 8 2023 15:56:42) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies 动态链接器搜索的位置一般有：\n可执行文件所在的目录。 系统默认的库目录，如 /usr/lib 和 /usr/local/lib。 由环境变量 DYLD_LIBRARY_PATH 或 LD_LIBRARY_PATH 指定的目录（在 Linux 中是 LD_LIBRARY_PATH）。 方法二 install_name_tool 相对麻烦的做法，直接修改动态库文件所在的目录。\n根据错误内容，看下libicui18n.72.dylib、libicuuc.72.dylib、libicuio.72.dylib依赖的所有动态库。\n1 2 3 4 5 6 7 8 otool -L /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib # 执行结果： /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib: libicui18n.72.dylib (compatibility version 72.0.0, current version 72.1.0) libicuuc.72.dylib (compatibility version 72.0.0, current version 72.1.0) libicudata.72.dylib (compatibility version 72.0.0, current version 72.1.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 905.6.0) 将如上的依赖库libicuuc.72.dylib、libicudata.72.dylib、libicui18n.72.dylib加上一个@loader_path特殊前缀，使用install_name_tool命令进行修改（回答了Q3的问题）。\n因为其他文件操作也一样，所以这里直接贴完整的操作过程（照抄作业即可）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 cd /usr/local/opt/icu4c/lib # libicui18n.72.dylib install_name_tool -change libicuuc.72.dylib @loader_path/libicuuc.72.dylib ./libicui18n.72.dylib install_name_tool -change libicudata.72.dylib @loader_path/libicudata.72.dylib ./libicui18n.72.dylib # libicuuc.72.dylib install_name_tool -change libicudata.72.dylib @loader_path/libicudata.72.dylib ./libicuuc.72.dylib # libicuio.72.dylib install_name_tool -change libicudata.72.dylib @loader_path/libicudata.72.dylib ./libicuio.72.dylib install_name_tool -change libicuuc.72.dylib @loader_path/libicuuc.72.dylib ./libicuio.72.dylib install_name_tool -change libicui18n.72.dylib @loader_path/libicui18n.72.dylib ./libicuio.72.dylib 再来检查一下效果：\n1 2 3 4 5 6 php73 --version # 执行结果： PHP 7.3.33 (cli) (built: Jun 8 2023 15:56:42) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies 命令说明 otool是macOS系统上的一个命令行工具，它用于显示和操作对象文件（包括静态库和动态库）。并提供了多种功能，可以帮助你检查和修改 Mach-O 对象文件的头部信息、数据段、符号表等。\n-L选项用于显示Mach-O文件（如动态库.dylib或可执行文件）所依赖的所有动态库。 install_name_tool是macOS上的一个命令行工具，用于修改Mach-O可执行文件和动态链接库（dynamic libraries，即.dylib文件）中的安装名称（install names）。这些安装名称是动态库或框架的标识符，用于运行时查找和加载依赖项。\n-change 选项用于更改动态库的安装名称。 这在以下情况下非常有用： 当你想要更新一个动态库的路径，但是可执行文件或另一个动态库中的安装名称仍然指向旧路径时。 当你将一个应用程序或库移动到一个新位置，需要更新所有引用该库的路径时。 基本语法：install_name_tool -change old_name new_name file old_name：当前的安装名称，即你想要更改的旧路径或名称。 new_name：新的安装名称，即你想要设置的新路径或名称。 file：包含要更改的安装名称的 Mach-O 文件（可执行文件或动态库）。 @loader_path 是一个特殊的前缀，用于指定相对于动态链接器加载程序的路径。当你在动态库中引用其他动态库时，可以使用 @loader_path 来告诉动态链接器在加载当前动态库的相同路径下查找依赖的动态库。\n解决过程 说的容易做起来难，以下是自己在一知半解的情况下的折腾过程，最后也是解决了问题：\n本来是当时解决完事后打的草稿，后面打算改一下，看了下还挺有趣，不改了，浅浅记录一下。\n因为会用到install_name_tool对动态链接库进行修改，使用ln的方式会改到原文件，所以做个拷贝到目标目录，直接在拷贝文件上进行修改。\n1 2 3 4 5 cd /usr/local/Cellar/icu4c/72.1/lib cp ./libicui18n.72.1.dylib /usr/local/opt/icu4c/lib/libicui18n.72.dylib cp ./libicuuc.72.1.dylib /usr/local/opt/icu4c/lib/libicuuc.72.dylib cp ./libicudata.72.1.dylib /usr/local/opt/icu4c/lib/libicudata.72.dylib cp ./libicuio.72.1.dylib /usr/local/opt/icu4c/lib/libicuio.72.dylib 执行观察下\n1 2 3 4 5 6 php73 --version # 执行结果： dyld: Library not loaded: libicuuc.72.dylib Referenced from: /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 发现还是报错，balabala 先爬帖，看有没有别的解决方法。\n发现DYLD_LIBRARY_PATH可以解决问题，但我不想用这种方式。\n然后继续折腾，折腾的麻了，想放弃直接brew reinstall php@7.3重装得了，结果跑了几次都raw.githubusercontent.com连接超时，重试了几次，连上了，直到遇到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 brew reinstall php@7.3 # 执行结果： ... ==\u0026gt; Installing dependencies for httpd: openssl@3, brotli, libnghttp2 and pcre2 ==\u0026gt; Installing httpd dependency: openssl@3 Warning: A newer Command Line Tools release is available. Update them from Software Update in System Preferences. If that doesn\u0026#39;t show you any updates, run: sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install Alternatively, manually download them from: https://developer.apple.com/download/all/. You should download the Command Line Tools for Xcode 13.2.1. ==\u0026gt; perl ./Configure --prefix=/usr/local/Cellar/openssl@3/3.1.1 --openssldir=/usr/local/etc/openssl@3 --libdir=/usr/local/Cellar/openss ==\u0026gt; make ==\u0026gt; make install MANDIR=/usr/local/Cellar/openssl@3/3.1.1/share/man MANSUFFIX=ssl ==\u0026gt; make test Error: Empty installation 再重试几次，好家伙，还是一样，直接劝退了。\n回头继续折腾修改动态库路径的这个方向。\n冷静思考下，网上的文章都说cp完那些动态库就可以了，怎么到了我的环境就不行？\n好像也不是不行，是行的，我逐个cp动态库以后再执行php73 --version能够看到错误内容有发生变化，那不就说明这个操作是有效的吗？那只要仔细看最后一个错误内容，说不定就能发现点什么\n对比了一下两次的结果：\n1 2 3 4 5 6 7 8 9 php73 --version # 执行结果： dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicuio.72.dylib Referenced from: /usr/local/opt/php@7.3/bin/php Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 四个文件都cp完再以后再执行的错误内容：\n1 2 3 4 5 6 7 8 9 php73 --version # 执行结果： dyld: Library not loaded: libicuuc.72.dylib Referenced from: /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 乍眼一看又是libicui18n，好像又回到了第一个错误一样，仔细观察可以发现两次的Referenced from不同，Library not loaded的内容也不同。\n但是有什么关联呢？一时想不明白，先去卫生间小解一下（日常想到头破憋尿鳖的不行才去）。\n回来的路上灵光一现，既然可以otool -L /usr/local/opt/php@7.3/bin/php，同理，同样也可以otool -L /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib\n赶紧快步走回去试一下：\n1 2 3 4 5 6 7 8 9 cd /usr/local/opt/icu4c/lib otool -L ./libicui18n.72.dylib # 执行结果： ./libicui18n.72.dylib: libicui18n.72.dylib (compatibility version 72.0.0, current version 72.1.0) libicuuc.72.dylib (compatibility version 72.0.0, current version 72.1.0) libicudata.72.dylib (compatibility version 72.0.0, current version 72.1.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 905.6.0) 对比icui18n.74.dylib，观察有什么不同\n1 2 3 4 5 6 7 8 otool -L /usr/local/Cellar/icu4c/74.2/lib/libicui18n.74.2.dylib # 执行结果： /usr/local/Cellar/icu4c/74.2/lib/libicui18n.74.2.dylib: /usr/local/opt/icu4c/lib/libicui18n.74.dylib (compatibility version 74.0.0, current version 74.2.0) @loader_path/libicuuc.74.dylib (compatibility version 74.0.0, current version 74.2.0) @loader_path/libicudata.74.dylib (compatibility version 74.0.0, current version 74.2.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 905.6.0) 可以明显看到，74中的相关依赖是多了@loader_path，而72中没有。\n大胆猜测一下，说不定正是因为i18n依赖了别的库，而库的地址，就是因为少了@loader_path所以才会有最后一个错误的提示，这样是不是就能说得通了？\n马上着手改一下试试\n1 2 3 4 5 6 7 8 9 10 cd /usr/local/opt/icu4c/lib install_name_tool -change libicuuc.72.dylib @loader_path/libicuuc.72.dylib ./libicui18n.72.dylib otool -L ./libicui18n.72.dylib # 执行结果： ./libicui18n.72.dylib: libicui18n.72.dylib (compatibility version 72.0.0, current version 72.1.0) @loader_path/libicuuc.72.dylib (compatibility version 72.0.0, current version 72.1.0) libicudata.72.dylib (compatibility version 72.0.0, current version 72.1.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 905.6.0) 再来执行php看下\n1 2 3 4 5 6 php73 --version # 执行结果： dyld: Library not loaded: libicudata.72.dylib Referenced from: /usr/local/Cellar/icu4c/74.2/lib/libicui18n.72.dylib Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 很好，错误内容有新的变化了，不再是libicuuc.72.dylib了，而libicudata.72.dylib正是下一个要依赖的动态库，说明修改起作用了，继续改\n1 install_name_tool -change libicudata.72.dylib @loader_path/libicudata.72.dylib ./libicui18n.72.dylib 再执行php观察返回结果\n1 2 3 4 5 6 php73 --version # 执行结果： dyld: Library not loaded: libicudata.72.dylib Referenced from: /usr/local/Cellar/icu4c/74.2/lib/libicuuc.72.dylib Reason: image not found zsh: abort /usr/local/opt/php@7.3/bin/php --version 很好，这次Referenced from是libicuuc.72.dylib了，说明改对了，接下来就是重复这个过程，直到把icu4c所有动态库的依赖地址都改掉，再来看下结果：\n1 2 3 4 5 6 php73 --version # 执行结果： PHP 7.3.33 (cli) (built: Jun 8 2023 15:56:42) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies 至此，问题终于解决了，总算没白费磕了那么多时间，又可以写一篇文章了😎。\n参考 macOS 开发中动态库问题剖析-腾讯云开发者社区-腾讯云 php 执行报错 icu4c错误 - 蓝静空 - 博客园 解决mac下:dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.64.dylib - 笨笨韩 - 博客园 Importing Enterprise Application Projects into Oracle Developer Studio IDE MacOS 遇到 dyld: Library not loaded: xxx.dylib 的解决方案 - 简书 MAC 升级 Homebrew 导致icu4c库依赖版本问题_failed to download resource \u0026ldquo;icu4c.rb-CSDN博客 解决mac下:dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.64.dylib_dyld[72382]: library not loaded: libicui18n.64.dyl-CSDN博客 Dynamic Library Usage Guidelines ","date":"2024-04-26T15:24:57+08:00","image":"https://ghjayce.github.io/asset/blog/xLrs7QpeKQhM85mLcIcqMjAyNDA0MjZfMTUzMTU1.png","permalink":"/p/system/mac/env/php/icu4c-load-dylib/","title":"Mac系统多个php版本环境下未找到icu4c动态库的解决过程"},{"content":"目录 第一章 C++语言简介 P29 ~ 56（14页） 第二章 面向对象的基本概念 P61 ~ 84（12页） 第三章 类和对象进阶 P91 ~ 140（25页） 第四章 运算符重载 P150 ~ 172（12页） 第五章 类的继承与派生 P177 ~ 236（30页） 第六章 多态与虚函数 P244 ~ 270（14页） 第七章 输入/输出流 P276 ~ 297（11页） 第八章 文件操作 P302 ~ 324（12页） 第九章 函数模板与类模板 P329 ~ 348（10页） 考试重点 前言 hello world 创建文件hello.cpp，编写代码：\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;hello world!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 编译并运行\n1 2 g++ hello.cpp -o hello ./hello 第一章 C++语言简介 第二节 C++语言的特点 编译式、通用的、大小写敏感的编程语言。 可运行于多种平台，如Windows、Mac及Unix多种版本的操作系统。 加入了面向对象的概念。 C语言的继承，可以像C语言那样进行结构化程序设计。 一、基本的输入/输出 在C语言中，标准的键盘输入、屏幕输出分别是scanf()、printf()两个函数。\n在C++中，类库中提供了输入流类istream、输出流类ostream，也就是cin、cout对象。\n从输入流中获取数据的操作称为提取操作，向输出流中添加数据的操作称为插入操作。\n运算符\u0026gt;\u0026gt;、\u0026lt;\u0026lt;是移位运算符，在C++类库提供的头文件\u0026lt;iostream\u0026gt;中重载了这两个符号，所以\u0026gt;\u0026gt;成了流提取运算符，\u0026lt;\u0026lt;成了流插入运算符。\ncin语法：\n1 cin \u0026gt;\u0026gt; 变量1 \u0026gt;\u0026gt; 变量2 \u0026gt;\u0026gt; ... \u0026gt;\u0026gt; 变量n; 当连续从键盘读取数据时，以空格、制表符、回车符作为分隔符。\n如果输入的内容是分隔符开头，cin会忽略并清除掉，直到读取你输入的内容。 cin会识别遇到的第一个分隔符作为整个输入过程使用的分隔符。 cout语法：\n1 cout \u0026lt;\u0026lt; 表达式1 \u0026lt;\u0026lt; 表达式2 \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; 表达式n; cout会自动判断输出数据的类型，按相应类型输出对应的数据，同一个cout支持多个不同类型的数据。\n代码实践下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int int1, int2; char strArray[20]; string str1 = strArray; double double1; char char1 = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;输入两个整型值，一个单字符，一个字符串和一个浮点值\u0026#34; \u0026lt;\u0026lt; \u0026#34;以空格/Tab键/Enter键分隔: \u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; int1 \u0026gt;\u0026gt; int2 \u0026gt;\u0026gt; char1 \u0026gt;\u0026gt; str1 \u0026gt;\u0026gt; double1; cout \u0026lt;\u0026lt; \u0026#34;输入内容分别是: \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; int1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; int2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; char1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; double1 \u0026lt;\u0026lt; endl; return 0; } 其中\nendl是换行作用，在屏幕输出时还能避免出现%符号。 二、头文件和命名空间 头文件 每条#include指令仅可包含一个头文件。 系统提供的头文件一般不以.h结尾，C语言的头文件是以.h结尾。 使用尖括号括住系统提供的头文件：#include \u0026lt;iostream\u0026gt;，C++编译器首先在系统设定的目录中寻找要包含的文件，如果没有找到，再到指令中指定的目录中查找。 使用双引号括住自定义的头文件：#include \u0026quot;e:\\myprog\\ex1.h\u0026quot;，C++编译器在用户当前目录或指令中指定的目录下寻找要包含的文件。 C++常见头文件： 标准输入输出流：\u0026lt;iostream\u0026gt; microsoft、cppreference。 标准文件流：\u0026lt;fstream\u0026gt; microsoft、cppreference。 标准字符串处理函数：\u0026lt;string\u0026gt; microsoft、cppreference。 标准数学函数：\u0026lt;cmath\u0026gt; microsoft、cppreference。 命名空间 using namespace std;表示使用命名空间std，这样就无需使用这种写法std::cin、std::cout、std::endl 命名空间语法格式：\n1 2 3 4 namespace 命名空间名 { 命名空间的各种声明(函数声明、类声明、...) } 参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;ios\u0026gt; #include \u0026lt;streambuf\u0026gt; #include \u0026lt;istream\u0026gt; #include \u0026lt;ostream\u0026gt; namespace std { extern istream cin; extern ostream cout; extern ostream cerr; extern ostream clog; extern wistream wcin; extern wostream wcout; extern wostream wcerr; extern wostream wclog; } 三、强制类型转换运算符 当不同类型的量进行混合算术运算时，系统自动进行合理的类型转换，比如：\n1 2 int k; double j=5; 5*k+j的值是什么类型？\n答：根据C++的类型提升规则，当一个 int 类型的值和一个 double 类型的值进行算术运算时，int 类型的值会被提升（promoted）到 double 类型，以便两个操作数类型一致。这是因为 double 类型比 int 类型更宽泛（numerically wider），所以可以容纳 int 类型的值而不会丢失信息。所以值是double类型，5*k被提升为double类型和j进行相加。\n也可以在程序中使用强制类型转换运算符，可以用static_cast或者const_cast进行转换。\nstatic_cast用于将一种数据类型转换成另一种数据类型，格式如下：\n1 static_cast\u0026lt;类型名\u0026gt;(表达式) static_cast也可以省略，有4种写法：\n1 2 3 4 int1 = static_cast\u0026lt;int\u0026gt;(double1); int2 = int(double1); // 强制类型转换运算符的新写法 int2 = (int)double1; // 旧写法 int2 = double1; // 自动类型转换 const_cast用于去除指针和引用的常量性，但不能去除变量的常量性，格式如下：\n1 const_cast\u0026lt;类型名\u0026gt;(表达式) 功能是：\n将常量指针转化成非常量的指针，并且仍然指向原来的对象； 或是将常量引用转换成非常量的引用，并且仍然指向原来的对象。 四、函数参数的默认值 默认值可以是常数，还可以是任何有定义的表达式，但禁止是函数内部的局部变量。\nC++语言规定，有默认值的形参必须在形参列表的最后。\n如果某个形参没有默认值，则它左侧的所有形参都不能有默认值。 在有默认值的形参的右侧，不能出现无默认值的形参。 在声明函数原型时，可以省略形参的名字，可以只给出它的类型及默认值。\n定义：\n1 2 3 4 5 // a、b、c都称作形参 // func(形参列表) void func(int a=11, int b=22, int c=33) { } 声明和调用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func(); // 对 func(55); // 对 void test1(int =2, double =3.0); // 对 void test2(int a, double b=3.0); // 对 void test3(int a=2, double b); // 错 void func1(int a, int b=2, int c=3); // 对 void func2(int a=1, int b, int c=3); // 错 void func3(int a=1, int b=2, int c); // 错 // 1、22、33这些都称作实参 func1(1, 22, 33); // 对 func1(); // 错 func1(1, 29); // 对 func1(5, , 9); // 错 int Max(int m, int n); int a, b; void func4(int x, int y=Max(a, b), int z=a-b) { } func4(4); // 对 func4(4, 9); // 对 五、引用和函数参数的传递 简单总结：引用相当于变量的别名，别名和引用的变量实际是同一个首地址。\n引用的定义 定义格式：\n1 类型名 \u0026amp;引用名 = 同类型的某个变量名; 例：\n1 2 int int1; int \u0026amp;int2 = int1; // int2 = 0 不能空引用，引用的变量必须初始化（引用必须指向某个已存在的内存区域的首地址）。C++98标准下，系统自动将int1，初始化为0。 不能声明引用的引用，int \u0026amp;int3 = \u0026amp;int2是错误的。 引用分为常引用和普通引用，不能通过常引用修改其引用的变量，而普通引用可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int int1 = 123; int \u0026amp;int2 = int1; int2 = 321; // 结果: int1: 321; int2: 321 cout \u0026lt;\u0026lt; \u0026#34;int1: \u0026#34; \u0026lt;\u0026lt; int1 \u0026lt;\u0026lt; \u0026#34;; int2: \u0026#34; \u0026lt;\u0026lt; int2 \u0026lt;\u0026lt; endl; const int \u0026amp;int3 = int2; //int3 = 456;//会报错error: assignment of read-only reference int1 = 123; // 结果: int1: 123; int2: 123; int3: 123 cout \u0026lt;\u0026lt; \u0026#34;int1: \u0026#34; \u0026lt;\u0026lt; int1 \u0026lt;\u0026lt; \u0026#34;; int2: \u0026#34; \u0026lt;\u0026lt; int2 \u0026lt;\u0026lt; \u0026#34;; int3: \u0026#34; \u0026lt;\u0026lt; int3 \u0026lt;\u0026lt; endl; return 0; } 引用在函数中的使用 定义：\n1 2 3 void func1(int \u0026amp;int1, string \u0026amp;str1) { } 引用可以作为函数的返回值，例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int \u0026amp;refVal(int \u0026amp;x) { return x; } int main() { int int1 = 10; int int2 = 20; refVal(int1) = 40; refVal(int2) = 30; // 结果: int1: 40; int2: 30 cout \u0026lt;\u0026lt; \u0026#34;int1: \u0026#34; \u0026lt;\u0026lt; int1 \u0026lt;\u0026lt; \u0026#34;; int2: \u0026#34; \u0026lt;\u0026lt; int2 \u0026lt;\u0026lt; endl; return 0; } 函数的返回值还可以是指针，这样的函数称为指针函数。格式如下：\n1 数据类型 *函数名(形参列表){} 例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int *findLarger(int *num1, int *num2) { // *num1是取内存地址的值，num2是内存地址 // 结果: *num1: 10; num2: 0x7fff363ab310 cout \u0026lt;\u0026lt; \u0026#34;num1: \u0026#34; \u0026lt;\u0026lt; *num1 \u0026lt;\u0026lt; \u0026#34;; num2: \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; if (*num1 \u0026gt; *num2) { return num1; } else { return num2; } } int main() { int a = 10; int b = 20; int *larger_ptr = findLarger(\u0026amp;a, \u0026amp;b); // 结果: 较大值为: 20 cout \u0026lt;\u0026lt; \u0026#34;较大值为: \u0026#34; \u0026lt;\u0026lt; *larger_ptr \u0026lt;\u0026lt; endl; return 0; } 六、const与指针共同使用 const是类型限定符的一种，其作用是限定访问权限。\n类型限定符：\nconst，声明变量只读，变量的值不能被修改，例：const int MAX_VALUE = 100;。 volatile，声明变量易变，变量的值可能在未知的情况下发生改变，防止编译器对该变量进行优化，例：volatile int sensorValue;。 mutable，类中的成员变量可以在常量成员函数中被修改。 1 2 3 4 5 6 7 class example { public: mutable int counter; void incrementCounter() const { counter++; } } const有三种使用情况：\nconst在符号*左侧，表示指针所指数据是常量，数据禁止由本指针改变，但可以通过其他方式修改。指针本身是变量，可以指向其他的内存地址。简记数据是常量。 1 2 3 4 5 6 7 8 9 string str0 = \u0026#34;hello\u0026#34;; const string *str1 = \u0026amp;str0; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // str1: 0x7ffc033659c0 string str2 = \u0026#34;world\u0026#34;; str1 = \u0026amp;str2; // 可以 cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; // str1: 0x7ffc033659a0 //*str1 = \u0026#34;test\u0026#34;; // 不可以 const在符号*右侧，表示指针本身是常量，禁止本指针指向其他地址，指针所指的数据可以由本指针修改。简记指针是常量。 1 2 3 4 5 6 7 8 9 string str0 = \u0026#34;hello\u0026#34;; string *const str1 = \u0026amp;str0; cout \u0026lt;\u0026lt; *str1 \u0026lt;\u0026lt; endl; // str1: hello string str2 = \u0026#34;world\u0026#34;; //str1 = \u0026amp;str2; // 不可以 *str1 = \u0026#34;test\u0026#34;; // 可以 cout \u0026lt;\u0026lt; *str1 \u0026lt;\u0026lt; endl; // str1: test 符号*左右都有const，表示指针本身和所指数据都是常量，禁止修改指针本身和修改指针所指数据。简记指针和数据都是常量。 1 2 3 4 5 6 7 string str0 = \u0026#34;hello\u0026#34;; const string *const str1 = \u0026amp;str0; cout \u0026lt;\u0026lt; *str1 \u0026lt;\u0026lt; endl; // str1: hello string str2 = \u0026#34;world\u0026#34;; //str1 = \u0026amp;str2; // 不可以 //*str1 = \u0026#34;test\u0026#34;; // 不可以 七、内联函数 inline是声明内联函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; // 内联函数定义 inline int max(int a, int b) { return (a \u0026gt; b) ? a : b; } int main() { int num1 = 10; int num2 = 20; // 在编译期间在这个调用点，将函数的代码插入到这个位置 int maxValue = max(num1, num2); // 编译期间，此时并不会产生函数调用 std::cout \u0026lt;\u0026lt; \u0026#34;较大的数字是: \u0026#34; \u0026lt;\u0026lt; maxValue \u0026lt;\u0026lt; std::endl; // 此时才产生函数调用 return 0; } 八、函数的重载 重载的目的：使用相同的函数名调用功能相似的函数，减少命名空间的浪费。\n重载满足条件：\n形参表中对应的形参类型不同。 形参表中形参个数不同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int bigger(int x, int y) { cout \u0026lt;\u0026lt; \u0026#34;int bigger: \u0026#34;; return x \u0026gt; y ? x : y; } float bigger(float x, float y) { cout \u0026lt;\u0026lt; \u0026#34;float bigger: \u0026#34;; return x \u0026gt; y ? x : y; } double bigger(double x, double y) { cout \u0026lt;\u0026lt; \u0026#34;double bigger: \u0026#34;; return x \u0026gt; y ? x : y; } double bigger(int x, double y) { cout \u0026lt;\u0026lt; \u0026#34;double2 bigger: \u0026#34;; return x + y; } string bigger(string x, string y) { cout \u0026lt;\u0026lt; \u0026#34;string bigger: \u0026#34;; return x \u0026gt; y ? x : y; } string bigger(string x, string y, string z) { cout \u0026lt;\u0026lt; \u0026#34;string2 bigger: \u0026#34;; return x + y \u0026gt; z ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39;; } int main() { cout \u0026lt;\u0026lt; bigger(1, 2) \u0026lt;\u0026lt; endl; // int bigger: 2 cout \u0026lt;\u0026lt; bigger(1.1, 1.2) \u0026lt;\u0026lt; endl; // double bigger: 1.2 cout \u0026lt;\u0026lt; bigger(1.1f, 1.2f) \u0026lt;\u0026lt; endl; // float bigger: 1.2 cout \u0026lt;\u0026lt; bigger(\u0026#34;a\u0026#34;, \u0026#34;A\u0026#34;) \u0026lt;\u0026lt; endl; // string bigger: a cout \u0026lt;\u0026lt; bigger(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) \u0026lt;\u0026lt; endl; // string2 bigger: no cout \u0026lt;\u0026lt; bigger(1, 1.2) \u0026lt;\u0026lt; endl; // double2 bigger: 2.2 return 0; } 错误的重载情况\n1 2 3 4 5 6 7 8 9 // 二义性情况 int sum(int x, int y, int z = 0); int sum(int x, int y); // 编译器不能确定你到底调用的是哪个函数 sum(1, 2); // 形参类型和数量都一样，仅返回值不一样，也不足以编译器区分，会报错 int sum(int x, int y); double sum(int x, int y); 九、指针和动态内存分配 指针定义：\n1 2 3 4 int a = 100; int *p = \u0026amp;a; // *表示是一个指针，*p是指针变量 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; // 内存地址 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // 100 静态内存分配：编译时确定数组空间大小，例：int arr[10]; 动态内存分配：内存分配是在程序运行期间进行的，运行期间才能确定占用内存的大小。 动态内存分配，语句格式：p = new T，p表示指针变量，T任意数据类型。\n1 2 3 4 5 6 7 8 9 int *p; p = new int; // 动态分配4个字节大小的内存空间 *p = 5; // *p向内存空间写入数值5 // 分配任意大小，语句格式 p = new T[n]; int *pArr; int i = 5; pArr = new int[i*20]; // 分配了100个元素的整型数组 pArr[100]; // 下标越界，超出了范围，编译不报错，也不会提示，运行和使用会得到意料之外的结果。 动态申请的内存空间需要再使用完以后释放，语法：\n1 delete 指针; delete不能用在非new动态申请的内存空间，编译过程不报错不提示，运行时报错。\ndelete释放掉指针所指向的空间后，再访问这个空间时，会得到意料之外的结果。\n如果是一个动态分配的数组，语法：\n1 delete[] 指针; 如果动态分配了一个数组，但却用delete 指针的方式，编译不报错不提示但实际没有被完全释放\n十、用string对象处理字符串 C++标准模板库中提供了string数据类型，专门用于处理字符串。\nstring是一个类，这个类型的变量称为“string对象”。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string str1; string city = \u0026#34;hello\u0026#34;; // h的下标是0 char name[] = \u0026#34;world\u0026#34;; string str2 = name; string citys[] = {\u0026#34;Beijing\u0026#34;, \u0026#34;Shanghai\u0026#34;, \u0026#34;Guangzhou\u0026#34;}; cout \u0026lt;\u0026lt; citys[0] \u0026lt;\u0026lt; endl; // Beijing cout \u0026lt;\u0026lt; sizeof(citys) / sizeof(string) \u0026lt;\u0026lt; endl; // 数组元素个数 return 0; } length()和size()没有区别，都是获取字符长度，前者是后者的别名函数。 string类型的字符串必须用双引号包起来，单引号只能用于单个字符。 string对象之间可以用\u0026lt;、\u0026lt;=、==、!=、\u0026gt;=、\u0026gt;运算符进行比较，大小的判定标准是按字典序（基于ASCII码）进行的，而且是大小写相关的。 例如：大写字母的ASCII码小于小写字母的ASCII码，A~Z的ASCII码是0x41~0x5a，a~z是0x61~0x7a，ASCII码对照表_百度、ASCII 码表_cppreference。 string对象、字符之间可以使用+运算符进行拼接。 1 2 3 4 string str = \u0026#34;hello world\u0026#34;; char str1 = str[5]; char strArr1[] = \u0026#34;jayce\u0026#34;; cout \u0026lt;\u0026lt; str + str1 + string(strArr1) \u0026lt;\u0026lt; endl; 常用成员函数：\n函数 功能 const char *c_str() const; 返回一个指向字符串的指针，字符串内容与本string串相同，用于将string转换为const char * int size() const; 返回当前字符串的长度，一个汉字长度为2 int length() const; size()的别名函数 bool empty() const; 字符串判空 size_type find(const char *str, size_type index); 返回str在字符串中第一次出现的位置（从index开始查找），如果没找到返回 -1 size_type find(char ch, size_type index); 返回字符ch在字符串中第一次出现的位置（从index开始查找），如果没找到返回 -1 string \u0026amp;insert(int p, const string \u0026amp;s); 在p位置插入字符串s string \u0026amp;append(const char *s); 将字符串s连接到当前字符串的结尾处 string substr(int pos = 0, int n = npos) const; 返回从pos开始的n个字符组成的字符串 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; // strcpy using namespace std; int main() { string str1 = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;str1: \u0026#34; \u0026lt;\u0026lt; str1.size() \u0026lt;\u0026lt; endl; string str2; cout \u0026lt;\u0026lt; \u0026#34;str2: \u0026#34; \u0026lt;\u0026lt; str2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;find: \u0026#34; \u0026lt;\u0026lt; str1.find(\u0026#34;o\u0026#34;) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; str1.find(\u0026#34;d\u0026#34;, 11) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; string::npos \u0026lt;\u0026lt; endl; // 实测并不是返回-1，而是18446744073709551615，也就是判断找没找到要用string::npos cout \u0026lt;\u0026lt; \u0026#34;substr: \u0026#34; \u0026lt;\u0026lt; str1.substr(0, 5) \u0026lt;\u0026lt; endl; string str3 = \u0026#34;abc\u0026#34;; char str4[20]; strcpy(str4, str3.c_str()); cout \u0026lt;\u0026lt; \u0026#34;c_str: \u0026#34; \u0026lt;\u0026lt; str4 \u0026lt;\u0026lt; endl; string str5 = \u0026#34;hello\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;insert: \u0026#34; \u0026lt;\u0026lt; str5.insert(5, \u0026#34; world\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;append: \u0026#34; \u0026lt;\u0026lt; str5.append(\u0026#34;! jayce\u0026#34;) \u0026lt;\u0026lt; endl; return 0; } 第二章 面向对象的基本概念 第一节 结构化程序设计 略\n第二节 面向对象程序设计的概念和特点 一、面向对象思想的提出 面向对象技术把问题看成是相互作用的事物的集合，也就是对象的集合。\n对象具有两个特性：\n状态，指对象本身的信息，也称为属性。 行为，指对对象的操作。 对象是类的一个具象，类是对象的一个抽象。\n二、面向对象程序设计的特点 面向对象的程序设计有4个基本特点：\n抽象 封装 继承 多态 第三节 类的初步知识 一、类的定义 类是用户自定义的数据类型，定义类时系统并不会为类分配存储空间，而是把类看作是一种模板。\n访问范围说明符，一共有3种：public、private、protected，在类中不限制出现顺序和出现次数。 在C++98标准下，类中声明的任何成员不能使用auto、extern、register关键字进行修饰。 类中的成员变量不能在声明时进行初始化。 类成员函数允许重载。 类定义语法格式：\n1 2 3 4 5 6 7 8 9 10 11 class 类名 { 访问范围说明符: 成员变量1 成员变量2 ... 成员函数声明1 成员函数声明2 ... ... } 成员函数既可以在类体内定义，也可以在类体外定义。\n如果在类体内定义，默认是内联函数。\n1 2 3 4 5 6 7 8 9 10 11 class Book { private: int page; public: void nextPage(int p) { page = p; }; void prevPage(int p); // 即使在体外定义也要先定义声明 }; 在类体外定义，关键点给函数名加上类名::\n1 2 3 4 void Book::prevPage(int p) { page = p; } 定义在哪里比较好？\n答：函数体代码通常比较长，所以在类体内仅定义成员函数的原型，在体外定义函数体。\n二、类的定义示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; class MyDate { public: MyDate(); // 构造函数 MyDate(int, int, int); // 构造函数重载 void setDate(int, int, int); public: void setDate(MyDate); void print(); private: int year, month, day; }; MyDate::MyDate() { year = 1970, month = 1, day = 1; } MyDate::MyDate(int y, int m, int d) { setDate(y, m, d); } void MyDate::setDate(int y, int m, int d) { year = y; month = m; day = d; return; } void MyDate::setDate(MyDate theDate) { setDate(theDate.year, theDate.month, theDate.day); return; } void MyDate::print() { cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; endl; return; } int main() { // 创建类对象 MyDate date1 = MyDate(), date2 = MyDate(2024, 3, 21), date3; date1.print(); date2.print(); date3.print(); return 0; } 第四节 类的示例程序剖析 一、程序结构 略\n二、成员变量与成员函数的定义 成员变量一般均定义为私有访问权限。 使用类，类型定义的变量称为类的对象，例如：用string对象的变量。 每个对象都有各自的存储空间。 成员函数并非每个对象都各存一份，和普通函数一样，在内存中只有一份。 三、创建类对象的基本形式 创建对象变量的两种基本方式：\n方式一：\n1 2 3 4 5 类名 对象名; 类名 对象名(参数); 类名 对象名 = 类名(参数); 类名 对象名1, 对象名2, ...; 类名 对象名1(参数), 对象名1(参数), ...; 创建对象后（运行时），C++会为它分配相应的空间，用来存储对象所有的成员变量，而类中定义的成员函数则被分配到存储空间中的一个公用区域，由该类的所有对象共享。\n在编译阶段并不会分配内存。\n方式二：\n1 2 3 4 5 6 // A 类名 *对象指针名 = new 类名; // B 类名 *对象指针名 = new 类名(); // C 类名 *对象指针名 = new 类名(参数); 用new创建对象时返回的是一个对象指针，这个指针指向本类刚创建的这个对象。C++分配给指针的仅仅是存储指针值的空间，而对象所占用的空间分配在堆上。\n使用new创建的对象，必须用delete来删除。\n用A方法创建的对象时，调用无参的构造函数，如果这个构造函数是由编译器为类提供的，则类中成员变量不进行初始化。 用B方法，和上面一样，区别在类中的成员变量会进行初始化。 和基本数据类型一样，还可以声明对象的引用、对象的指针、对象的数组：\n1 2 3 4 5 类名 \u0026amp;对象引用名 = 对象; 类名 *对象指针名 = 对象的地址; 类名 对象数组名[数组大小]; 第五节 访问对象的成员 一、使用对象访问成员变量与调用成员函数 1 2 对象名.成员变量名 对象名.成员函数名(参数表) 二、使用指针访问对象的成员 除了使用.的方式，还可以使用指针或引用的方式来访问类成员，如果通过指针，将.换成-\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { // 创建类对象 MyDate date1; MyDate *p = new MyDate(); // 使用 new 关键字动态分配内存并将地址赋给指针 MyDate *p2 = \u0026amp;date1; // p2 指针指向 date1 p-\u0026gt;print(); p2-\u0026gt;print(); delete p; // 释放动态分配的内存 return 0; } 三、使用引用访问对象的成员 略。\n第六节 类成员的可访问范围 一、访问范围说明符的含义 访问修饰符：\npublic公有 private私有 protected保护 3种关键字出现的次数和先后次序都没有限制。\n如果类中某个成员（变量/函数）没有访问范围说明符，默认是私有成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A { int m, n; public: int a, b; int func1(); private: int c, d; void func2(); public: char e; int f; int func3(); } 公有成员变量有a、b、e、f，公有成员函数有func1、func3。 私有成员变量有m、n、c、d，私有成员函数有func2。 二、成员的访问 使用public修饰的成员，既可以在本类内和主函数内访问，也可以在其他类中访问，只要定义了该类的对象即可。 使用private修饰的成员，仅可以在本类内访问。 使用protected修饰的成员，既可以在本类内访问，也可以在子类内访问。 三、隐藏的作用 设置私有成员的机制叫作”隐藏“。\n目的是强制对私有成员变量的访问一定要通过公有成员函数进行。\n好处是成员变量类型变动时，只需要更改成员函数即可，否则所有直接访问成员变量的语句都需要修改。\n第七节 标识符的作用域与可见性 在不同的作用域声明的标识符，可见性有如下规则：\n标识符要声明在前，引用在后。 在同一个作用域中，不能声明同名的标识符，在没有互相包含关系的不同作用域中声明的同名标识符，互不影响。 如果存在两个或多个具有包含关系的作用域。 在外层声明了一个标识符，而内层没有声明同名的标识符，那么此时外层的标识符对内层可见。 如果在内层声明了一个和外层同名的标识符，则外层的标识符对内层不可见，称为内层标识符隐藏了外层同名标识符，这种机制称为隐藏规则，举个例子：。 作用域隐藏规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 1; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt;endl; // 1 for (int i = 0; i \u0026lt; 2; i++) { int a = 2; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt;endl; // 1 } 函数原型作用域 在声明函数原型时形参的作用范围就是函数原型作用域，这是C++程序中最小的作用域，例：\n1 double ares(double radius); 为什么是最小的呢？因为标识符radius的作用范围就只在函数ares形参列表里，即左右括号之间。\n局部作用域 程序中使用一对花括号括起来的一段程序称为块，作用范围就是在块内，称为局部作用域。\n类作用域 类X的成员m具有类作用域，对m的访问有3种：\n在类X的成员函数中没有声明与m同名的变量（局部作用域标识符），那在该函数内可以直接访问成员m。 在类体外，不违反m的访问修饰符限定的情况下，可以通过x.m，x是类X的对象，或者X::m。 在类体外，不违反m的访问修饰符限定的情况下，可以通过ptr-\u0026gt;m这样的表达式来访问，ptr为指向类X的一个对象的指针。 命名空间作用域 略\n第三章 类和对象进阶 介绍的内容：\n构造函数 析构函数 类中特殊的成员 重载的成员函数 this指针 友元概念 第一节 构造函数 一、构造函数的作用 用于给对象进行初始化，主要是为成员变量赋值初始值的。\n程序中涉及到的基本数据类型的变量都需要先声明并初始化，然后再使用，这样能保证变量的值是确定的。\n在C++的基本数据类型的变量声明中，分为全局变量和函数内部的局部变量（类中局部变量亦同）。\n全局变量，如果程序员仅声明没初始化，系统会在程序启动时自动为其初始化为0。 局部变量，系统不进行自动初始化，它的值必须要程序员给定，否则将是一个随机值。 构造函数由程序员编写，如果程序员未编写，由系统自动添加一个不带参数的构造函数。\n在对象生成时（任何方式声明/定义时），系统自动调用构造函数，程序员无需主动调用。\n二、构造函数的定义 在类体外的三种定义形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class 类名 { private: x1, x2, ... xn } // 形式一 类名::类名(形参1, 形参2, ..., 形参n): x1(形参1), x2(形参2), ..., xn(形参n) {} // 形式二 类名::类名(形参1, 形参2, ..., 形参n) { x1 = 形参1; x2 = 形参2; ... xn = 形参n; } // 形式三 类名::类名() { x1 = 初始化表达式1; x2 = 初始化表达式2; ... xn = 初始化表达式n; } 方式一中的x1(形参1), x2(形参2), ..., xn(形参n)称为构造函数初始化列表。\n实例一：\n1 2 3 4 5 6 7 8 9 10 11 12 class Math { protected: int k; public: Math(int n=5): k(n) { cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; } }; Math test(3); // 输出3 实例二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyDate { public: MyDate(); // 构造函数 void setDate(int, int, int); public: void setDate(MyDate); void print(); private: int year, month, day; }; MyDate::MyDate(): year(1970), month(1), day(25) {} MyDate::MyDate(int d): year(1970), month(1) { day = d; } MyDate::MyDate(int m, int d): year(1970) { month = m; day = d; } MyDate::MyDate(int y, int m, int d) { year = y; month = m; day = d; } 错误示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 示例一，编译错误，函数重复定义，函数参数列表式相同的 myDate::myDate(int d): year(1970), month(1) { day = d; } myDate::myDate(int d): year(1970), day(1) { month = d; } // 示例二，编译不提示错误，参数表带入的实参值为最终值 myDate::myDate(int d): year(1970), day(1) { day = d; } 三、构造函数的使用 对象需要占据内存空间，创建对象时，为对象分配的内存空间的初始化由构造函数完成。\n默认值\n1 2 3 4 5 6 7 8 9 10 11 12 13 class A { int a, b; public: A(int, int); }; A::A(int k, int j = 2) { a = k; b = j; cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;;b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; }; A a(3); // a:3;b:2 使用构造函数创建对象指针\n1 2 MyDate *pd = new MyDate(); MyDate *pd = new MyDate; 使用new创建对象时，加不加括号都可以，但处理上有差异。\n如果有自定义构造函数，都调用构造函数进行初始化。 如果类中没有自定义构造函数。 不加括号时，系统只为成员变量分配内存空间，不进行内存的初始化，成员变量的值是随机值。 加了括号时，系统在为成员变量分配内存的同时，将其初始化为0。 实测new创建对象，加不加括号结果都一样（没有自定义构造函数的情况），在分配内存的同时并初始化为0，书上讲的知识点估计是以前编译器的特性，和现在不一样了。\n1 2 3 // 对象数组 MyDate A[3]; // 3个元素均调用了无参数的构造函数 MyDate A[3] = {MyDate(1), MyDate(10, 25), MyDate(1980, 9, 10)}; // 调用有参数构造函数 看看调用了多少次构造函数？\n1 AB a(4), b[3], *p; 共4次，创建a对象时1次，创建b对象数组时3次，而指针p仅是个声明，并不会调用构造函数。\n四、复制构造函数与类型转换构造函数 复制构造函数 复制构造函数是构造函数的一种，也称为拷贝构造函数，是一种特殊的构造函数，作用是创建对象时用一个已存在的对象，用它的成员变量的值去初始化正在创建的这个对象。\n复制构造函数只有一个参数，参数的类型是本类的引用，参数可以是const引用，也可以是非const引用。\n一个类可以写两个复制构造函数，定义如下：\n1 2 3 A::A(const A\u0026amp;) A::A(A \u0026amp;) 如果你没有定义复制构造函数（非const的），编译器会自动生成一个非const引用的复制构造函数，如果你用了const引用的方式，但没有定义const引用的复制构造函数，编译器会报错。 如果你定义了复制构造函数，编译器只调用你定义的复制构造函数，当然函数内部的实现由你自己决定。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class TestA { public: int a; int b; void print(); }; void TestA::print() { cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } TestA varA; varA.a = 1; varA.b = 2; varA.print(); // a:1; b:2 TestA varB; varB.print(); // a:418708000; b:32765 TestA varC(varA); varC.print(); // a:1; b:2 /* ================== */ class TestB { public: int a; int b; void print(); void print() const; TestB(const TestB \u0026amp;); // 一旦定义了复制构造函数 TestB() // 无参的构造函数也必须要定义，编译器不会替你生成 { a = 123; b = 456; } }; TestB::TestB(const TestB \u0026amp;obj) { a = obj.a; } void TestB::print() { cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } void TestB::print() const { cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } const TestB varD; // const对象只能调用const成员函数，non-const对象只能调用non-const成员函数 varD.print(); // a:123; b:456 TestB varE(varD); varE.a = 456; varE.print(); // a:456; b:0 自动调用复制构造函数的3种情况：\n用一个对象去初始化另一个对象时 1 2 3 类名 对象名2(对象名1); // or 类名 对象名2 = 对象名1; 作为函数参数时，在调用函数时，会调用实参的复制构造函数来初始化形参，即实参内存地址是A，形参从实参那复制一份数据出来，形参的内存地址是B。 1 2 3 4 5 6 7 // 作为函数形参时，会调用一次复制构造函数，可以对比复制构造函数的类和obj的地址的变化 void func(TestB obj) { obj.b = 789; cout \u0026lt;\u0026lt; \u0026#34;func_obj(\u0026#34; \u0026lt;\u0026lt; \u0026amp;obj \u0026lt;\u0026lt; \u0026#34;): \u0026#34;; obj.print(); } 作为函数返回时，和作为函数参数一样，返回时会调用一次复制构造函数。 1 2 3 4 TestB func(TestB obj) { return obj; } 类型转换构造函数 如果构造函数只有一个参数，则可以看作是类型转换构造函数，作用是进行类型的自动转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Demo { int id; public: Demo(int i) { id = i; cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void printDemo(); ~Demo() { cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; void Demo::printDemo() { cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl; } int main() { Demo d4(4); d4.printDemo(); d4 = 6; d4.printDemo(); return 0; } 输出结果：\n1 2 3 4 5 6 id=4构造函数 id=4 id=6构造函数 id=6析构函数 id=6 id=6析构函数 第二节 析构函数 和构造函数一样，析构函数也是成员函数的一种，它的名字和类名相同，区别是要在类名前面加~字符。\n析构函数没有参数，也没有返回值。\n一个类中有且仅有一个析构函数，如果没有定义析构函数，编译器自动生成默认的析构函数，默认的析构函数体为空。\n析构函数不可以超过1个，不会有重载的析构函数。\n第三节 类的静态成员 一、静态变量 什么是全局变量和局部变量？\n全局变量是指在花括号之外声明的变量，作用域范围是全局可见的，即在整个项目文件内都有效。 局部变量是指在块内定义，即花括号内定义的变量。 静态变量分为2种：\n静态全局变量，使用static修饰的全局变量是静态全局变量。作用域范围是，在定义该变量的源文件内有效，项目中的其他源文件中不能使用它。 静态局部变量，使用static修饰的局部变量是静态局部变量，具有局部作用域，但却有全局生存期，即静态局部变量在程序的整个运行期间都存在，它占据的空间一直到程序结束时才释放。 静态变量均存储在全局数据区，静态局部变量只执行一次初始化，如果程序未显示给出初始值，则相当于初始化为0，如果显示给出初始值，则在该静态变量所在块第一次执行时完成初始化。\n二、类的静态成员 类的静态成员有2种：\n静态成员变量 静态成员函数 在类体内定义类的成员时，在前面加上static关键字就是静态成员了。\n类的静态成员被类的所有对象共享，不论有多少对象存在，静态成员都只有一份保存在公用内存中，对于静态成员变量，各对象看到的值都是一样的。\n定义静态成员注意点：\n在类体内先声明静态变量，然后再到类体外定义静态变量的初始值，不能直接在类体内赋值。 在类体外定义静态成员变量初值时，前面不能加static关键字，避免和一般的全局静态变量混淆，类体外静态成员函数也一样。 访问类静态成员有3种方式（注意区别于访问类成员仅能使用对象名或者对象指针作为前缀是不一样的）：\n1 2 3 4 5 类名::静态成员名 // or 类名.静态成员名 // or 对象指针-\u0026gt;静态成员名 第四节 变量及对象的生存期和作用域 略，后补\n一、变量的生存期和作用域 二、类对象的生存期和作用域 第五节 常量成员和常引用成员 const的修饰的含义是常量，作用是定义了以后不能再修改。\n在类中，可以用const关键字定义成员变量、成员函数和类的对象。\n类的常量成员变量必须进行初始化，而且只能在构造函数的成员初始化列表的方式进行，例如：\n1 2 3 4 5 6 7 8 9 class A { const int x; const int y; public: A(): x(100), y(200) { } } 使用const修饰的函数称为常量函数，格式如下：\n1 返回类型 函数名(形参表) const; 定义类的对象时，前面加const，则对该对象称为常量对象，例如：\n1 const A a(); // a就是常量对象 常量对象只能调用常量函数，而且常量对象中的各个属性值均不能修改。\n第六节 成员对象和封闭类 一个类的成员变量如果是另一个类的对象，则该成员变量称为“成员对象”，包含成员对象的类称为封闭类，这两个类为包含关系。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 class B { }; class A { B b1; }; class C { public: B print(); }; 类A、类C都是封闭类。类C是因为有函数的返回值是类B（另一个类）。\n一、封闭类构造函数的初始化列表 如例子：\n二、封闭类的复制构造函数 第七节 友元 一、友元 二、友元函数 三、友元类 假如声明了类B为类A的友元类，即类B是一个友元类，那么类B中的所有函数都是类A的友元函数，即类B的所有成员函数都可以访问类A的所有成员。\n声明格式：\n1 friend class 类名; 注意点：\n友元类的关系是单向的，还是上面的例子，类B是类A的友元类，但类A不是类B的友元类。 友元类的关系不能传递，即类B是类A的友元类，类C是类B的友元类，不等于类C是类A的友元类。 来个例子，方便理解：\n1 2 3 4 5 6 7 8 9 10 11 class C { } class B { friend class C; } class A { friend class B; } 类B的所有成员函数可以访问类A的所有成员，类C的所有成员函数可以访问类B的所有成员，但类C不能访问类A的所有成员。 类A不能访问类B、类C的所有成员。 除非确有必要，一般不把整个类声明为友元类，而仅把类中的某些成员函数声明为友元函数。\n第八节 this指针 略\n第四章 运算符重载 第四节 重载强制类型转换运算符 强制转换运算符是单目运算符，可以被重载，但只能重载为成员函数，不能重载为全局函数。\n例如：(类型名) 对象等价于对象.operator 类型名()，即变成对运算符函数的调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex { private: double real, image; public: Complex(double r = 0, double i = 0): real(r), image(i) { } operator double() { cout \u0026lt;\u0026lt; \u0026#34;调用了强制类型转换重载: double()\u0026#34; \u0026lt;\u0026lt; endl; return real; } }; int main() { Complex a(1.2, -3.4); cout \u0026lt;\u0026lt; (double)a \u0026lt;\u0026lt; endl; // 1.2 double n = 12 + a; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; // 13.2 return 0; } 第五章 类的继承与派生 一、继承的概念 通过已有的类建立新类的过程，叫作类的派生。\n原来的类称为基类/父类/一般类，新类称为派生类/子类/特殊类。\n派生类派生自基类，或继承与基类，也可以说基类派生了派生类。\n若派生类中定义了一个与基类同名的成员，成员可以是变量/函数，是允许的：\n覆盖（重定义/重写）：在派生类的成员函数中访问这个同名成员（或者通过派生类对象访问）。 隐藏（函数重定义/同名隐藏），对于成员函数，派生类既继承了基类的同名成员函数，又在派生类中重写了这个成语函数。 隐藏是指使用派生类对象调用这个成语函数时，调用的是派生类的函数，隐藏了基类的成员函数。 二、派生类的定义与大小 派生类的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义 class 派生类名:继承方式说明符 基类名 { 类体 } // 实例 class BaseClass // 基类 { int v1, v2; }; class DerivedClass:public BaseClass // 派生类 { int v3; } 继承方式说明符是指如何控制基类成员在派生类中的访问属性，有3种：\npublic公有继承，常用，基类的私有成员不可访问外，公有和保护成员均可访问。 private私有继承，基类的私有成员不可访问，公有和保护成员以私有成员出现在派生类中。 protected保护继承，基类的私有成员不可访问，公有和保护成员以保护成员出现在派生类中。 改变基类成员的访问权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class BaseClass { public: int v1, v2; BaseClass(): v1(1), v2(1) {} int temp1() {} }; class DerivedClass:public BaseClass { // 变成私有成员了 int v1; int temp1(){} public: DerivedClass(): v1(10) {} void printv() {} } 类的大小 派生类对象占用的存储空间大小 = 基类成员变量占用的存储空间大小 + 派生类对象自身成员占用的存储空间大小。\n为变量分配内存时，会进行边界对齐。\n常见内存对齐是4字节、8字节。\n在32位系统，通常以4字节为基本单位对齐。 在64位，通常以8字节。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class BaseClass { int v1, v2; char v4; public: int temp1() {} }; class DerivedClass:public BaseClass { int v3; int *p; public: int temp(){} }; sizeof(BaseClass); // 12 sizeof(DerivedClass); // 24 基类占用9个字节（4+4+1），内存对齐分配12个字节。 int占4个字节 × 2 char占1个字节 派生类占用24个字节（12+4+8），正好对齐。 int × 1 指针变量64位系统下占8个字节（32位系统减半）。 三、继承关系的特殊性 如果基类中有友元类 / 友元函数，派生类不会继承这个友元关系。 如果基类是某个类的友元，友元关系可被继承。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; using namespace std; class another; class Base { private: float x; public: void print(const another \u0026amp;K); }; class Derived:public Base { private: float y; }; class another { private: int aaa; public: another() { aaa = 100; } friend void Base::print(const another \u0026amp;K); }; void Base::print(const another \u0026amp;K) { cout \u0026lt;\u0026lt; \u0026#34;Base:\u0026#34; \u0026lt;\u0026lt; K.aaa \u0026lt;\u0026lt; endl; } int main() { Base a; Derived d; another ano; // aaa 初始化100 a.print(ano); // Base:100 d.print(ano); // Base:100 return 0; } 第六章 多态与虚函数 第一节 多态的基本概念 一、多态 基类和派生类都有同名虚函数时，通过基类的指针或引用调用：\n如果基类指针指向的是基类对象，执行的就是基类的虚函数。 如果基类指针指向的是派生类对象，执行的就是派生类的虚函数，这就叫多态。 二、虚函数 先来看一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: void foo() { cout \u0026lt;\u0026lt; \u0026#34;A::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: void foo() { cout \u0026lt;\u0026lt; \u0026#34;B::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *ptr = new B(); // 指向派生类对象的基类指针 ptr-\u0026gt;foo(); // 输出：A::foo() delete ptr; A a = B(); a.foo(); // 输出：A::foo() return 0; } 如果想要调用的是派生类类B的同名函数要怎么做到？答案就是虚函数。\n修改上面的例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: // 声明 virtual void foo(); }; // 定义 void A::foo() { cout \u0026lt;\u0026lt; \u0026#34;A::foo()\u0026#34; \u0026lt;\u0026lt; endl; } class B : public A { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;B::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *ptr = new B(); ptr-\u0026gt;foo(); // 输出：B::foo() delete ptr; A a = B(); a.foo(); // 输出：A::foo() return 0; } 没错，区别就是在函数前面增加了virtual关键字，声明为虚函数。\n这样实现了等到运行时根据引用或指针实际指向的对象来确定调用的版本，这叫动态多态。而不是在编译阶段就确定好了指向，即使在运行时也是固定的，不会发生变化，这叫静态绑定。\n虚函数使用注意点：\n虚函数声明为内联函数不会引起错误，但内联函数是在编译阶段进行静态处理的，而虚函数的调用是动态绑定的，所以虚函数一般不声明为内联函数。 派生类重写基类的虚函数实现多态，要求函数名、参数列表及返回值类型要完全相同。 基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性，派生类中的同名函数虽然可以不用加virtual关键字，但为了代码清晰和可读，推荐显示声明。 只有类的非静态成员函数才能定义为虚函数，静态成员函数和友元函数不能定义为虚函数。 虚函数定义在体外，只需在声明函数时添加virtual关键字，定义时不加。 构造函数不能定义为虚函数。最好也不要将operator =定义为虚函数，避免使用时容易混淆。 不要在构造函数和析构函数中调用虚函数。因为对象是不完整的，可能会出现未定义的行为。 最好将基类的析构函数声明为虚函数。 哪些函数不能是虚函数？为什么？\n全局函数（非成员函数），虚函数是为了与继承机制配合实现多态的，而全局函数（非成员函数）不属于某个类，没有继承关系，只能被重载，不能被覆盖，声明为虚函数也起不到多态的作用。因为编译器会在编译时绑定全局函数。 静态成员函数，所有的对象都共享，都能使用，不归某个对象所有，没有动态绑定的必要性。 内联成员函数，内联函数的目的是在代码中展开，减少函数调用的开销，是静态的，虚函数的目的是继承对象后能够动态绑定函数，两个不同的概念，虽然没限制这么做，但大可不必，上面用到了只是方便演示。 构造函数，构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用，简单点说就是对象都还没初始化呢，哪来的多态啊，这不闹吗？还有一点就是，构造函数不能被继承，因此不能声明为虚函数。 友元函数，不属于类的成员函数，不能被继承，没有必要。 三、通过基类指针实现多态 直接上例子：\n通过基类指针实现多态，基类A，派生B、C，B派生D。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: // 声明 virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;A::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;B::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; class C : public A { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;C::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; class D : public B { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;D::foo()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A a; B b; C c; D d; A *pa = \u0026amp;a; B *pb = \u0026amp;b; pa-\u0026gt;foo(); // A::foo() pa = pb; pa-\u0026gt;foo(); // B::foo() pa = \u0026amp;c; pa-\u0026gt;foo(); // C::foo() pa = \u0026amp;d; pa-\u0026gt;foo(); // D::foo() return 0; } 如果所有类的virtual去掉后，最后的结果是什么？\n答：全都输出A::foo()。\n第二个例子：用基类指针访问基类对象及派生类对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class A { public: string name; virtual void say() { cout \u0026lt;\u0026lt; \u0026#34;A::say(), name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } }; class B : public A { public: string nickname; virtual void say() { cout \u0026lt;\u0026lt; \u0026#34;B::say(), name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } void talk() const { cout \u0026lt;\u0026lt; \u0026#34;B::talk(), nickname: \u0026#34; \u0026lt;\u0026lt; nickname \u0026lt;\u0026lt; endl; } }; int main() { A *pa; // 声明一个类A的指针 A a; B b; pa = \u0026amp;a; // 指向变量a的内存地址 pa-\u0026gt;name = \u0026#34;jayce\u0026#34;; pa-\u0026gt;say(); // A::say(), name: jayce a.say(); // A::say(), name: jayce pa = \u0026amp;b; // 指向变量b的内存地址 pa-\u0026gt;name = \u0026#34;jack\u0026#34;; pa-\u0026gt;say(); // 结果是 B::say(), name: jack。==== 多态，虚函数发挥了作用，否则调用的是基类(A)的say() b.say(); // B::say(), name: jack b.nickname = \u0026#34;jack chen\u0026#34;; //pa-\u0026gt;talk(); // 会报错，因为编译器在编译时只知道pa的静态类型是A，A类中并没有定义该函数，即使后面指向了派生类B（继承了A），也并不会产生动态影响 ((B *)pa)-\u0026gt;talk(); // 必须得强制类型转换 B::talk(), nickname: jack chen b.talk(); // B::talk(), nickname: jack chen return 0; } 四、通过基类引用实现多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: string name; virtual void say() { cout \u0026lt;\u0026lt; \u0026#34;A::say(), name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } }; class B : public A { public: virtual void say() { cout \u0026lt;\u0026lt; \u0026#34;B::say(), name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; } }; void say(A \u0026amp;obj) { obj.say(); } void talk(B \u0026amp;obj) { obj.say(); } int main() { A a; B b; a.name = \u0026#34;jayce\u0026#34;; b.name = \u0026#34;jack\u0026#34;; say(a); // A::say(), name: jayce say(b); // B::say(), name: jack talk((B \u0026amp;)a); // A::say(), name: jayce talk(b); // B::say(), name: jack return 0; } 五、多态的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: int age; virtual void func() {}; virtual void func1() {}; }; class B :public A { public: int weight; void func() {} }; int main() { cout \u0026lt;\u0026lt; sizeof(A) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; sizeof(B) \u0026lt;\u0026lt; endl; // 64为系统下：16, 16 === 去掉virtual则是：4, 8 return 0; } 在64位系统下，结果是16, 16，如果去除virtual关键字则输出结果是4, 8。\n先说没有virtual的情况： 基类A只有一个int成员变量，占4个字节。 而派生类B的内存空间大小是需要加上基类A的内存空间大小，类B也有一个int成员变量，所以占8个字节。 有virtual的情况，空间明显变大了，这是因为编译系统为类对象自动添加的部分，是一块连续的内存，其中存储的是虚函数表的地址。 64位系统下，指针占8字节，8+4=12。 内存对齐（8字节）的关系，所以类A的大小是16。 而类B的大小则是8+4+4=16。 每一个有虚函数的类都有一个虚函数表，它是由编译器生成的，程序运行时被载入内存。一个类的虚函数表列出了该类的全部虚函数地址，虚函数表是类中所有对象共享的，该类的任何对象中都保存指向该虚函数表的指针。\n同一个类的所有对象共享虚函数表，各个对象有自己的指向虚函数表的指针，而且各不相同。\n虚函数执行过程：当程序执行到pa-\u0026gt;func();时：\n如果pa指向基类对象，则通过基类对象中保存的基类虚函数表的地址，找到基类对象的虚函数表，再从虚函数表中找到A::func()的入口地址，完成函数调用。 如果pa指向派生类对象，也是一样，从派生类的虚函数表中找到B::func()，完成函数调用。 如果派生类B没有重写基类的某个虚函数，则此时虚函数表中保存的是基类虚函数的地址，也就是会调用基类的虚函数。 第二节 多态实例 略\n第三节 多态的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; class Cat { public: void eat() { cout \u0026lt;\u0026lt; \u0026#34;Cat::eat\u0026#34; \u0026lt;\u0026lt; endl; searchingPrey(); huntAndKill(); rest(); } virtual void searchingPrey() { cout \u0026lt;\u0026lt; \u0026#34;Cat::寻找猎物\u0026#34; \u0026lt;\u0026lt; endl; } virtual void huntAndKill() { cout \u0026lt;\u0026lt; \u0026#34;Cat::猎杀\u0026#34; \u0026lt;\u0026lt; endl; } void rest() { cout \u0026lt;\u0026lt; \u0026#34;Cat::吃饱了休息\u0026#34; \u0026lt;\u0026lt; endl; } }; class GingerCat :public Cat { public: virtual void searchingPrey() { cout \u0026lt;\u0026lt; \u0026#34;GingerCat::寻找怨种铲屎官\u0026#34; \u0026lt;\u0026lt; endl; } void huntAndKill() { cout \u0026lt;\u0026lt; \u0026#34;GingerCat::猎杀？不存在的，我喵喵喵几声就有吃的\u0026#34; \u0026lt;\u0026lt; endl; } void rest() { cout \u0026lt;\u0026lt; \u0026#34;GingerCat::吃饱了睡觉\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { GingerCat obj; obj.eat(); return 0; } 分析：\n因为派生类没有重写eat()方法，所以调用的是基类的Cat::eat()。 Cat::eat()调用了searchingPrey()、huntAndKill()等，因为是在基类的成员函数中调用的，相当于this.searchingPrey()、this.huntAndKill()。此时的this指针是Cat *类型的，即this是一个基类指针。 当调用searchingPrey()，因为它是虚函数，相当于通过基类指针调用虚函数，结果是多态的，也就是在声明时是一个GingerCat，所以调用的是GingerCat::searchingPrey()。huntAndKill()在基类也是一个虚函数，同理不再赘述。（即使在派生类的方法中并没有写上virtual关键字，但并不会有影响） 而rest()并不是虚函数，所以当然是调用基类的函数。 第四节 虚析构函数 如果一个基类指针指向的对象是用new运算符动态生成的派生类对象，在释放该对象所占用的空间时，仅基类的析构函数会被调用，而派生类的析构函数并未被调用，导致派生类的内存空间没有被释放，导致内存泄漏。\n那怎么解决这个问题？就是虚析构函数。\n格式如下：\n1 virtual ~类名(); 如果一个类的析构函数是虚函数，则由它派生的所有子类的析构函数也是虚析构函数。\n上例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;A析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; class B :public A { public: int w, h; B() { cout \u0026lt;\u0026lt; \u0026#34;B构造函数\u0026#34; \u0026lt;\u0026lt; endl; w = 4; h = 7; } ~B() { cout \u0026lt;\u0026lt; \u0026#34;B析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; class D { public: D() { cout \u0026lt;\u0026lt; \u0026#34;D构造函数\u0026#34; \u0026lt;\u0026lt; endl; } virtual ~D() { cout \u0026lt;\u0026lt; \u0026#34;D析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; class C :public D { public: int w, h; C() { cout \u0026lt;\u0026lt; \u0026#34;C构造函数\u0026#34; \u0026lt;\u0026lt; endl; w = 12; h = 72; } ~C() { cout \u0026lt;\u0026lt; \u0026#34;C析构函数\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A *pa = new B(); delete pa; // 并没有调用到B的析构函数 cout \u0026lt;\u0026lt; \u0026#34;========\u0026#34; \u0026lt;\u0026lt; endl; D *pb = new C(); delete pb; return 0; } 输出结果：\n1 2 3 4 5 6 7 8 A构造函数 B构造函数 A析构函数 ======== D构造函数 C构造函数 C析构函数 D析构函数 第五节 纯虚函数和抽象类 一、纯虚函数 在一些情况下，基类中的某个虚函数给不出一个确切的定义，或者没有必要给出详细的定义，那么可以将它声明为一个纯虚函数。\n格式如下：\n1 virtual 函数返回类型 函数名(参数表) = 0; 纯虚函数没有函数体，所以参数表后面必须要写=0，在派生类中必须要重写这个函数。\n二、抽象类 包含纯虚函数的类称为抽象类，因为有尚未完成的函数定义，所以它不能实例化为一个对象，直到有派生类实现了纯虚函数后，它才不再是抽象类，此时可以实例化为一个对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: virtual void foo() = 0; virtual void bar() = 0; void baz() { cout \u0026lt;\u0026lt; \u0026#34;A::baz()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B :public A { public: virtual void bar() { cout \u0026lt;\u0026lt; \u0026#34;B::bar()\u0026#34; \u0026lt;\u0026lt; endl; } void baz() { cout \u0026lt;\u0026lt; \u0026#34;A::baz()\u0026#34; \u0026lt;\u0026lt; endl; } }; class C :public B { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;C::foo()\u0026#34; \u0026lt;\u0026lt; endl; bar(); } void baz() { cout \u0026lt;\u0026lt; \u0026#34;C::baz()\u0026#34; \u0026lt;\u0026lt; endl; } }; class D :public B { public: virtual void foo() { cout \u0026lt;\u0026lt; \u0026#34;D::foo()\u0026#34; \u0026lt;\u0026lt; endl; bar(); } void baz() { cout \u0026lt;\u0026lt; \u0026#34;D::baz()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { // A a; // 报错，无法实例化 // B b; // 报错，无法实例化 C c; c.foo(); cout \u0026lt;\u0026lt; \u0026#34;=====\u0026#34; \u0026lt;\u0026lt; endl; A *pa = \u0026amp;c; pa-\u0026gt;foo(); cout \u0026lt;\u0026lt; \u0026#34;=====\u0026#34; \u0026lt;\u0026lt; endl; D d; B *pb = \u0026amp;d; pb-\u0026gt;baz(); return 0; } 输出结果：\n1 2 3 4 5 6 7 C::foo() B::bar() ===== C::foo() B::bar() ===== A::baz() 三、虚基类 也就是一个类同时继承多个继承了基类的类，为了避免二义性的情况。\n格式如下：\n1 2 3 4 class 派生类名 :virtual 派生方式 基类名 { 派生类体 }; 例子：略\n第七章 输入/输出流 第一节 流类简介 第二节 标准流对象 第三节 控制I/O格式 流操纵符 第八章 文件操作 第一节 文件基本概念和文件流类 一、文件的概念 从不同的角度来看待文件就可以得到不同的文件分类。\nC++根据文件数据的编码方式不同分为文本文件和二进制文件。 根据存取方式不同分为顺序存取文件和随机存取文件。 从数据存储的角度来说，所有的文件本质上都是一样的，都是由一个个字节组成，归根到底都是0、1字节串。文本文件和二进制文件只是格式不同而已。\n计算机将文件看成一个有序排列的字节序列，在文件内部有一个读写文件的位置指针，用以记录文件内部正在进行操作的字节位置。操作文件时，系统会自动修改这个位置指针。\n顺序存取文件，顾名思义，按照文件中数据的存储次序进行顺序操作，整个文件的操作过程，将移动位置指针的工作交给系统自动完成。 例如：磁带文件。 随机访问文件，就是通过命令移动位置指针直接定位到文件内需要的位置进行数据操作。 文件的基本操作分为读文件和写文件。\n读文件，将文件中的数据读入内存中，称为输入。 写文件，将内存中的数据存入文件中，称为输出。 二、C++文件流类 流是一个逻辑概念，是对所有外部设备的逻辑抽象。C++的I/O系统将每个外部设备都转换成一个称为流的逻辑设备，由流来完成对不同设备的具体操作。\n文件是一个物理概念，代表存储着信息集合的某个外部介质，它是C++语言对具体设备的抽象。\nC++也是使用流类对文件进行处理，标准类库中有3个流类用于文件操作，统称为文件流类：\nifstream：用于从文件中读取数据。 ofstream：从文件中写入数据。 fstream：对文件既可以读又可以写。 文件流类关系：\n类ifstream、类fstream都是从类istream派生出来的。 类ofstream是从类ostream派生出来的。 fstream是同时继承了类ifstream和类ofstream。 文件操作：打开、读、写、关闭等。\n第二节 打开和关闭文件 一、打开文件 在对文件进行读写操作之前，要先打开文件，有两个目的：\n建立关联。通过指定文件名，建立起文件和文件流对象的关联，以后在对文件进行操作时，可以通过流对象来进行。 指明文件的使用方式和文件格式。 使用方式：只读、只写、既读又写、在文件末尾追加数据。 文件格式：文本、二进制。 打开文件的两种格式：\n1 2 3 4 5 6 // 方式一 流类名 对象名; 对象名.open(文件名, 模式); // 方式二 流类名 对象名(文件名, 模式); 文件名，是一个字符串，可以是绝对路径（完整路径），也可以是相对路径。 模式，是类ios定义的打开模式标记常量，即表示文件的打开方式，这些标记可以单独使用，也可以组合使用。 模式标记常量 适用对象 作用 ios::in ifstream、fstream 以读方式打开文件，文件不存在，则打开出错 ios::out ofstream、fstream 以写方式打开文件，文件不存在，新建该文件；文件存在，在打开时清除文件内容 ios::app ofstream 以追加方式打开文件，在文件末尾添加数据，文件不存在则新建 ios::ate ofstream 打开一个已有文件，将文件读指针指向文件末尾，文件不存在则打开出错 ios::trunc ofstream 删除文件现有内容，单独使用时与ios::out相同 ios::binary ifstream、ofstream、fstream 以二进制方式打开文件。不指定的话默认是文本模式 ios::in|ios::out fstream 打开已存在的文件，可读可写，文件打开原内容保持不变，文件不存在则打开出错 ios::in|ios::out ofstream 和上面一样，区别在不能读 ios::in|ios::out|ios::trunc fstream 一样，区别在文件不存在时新建，存在则打开时清除文件的内容 二、关闭文件 当一个文件操作完毕应该及时关闭文件，发出关闭文件命令后，系统会将缓冲区中的数据完整地写入文件，同时添加文件结束标记，切断流对象与外部文件的连接。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string name; ifstream obj1; name = \u0026#34;test1.txt\u0026#34;; obj1.open(name, ios::in); if (obj1) { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开失败\u0026#34; \u0026lt;\u0026lt; endl; } name = \u0026#34;test2.txt\u0026#34;; ofstream obj2(name, ios::out); if (obj2) { obj2 \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; // 写入内容 obj2.close(); // 关闭文件并将写入内容从缓冲区写入到文件中 } else { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开失败\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 第三节 文件读写操作 一、读写文本文件 C++将文件看成顺序排列的无结构的字节流。\n对于长度为n的文件来说，字节号从0~n-1。\n每个文件都有一个文件结束标识，也就是在n的位置上。对于文本文件来说，C++在iostream中定义了一个标识文件结束的标识常量EOF，其值为0x1A的字符。\n在关闭文件流时，该字符将被自动加入到文件尾部。在键盘操作时，按下Ctrl + Z键，就可以在标准输入流cin中输入文件结束符。\n使用文件流对象打开文件后，文件就成了一个输入流或输出流，对于文本文件，可以用cin、cout进行读写，在标准输入流/输出流中可以使用的成员函数和流操纵符同样适用于文件流。\n例子一，对文件score.txt进行输入/输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char id[11], name[21]; int score; string fileName = \u0026#34;./temp/score.txt\u0026#34;; ofstream file1(fileName, ios::out); if (!file1) { cout \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; \u0026#34;创建失败\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;请输入：学号 姓名 成绩（按Ctrl + Z结束输入）\\n\u0026#34;; while (cin \u0026gt;\u0026gt; id \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score) { file1 \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl; } file1.close(); return 0; } 例子二，读取score.txt的内容并打印到屏幕\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { char id[11], name[21]; int score; string fileName = \u0026#34;./temp/score.txt\u0026#34;; ifstream file1(fileName, ios::in); if (!file1) { cout \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; \u0026#34;文件不存在，打开失败\u0026#34; \u0026lt;\u0026lt; endl; return 0; } cout \u0026lt;\u0026lt; \u0026#34;学生信息：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; \u0026#34;学号 姓名 成绩\u0026#34; \u0026lt;\u0026lt; endl; while (file1 \u0026gt;\u0026gt; id \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score) { // \u0026gt;\u0026gt; 按照空格或换行符进行分隔将数据存到不同的变量中 cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl; } file1.close(); return 0; } 输出结果：\n1 2 3 4 学生信息： 学号 姓名 成绩 00123 张三 90 00124 李四 9 例子三，逐行读取score.txt的内容并打印到屏幕： score.txt文件内容：\n1 2 00123 张三 90 00124 李四 9 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string name = \u0026#34;./temp/score.txt\u0026#34;; ifstream obj3(name, ios::in); char ch; bool newLine = true; int lineCount = 0; if (obj3) { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开成功\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;以下是文件内容：\u0026#34; \u0026lt;\u0026lt; endl; while ((ch = obj3.get()) != EOF) { if (newLine) { cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; ++lineCount \u0026lt;\u0026lt; \u0026#39;:\u0026#39;; newLine = false; } if (ch == \u0026#39;\\n\u0026#39;) { newLine = true; } cout \u0026lt;\u0026lt; setw(0) \u0026lt;\u0026lt; ch; } obj3.close(); } return 0; } 输出结果：\n1 2 3 4 ./temp/score.txt打开成功 以下是文件内容： 1:00123 张三 90 2:00124 李四 9 fstream成员函数官方文档：std::basic_fstream - cppreference.com\n例子四，对文本文件的内容排序，将结果输出到另一个文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; const int MAX_SIZE = 1000; class Student { public: char id[11]; char name[21]; int score; } stu[MAX_SIZE]; int compare(const void *obj1, const void *obj2) { return (*(Student *)obj1).score - (*(Student *)obj2).score; } int main() { string name = \u0026#34;./temp/score.txt\u0026#34;; ifstream file1(name, ios::in); if (!file1) { file1.close(); cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开失败\u0026#34; \u0026lt;\u0026lt; endl; return 0; } name = \u0026#34;./temp/result.txt\u0026#34;; ofstream file2(name, ios::out); if (!file2) { file2.close(); cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;打开失败\u0026#34; \u0026lt;\u0026lt; endl; return 0; } int n = 0; cout \u0026lt;\u0026lt; \u0026#34;排序前: \\n\u0026#34;; while (file1 \u0026gt;\u0026gt; stu[n].id \u0026gt;\u0026gt; stu[n].name \u0026gt;\u0026gt; stu[n].score) { cout \u0026lt;\u0026lt; stu[n].id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[n].name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[n].score \u0026lt;\u0026lt; endl; n++; } qsort(stu, n, sizeof(Student), compare); cout \u0026lt;\u0026lt; \u0026#34;排序后: \\n\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { cout \u0026lt;\u0026lt; stu[i].id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].score \u0026lt;\u0026lt; endl; file2 \u0026lt;\u0026lt; stu[i].id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].score \u0026lt;\u0026lt; endl; } file1.close(); file2.close(); return 0; } 结果：\n1 2 3 4 5 6 排序前: 00123 张三 90 00124 李四 9 排序后: 00124 李四 9 00123 张三 90 cstdlib函数库官方文档：标准库标头 \u0026lt;cstdlib\u0026gt; - cppreference.com\n二、读写二进制文件 文本文件在存储数据时以ASCII码保存数据的，虽然使用上比较方便，但文本格式存储数据占用的空间大，而且数据输入/输出还要在内存和外存之间做数据格式的转换。\n二进制数据文件以基本类型数据的二进制格式存放，即内存和外存所存储的数据格式都是一致的二进制格式。\n存储长度仅与数据类型有关，例如一个double类型数据，无论是-12345.678，还是3.1415926，在内存中都采用二进制存储，占用8个字节，将这些数据保存到二进制文件中，也还是占用8个字节，与内存中的表示完全一致。\n都不需要做数据格式的转换了，处理数据那不得比文本格式快多了，就好比国道和高速公路。\n因此二进制数据文件又称为类型文件，由“数据类型”定义的一个“单元”通常包含若干个数据项，由若干个字节组成，称为一个文件的“记录”，或是文件的“元素”。\n存储说明 二进制数据文件的读写操作完全由程序控制，一般的文字处理软件不能直接参与编辑。\n例如用以下的类表示学生的信息：\n1 2 3 4 5 6 7 class Student { public: char id[11]; char name[21]; int score; }; 用文本文件存储内容如下：\n1 2 3 00123 ZhangSan 90 00124 LiSi 100 00125 WangWu 78 在这种存储格式下，每个学生信息占一行，每行的长度都不一样，即使整个文件中的学生信息都是按姓名排好序的，要根据名字进行查找，仍然没有什么好办法，只能从头到尾对整个文件进行查找。\n如果把整个文件都读入内存，排序后再进行查找，当然速度会很快，但如果文件非常大，数据量巨大，把所有信息都读入内存根本不现实。\n而二进制的格式存储，则是把Student对象作为一个整体直接写入文件，在该文件中，每个学生的信息都占sizeof(Student)个字节，对象写入文件后一般称为“记录”，每个学生都对应一条记录，除了免去内存和外存之间的格式转换，也免去了对文件存储格式的设计，减少了工作量。\n那怎么读写二进制文件呢？\n答：可以用ios::binary()的方式打开二进制文件，调用ifstream或fstream的read()读数据，写数据则是调用ofstream或fstream的write()，但不能用cin、cout从流中读写数据。\n用ostream::write()成员函数写文件 原型如下：\n1 ostream \u0026amp; write(char *buffer, int nCount); 该成员函数将内存中buffer所指向的nCount个字节的内容写入文件，返回值是对函数所作用的对象的引用。\n例子一，以二进制文件保存学生信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Student { public: string id; string name; int score; }; int main() { Student stu; string fileName = \u0026#34;./temp/student.dat\u0026#34;; ofstream file1(fileName, ios::out | ios::binary); if (!file1) { cerr \u0026lt;\u0026lt; \u0026#34;无法打开文件: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;请输入学生信息, 学号、姓名、成绩, 按\u0026#39;enter\u0026#39;输入下一个信息，输入\u0026#39;exit\u0026#39;退出\u0026#34; \u0026lt;\u0026lt; endl; while (true) { cout \u0026lt;\u0026lt; \u0026#34;请输入学号: \u0026#34;; cin \u0026gt;\u0026gt; stu.id; if (stu.id == \u0026#34;exit\u0026#34;) break; cout \u0026lt;\u0026lt; \u0026#34;请输入姓名: \u0026#34;; cin.ignore(); // 忽略之前留在输入流中的换行符 getline(cin, stu.name); cout \u0026lt;\u0026lt; \u0026#34;请输入成绩: \u0026#34;; cin \u0026gt;\u0026gt; stu.score; if (cin.fail()) { cerr \u0026lt;\u0026lt; \u0026#34;输入错误，请重新输入。\u0026#34; \u0026lt;\u0026lt; endl; cin.clear(); // 清除错误标志 cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); // 忽略错误输入直到下一个换行符 continue; } cout \u0026lt;\u0026lt; \u0026#34;学号: \u0026#34; \u0026lt;\u0026lt; stu.id \u0026lt;\u0026lt; \u0026#34;, 姓名: \u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34;, 成绩: \u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; // file1.write(reinterpret_cast\u0026lt;const char *\u0026gt;(\u0026amp;stu), sizeof(stu)); file1.write((char *)(\u0026amp;stu), sizeof(stu)); } file1.close(); return 0; } 说明：\n调用write()函数将对象stu作为一条记录完整写入文件，第一个参数(char *) \u0026amp;stu的含义是，通过运算符\u0026amp;得到对象stu的地址，然后通过强制类型转换成指向char型的指针，即转换为要写入文件的内存缓冲区的地址。第二个参数sizeof(stu)是得到对象stu占用的内存大小，sizeof(stu)的结果为36字节，既是对象stu在内存中占用的字节数，也是写入文件中一个记录的大小。\nsizeof(stu)的结果等价于sizeof(Student)。\n例子二，向二进制文件追加数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Student { public: string id; string name; int score; }; int main() { char ch; string fileName = \u0026#34;./temp/student.dat\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;确定要向\u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; \u0026#34;文件中追加新的数据吗？(Y/N)\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ch; if (ch != \u0026#39;Y\u0026#39; \u0026amp;\u0026amp; ch != \u0026#39;y\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;输入错误\u0026#34; \u0026lt;\u0026lt; endl; return 1; } Student stu; ofstream file1(fileName, ios::app | ios::binary); if (!file1) { cerr \u0026lt;\u0026lt; \u0026#34;无法打开文件: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;请输入学生信息, 学号 姓名 成绩, 每行一条学生记录，按\u0026#39;enter\u0026#39;输入下一个学生信息，输入\u0026#39;exit\u0026#39;退出\u0026#34; \u0026lt;\u0026lt; endl; while (true) { cin \u0026gt;\u0026gt; stu.id; if (stu.id == \u0026#34;exit\u0026#34;) { break; } cin \u0026gt;\u0026gt; stu.name \u0026gt;\u0026gt; stu.score; file1.write((char *)(\u0026amp;stu), sizeof(stu)); } file1.close(); return 0; } 用istream::read()成员函数读文件 原型如下：\n1 istream \u0026amp;read(char *buffer, int nCount); 该成员函数从文件中读取nCount个字节的内容，存放到buffer所指向的内存缓存区中，返回值是对函数所作用的对象的引用。该函数是非格式化操作，对读取的字节内容不进行处理，直接放入buffer中。\n用ostream::gcount()成员函数得到读取字节数 如果要知道每次读操作成功读取了多少个字节，可以在read()函数执行后立即调用文件流对象的成员函数gcount()，它的返回值就是最近一次read()函数执行时成功读取的字节数。\n原型：\n1 int gcount(); 例子，从二进制文件中读取数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Student { public: string id; string name; int score; }; int main() { Student stu; int count = 0, byte = 0; string fileName = \u0026#34;./temp/student.dat\u0026#34;; ifstream file1(fileName, ios::in | ios::binary); if (!file1) { cerr \u0026lt;\u0026lt; \u0026#34;无法打开文件: \u0026#34; \u0026lt;\u0026lt; fileName \u0026lt;\u0026lt; endl; return 1; } cout \u0026lt;\u0026lt; \u0026#34;学生信息：学生学号 姓名 成绩\\n\u0026#34;; while (file1.read((char *)\u0026amp;stu, sizeof(stu))) { // 读取记录直到文件结束 cout \u0026lt;\u0026lt; stu.id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; count++; byte += file1.gcount(); } cout \u0026lt;\u0026lt; \u0026#34;共有记录数: \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;; 字节数: \u0026#34; \u0026lt;\u0026lt; byte \u0026lt;\u0026lt; endl; file1.close(); return 0; } 输出结果：\n1 2 3 4 5 6 7 8 9 学生信息：学生学号 姓名 成绩 00123 张三 98 00124 李四 100 00125 王五 80 00126 老六 69 00127 小七 87 00128 老八 60 00129 馋九 75 共有记录数: 7; 字节数: 392 三、用成员函数put()和get()读写文件 略\n四、文本文件与二进制文件的异同 两者本质上没有差别，只在一些细节上存在差异。\n文本文件，以文本形式存储数据。 优点：具有较高的兼容性。 缺点： 存储一批纯数值信息时，要在数据之间人为地添加分隔符，在输入/输出过程中，系统要对内外存的数据格式进行相应转换。 不便于对数据进行随机访问。 二进制文件，以二进制形式存储数据。 优点：方便对数据进行随机访问，相同数据类型的数据所占用空间的大小均是相同的，不必在数据之间人为地添加分隔符，在输入/输出的过程中，系统不需要对数据进行任何转换。 缺点：数据兼容性差，当在不同的系统或程序之间采用二进制文件进行数据交换时，读取文件的一方必须非常了解写文件的一方采用的是什么数据类型、数据格式等非常详细的信息之后，才能将二进制文件正确解读。 第四节 随机访问文件 略\n第九章 函数模板与类模板 第一节 函数模板 一、函数模板的概念 在写代码的过程中，会遇到一种情况，除了函数形参的类型不一样，功能实现完全一样。这种情况往往需要对每个类型都定义一个单独的版本，代码重复度非常高且重复劳动。\n为了解决这个问题，C++提供了一种处理机制，就是函数模板。函数在设计时并不使用实际的类型，而是使用虚拟的类型参数，这样的好处是只需要写一个版本。\n格式如下：\n1 2 3 4 5 template \u0026lt;模板参数表\u0026gt; 返回类型 函数模板名(参数表) { 函数体的定义 } 执行过程：当用实际的类型去调用函数模板时，编译器将以函数模板为样板，生成这个类型的函数代码，这个过程称为函数模板实例化。\n模板参数表的写法和函数形参列表的写法很相似，用逗号进行分隔，形式如下：\n1 \u0026lt;类型 参数名, 类型 参数名, ...\u0026gt; 类型也称为占位符，参数名可以是C++类型，也可以是具体的值，如数字、指针等。 如果是一个类型，需要使用typename或class 关键字来表示参数的类型。 如果参数是一个值，那就是这个值的类型。 二、函数模板的示例 例子一，简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; T abs(T var) { return var \u0026gt; 0 ? var : -var; } int main() { int n = -5; int m = 10; double d = -.5; float f = 3.2; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;的绝对值是：\u0026#34; \u0026lt;\u0026lt; abs(n) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;的绝对值是：\u0026#34; \u0026lt;\u0026lt; abs(m) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;的绝对值是：\u0026#34; \u0026lt;\u0026lt; abs(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;的绝对值是：\u0026#34; \u0026lt;\u0026lt; abs(f) \u0026lt;\u0026lt; endl; return 0; } 输出结果：\n1 2 3 4 -5的绝对值是：5 10的绝对值是：10 -0.5的绝对值是：0.5 3.2的绝对值是：3.2 例子二，对象交换的模板函数示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; void Swap(T \u0026amp;x, T \u0026amp;y) { T temp = x; x = y; y = temp; } class MyDate { int year, month, day; public: MyDate() { year = 1970; month = 5; day = 04; } MyDate(int y, int m, int d): year(y), month(m), day(d) { } void print() { cout \u0026lt;\u0026lt; \u0026#34;y:\u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;; m:\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;; d:\u0026#34; \u0026lt;\u0026lt; day; } }; int main() { int n = 1, m = 2; cout \u0026lt;\u0026lt; \u0026#34;转换前: n=\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;; m=\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; Swap(n, m); cout \u0026lt;\u0026lt; \u0026#34;转换后: n=\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;; m=\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; double f = 1.2, g = 2.3; cout \u0026lt;\u0026lt; \u0026#34;转换前: f=\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;; g=\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; Swap\u0026lt;double\u0026gt;(f, g); cout \u0026lt;\u0026lt; \u0026#34;转换后: f=\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;; g=\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; MyDate d1, d2(2000, 1, 1); cout \u0026lt;\u0026lt; \u0026#34;转换前: d1=\u0026#34;; d1.print(); cout \u0026lt;\u0026lt; \u0026#34;; d2=\u0026#34;; d2.print(); cout \u0026lt;\u0026lt; endl; Swap\u0026lt;MyDate\u0026gt;(d1, d2); cout \u0026lt;\u0026lt; \u0026#34;转换后: d1=\u0026#34;; d1.print(); cout \u0026lt;\u0026lt; \u0026#34;; d2=\u0026#34;; d2.print(); cout \u0026lt;\u0026lt; endl; return 0; } 输出结果：\n1 2 3 4 5 6 转换前: n=1; m=2 转换后: n=2; m=1 转换前: f=1.2; g=2.3 转换后: f=2.3; g=1.2 转换前: d1=y:1970; m:5; d:4; d2=y:2000; m:1; d:1 转换后: d1=y:2000; m:1; d:1; d2=y:1970; m:5; d:4 Swap(double)(f, g)是显示实例化模板的写法，和Swap(f, g)结果一样。\n显示实例化的格式如下：\n1 模板名 \u0026lt;实际类型参数1, 实际类型参数2, ...\u0026gt; 例子三，对象排序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; int myCompare(const T \u0026amp;left, const T \u0026amp;right) { if (left \u0026lt; right) { return -1; } if (right \u0026lt; left) { return 1; } return 0; } template \u0026lt;typename T\u0026gt; void swap(T \u0026amp;x, T \u0026amp;y) { T temp = x; x = y; y = temp; } int main() { string strArr[10] = {\u0026#34;shang\u0026#34;, \u0026#34;xia\u0026#34;, \u0026#34;zuo\u0026#34;, \u0026#34;you\u0026#34;, \u0026#34;qian\u0026#34;, \u0026#34;hou\u0026#34;, \u0026#34;dong\u0026#34;, \u0026#34;xi\u0026#34;, \u0026#34;nan\u0026#34;, \u0026#34;bei\u0026#34;}; int j; string temp; for (int i = 1; i \u0026lt; 10; i++) { j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; myCompare\u0026lt;string\u0026gt;(strArr[j-1], strArr[j]) \u0026gt; 0) { swap(strArr[j], strArr[j-1]); j--; } } for (int i = 0; i \u0026lt; 10; i++) cout \u0026lt;\u0026lt; strArr[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // bei,dong,hou,nan,qian,shang,xi,xia,you,zuo, cout \u0026lt;\u0026lt; endl; return 0; } 三、函数或函数模板调用语句的匹配顺序 例子一，函数调用顺序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; void max(T a) { cout \u0026lt;\u0026lt; \u0026#34;Template 1\u0026#34; \u0026lt;\u0026lt; endl; } template \u0026lt;class T1, class T2\u0026gt; void max(T1 a, T2 b) { cout \u0026lt;\u0026lt; \u0026#34;Template 2\u0026#34; \u0026lt;\u0026lt; endl; } void max(double x, double y) { cout \u0026lt;\u0026lt; \u0026#34;Function max\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int i = 4, j = 5; max(1.2, 3.4); // Function max max(i, j); // 并没有调用到函数，为什么？ max(1.2, 3); // Template 2 return 0; } 例子二，重载函数模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; class MyDate { int year, month, day; public: MyDate() { year = 1970; month = 1; day = 1; } MyDate(int y, int m, int d): year(y), month(m), day(d) { } friend ostream \u0026amp;operator \u0026lt;\u0026lt;(ostream \u0026amp;os, MyDate \u0026amp;obj); }; ostream \u0026amp;operator \u0026lt;\u0026lt;(ostream \u0026amp;os, MyDate \u0026amp;obj) { os \u0026lt;\u0026lt; obj.year \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; obj.month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; obj.day; return os; } template \u0026lt;class T\u0026gt; void print(T x, T y) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } template \u0026lt;class T1, class T2\u0026gt; void print(T1 x, T2 y) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } int main() { int i = 4, j = 5; print(i, j); // 4,5 MyDate d1, d2(2024, 4, 10); print(d1, d2); // 1970/1/1,2024/4/10 print(i, d2); // 4,2024/4/10 return 0; } 第二节 类模板 一、类模板概念 跟函数模板一样，类也有模板。不展开赘述。\n格式如下：\n1 2 3 4 5 template \u0026lt;模板参数表\u0026gt; class 类模板名 { 类体定义 } 类模板的成员函数既可以在类体内定义，这样就是内联函数，也可以在体外定义，格式如下：\n1 2 3 4 5 template \u0026lt;模板参数表\u0026gt; 返回类型名 类模板名\u0026lt;模板参数标识符列表\u0026gt;::成员函数名(参数表) { 函数体 } 类模板声明本身并不是一个类，不能直接生成对象，因为类型参数是不确定的，必须先为模板参数指定“实参”，即模板要“实例化”后，才可以创建对象。格式如下：\n1 2 3 类模板名 \u0026lt;模板参数表\u0026gt; 对象名1, ..., 对象名n; // or 类模板名 \u0026lt;模板参数表\u0026gt; 对象名1(构造函数实参), ..., 对象名n(构造函数实参); 编译器由类模板生成类的过程称为类模板的实例化。由类模板实例化得到的类称为模板类。\n二、类模板示例 例子一，简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class Pair { private: T first; T second; public: Pair(T f, T s) : first(f), second(s) {} T getFirst() const { return first; } T getSecond() const { return second; } void display() const { cout \u0026lt;\u0026lt; \u0026#34;First: \u0026#34; \u0026lt;\u0026lt; first \u0026lt;\u0026lt; \u0026#34;, Second: \u0026#34; \u0026lt;\u0026lt; second \u0026lt;\u0026lt; endl; } }; int main() { Pair\u0026lt;int\u0026gt; intPair(10, 20); intPair.display(); // First: 10, Second: 20 Pair\u0026lt;double\u0026gt; doublePair(3.14, 6.28); doublePair.display(); // First: 3.14, Second: 6.28 Pair\u0026lt;char\u0026gt; charPair(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); charPair.display(); // First: a, Second: b return 0; } 例子二，使用普通参数的类模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;int size, typename T\u0026gt; class Test { public: T data; double buffer[size]; T getData(T v); double get(int index); }; template \u0026lt;int i, typename A\u0026gt; A Test\u0026lt;i, A\u0026gt;::getData(A v) { return v; } template \u0026lt;int x, typename y\u0026gt; double Test\u0026lt;x, y\u0026gt;::get(int j) { return buffer[j]; } int main() { Test\u0026lt;6, string\u0026gt; obj; int i; double arr[6] = {12.1, 23.2, 34.3, 45.4, 56.5, 67.6}; for (i = 0; i \u0026lt; 6; i++) { obj.buffer[i] = arr[i] - 10; } obj.data = \u0026#34;demo\u0026#34;; for (i = 0; i \u0026lt; 6; i++) { cout \u0026lt;\u0026lt; obj.get(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 2.1 13.2 24.3 35.4 46.5 57.6 } cout \u0026lt;\u0026lt; endl; return 0; } 例子三，在类模板中使用函数模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1, class T2\u0026gt; class Pair { public: T1 first; T2 second; Pair(T1 f, T2 s) : first(f), second(s) {} bool operator \u0026lt;(const Pair\u0026lt;T1, T2\u0026gt; \u0026amp;p) const; template \u0026lt;class T\u0026gt; void print(T x) const { cout \u0026lt;\u0026lt; \u0026#34;first: \u0026#34; \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026#34;; second: \u0026#34; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } }; template \u0026lt;class A1, class A2\u0026gt; bool Pair\u0026lt;A1, A2\u0026gt;::operator \u0026lt;(const Pair\u0026lt;A1, A2\u0026gt; \u0026amp;p) const { return first \u0026lt; p.first; } int main() { Pair\u0026lt;string, int\u0026gt; var1(\u0026#34;Tom\u0026#34;, 19); Pair\u0026lt;string, int\u0026gt; var2(\u0026#34;Jim\u0026#34;, 21); bool a = var1 \u0026lt; var2; if (a == false) { cout \u0026lt;\u0026lt; \u0026#34;Jim排在Tom前面\u0026#34; \u0026lt;\u0026lt; endl; } var1.print(var2); // first: Jim; second: 21 Pair\u0026lt;int, int\u0026gt; var3(20, 10); var1.print(var3); // first: 20; second: 10 Pair\u0026lt;string, string\u0026gt; var4(\u0026#34;word\u0026#34;, \u0026#34;单词\u0026#34;); var1.print(var4); // first: word; second: 单词 return 0; } 例子四，类模板中使用静态成员：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; class Test { public: static T k; static void increment() { k++; } Test() { k += 1; } Test(T num) { k += num; } }; template \u0026lt;typename T\u0026gt; T Test\u0026lt;T\u0026gt;::k = 0; // 静态成员变量的初始化 int main() { Test\u0026lt;int\u0026gt; a; cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a.k \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt; b(3.6); cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34; \u0026lt;\u0026lt; b.k \u0026lt;\u0026lt; endl; Test\u0026lt;int\u0026gt;::increment(); cout \u0026lt;\u0026lt; \u0026#34;int increment以后，k: \u0026#34; \u0026lt;\u0026lt; Test\u0026lt;int\u0026gt;::k \u0026lt;\u0026lt; endl; Test\u0026lt;double\u0026gt;::increment(); cout \u0026lt;\u0026lt; \u0026#34;double increment以后，k: \u0026#34; \u0026lt;\u0026lt; Test\u0026lt;double\u0026gt;::k \u0026lt;\u0026lt; endl; return 0; } 输出结果：\n1 2 3 4 a: 1 b: 3.6 int increment以后，k: 2 double increment以后，k: 4.6 三、类模板与继承 类之间允许继承，类模板同样也可以，分别是以下4种情况：\n普通类继承模板类。 类模板继承普通类。 类模板继承模板类。 类模板继承模板类。 例子一，普通类继承模板类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; class Base { public: T data; }; class Test :public Base\u0026lt;int\u0026gt; { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; } }; int main() { Test obj; obj.print(); return 0; } 例子二，类模板继承普通类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: int k; void print() { cout \u0026lt;\u0026lt; \u0026#34;Base::print(), k: \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; } }; template \u0026lt;typename T\u0026gt; class Test :public Base { T data; public: void set(T d) { data = d; } void print() { Base::print(); cout \u0026lt;\u0026lt; \u0026#34;Test::print(), data: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; } }; int main() { Test\u0026lt;string\u0026gt; obj; obj.set(\u0026#34;hello world\u0026#34;); obj.print(); return 0; } 输出结果：\n1 2 Base::print(), k: 0 Test::print(), data: hello world 例子三，类模板继承模板类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; class Base { public: T data1; Base() {} Base(T val): data1(val) { } void print() { cout \u0026lt;\u0026lt; \u0026#34;Base::print(), data1: \u0026#34; \u0026lt;\u0026lt; data1 \u0026lt;\u0026lt; endl; } }; template \u0026lt;class T1, class T2\u0026gt; class Test :public Base\u0026lt;T1\u0026gt; { public: T2 data2; Test() {} Test(T1 val1, T2 val2): Base\u0026lt;T1\u0026gt;(val1), data2(val2) { } void print() { Base\u0026lt;T1\u0026gt;::print(); cout \u0026lt;\u0026lt; \u0026#34;Test::print(), data2: \u0026#34; \u0026lt;\u0026lt; data2 \u0026lt;\u0026lt; endl; } }; int main() { Test\u0026lt;int, string\u0026gt; obj1(666, \u0026#34;hello\u0026#34;); obj1.print(); Test\u0026lt;int, double\u0026gt; obj2; obj2.print(); return 0; } 输出结果：\n1 2 3 4 Base::print(), data1: 666 Test::print(), data2: hello Base::print(), data1: 0 Test::print(), data2: 6.95313e-310 例子四，类模板继承模板类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; class Base { public: T data1; Base() {} Base(T val): data1(val) { } void print() { cout \u0026lt;\u0026lt; \u0026#34;Base::print(), data1: \u0026#34; \u0026lt;\u0026lt; data1 \u0026lt;\u0026lt; endl; } }; template \u0026lt;class T\u0026gt; class Test :public Base\u0026lt;int\u0026gt; { public: T data2; Test() {} Test(T val, int val2 = 123): Base\u0026lt;int\u0026gt;(val2), data2(val) { } void print() { Base\u0026lt;int\u0026gt;::print(); cout \u0026lt;\u0026lt; \u0026#34;Test::print(), data2: \u0026#34; \u0026lt;\u0026lt; data2 \u0026lt;\u0026lt; endl; } }; int main() { Test\u0026lt;int\u0026gt; obj1(666); obj1.print(); Test\u0026lt;string\u0026gt; obj2(\u0026#34;hello world\u0026#34;, 9527); obj2.print(); return 0; } 输出结果：\n1 2 3 4 Base::print(), data1: 123 Test::print(), data2: 666 Base::print(), data1: 9527 Test::print(), data2: hello world 考试重点 想啥呢？都是重点，不好好实操怎么可能学的会呢？笔试都是综合应用占比多，选择题20分，填空题15分，程序填空题20分，程序分析题30分，程序设计题15分，就问你想不想考过吧 （狗头）。\n","date":"2024-03-07T15:41:50+08:00","image":"https://ghjayce.github.io/asset/blog/pUUpVODdvSxxT4BxTflbMjAyNDAzMDhfMTU0NTM2.png","permalink":"/p/book/080901/04737/summary/","title":"04737《C++程序设计》概要笔记"},{"content":"目录 第一章 管理信息系统导论 P17 ~ 36（10页） 第二章 管理信息系统的基本知识 P37 ~ 59（12页） 第三章 系统开发方法概述 P61 ~ 78（9页） 第四章 总体规划 P79 ~ 96（9页） 第五章 系统分析 P97 ~ 123（14页） 第六章 系统设计 P125 ~ 156（16页） 第七章 系统实施 P157 ~ 172（8页） 第八章 运行管理 P173 ~ 191（10页） 第九章 系统开发综合实例 P193 ~ 209（9页） 考试重点 第一章 管理信息系统导论 1.1 管理信息系统的概念及其发展 1.1.3 管理信息系统的定义 管理信息系统的基本定义 管理信息系统是一个由人、机（计算机）组成。能管理信息的传递、收集、加工、存储、使用和维护的系统。\n作用：它能监测企业或组织的各种运行情况，利用过去的数据预测未来；从全局出发辅助决策； 目的：利用信息控制企业或组织的行为，帮助其实现长远的规划目标。 管理信息系统是一个一体化系统 管理信息系统是一个“一体化系统”或称“集成系统”。\n怎么做：在进行管理信息系统建设过程中应从总体出发、全面考虑。 好处：保证各种职能子系统（如会计、统计、人力资源、市场营销、后勤管理等）共享数据，减少数据的冗余。 目的：保证数据的兼容性和一致性。 一体化的两个含义：\n数据的一体化： 数据在物理存储上可以分布存放，但在逻辑上却由统一的部门、统一的人员集中管理。 不限制个别子系统拥有私有数据。 系统开发的一体化： 要按总体规划，分步实施的原则进行管理信息系统的建设。 1.2 管理信息系统的分类 本书主要分4类：\n核心业务 数据处理方式 管理应用层次 行业和业务职能 实际工作中可能更多或者综合起来，目的是通过分类的方式进一步理解管理信息系统的概念。\n1.2.1 按核心业务活动分类 分3类\n电子业务系统 电子政务系统 电子商务系统 电子业务系统 针对一个组织（多指企事业单位）内部的具体业务过程而建立，主要服务于这个组织的内部管理活动。\n例：\n人力资源管理系统 会计信息系统 企业资源计划系统 教务管理系统 学籍管理系统 科技管理系统 生产业务管理系统 铁路客票发售系统 电子政务系统 针对政府部门的政务管理活动和服务职能而建立。\n作用：促进政府部门管理手段的变革，超越时间、空间和部门分割的制约。 目的：全方位地向社会提供优质、规范、透明的服务。 政府职能：\n经济管理 市场监管 社会管理 公共服务 电子政务目的是将四大职能电子化、网络化，有4个突出特点：\n使政务工作更有效、跟精简。 更公开、更透明。 为企业和居民提供更好的服务。 重构政府、企业和居民之间的关系，比以前更加协调，更好的参与到政府的管理。 电子商务系统 针对商贸活动而建立，实现消费者网上购物、商户之间的网上交易和在线电子支付等活动。\n模式划分：\n企业对企业（Business-to-Business），简称B2B。 企业对消费者（Business-to-Customer），简称B2C。 消费者对消费者（Customer-to-Customer），简称C2C。 企业对政府（Business-to-Government），简称B2G。 例：\nB2C：网上书店、花店、各类手机品牌、汽车品牌 C2C：淘宝网 1.2.2 按数据处理方式分类 分2类\n操作型管理信息系统：一般是由面向具体的管理业务而建立的，功能比较简单，主要包括数据录入、修改、删除、打印、查找和简单的汇总计算等。 例：工资发放管理系统、人事档案管理系统、会计记账管理系统等。 分析型管理信息系统：通常基于操作型管理信息系统开发，面向需要进行趋势分析、预测等管理决策需求而建立。 例：财务分析系统（基于会计记账管理系统开发的） 在企业实际应用中，一个完整的管理信息系统包括操作型和分析型两类子系统。\n1.2.3 按管理应用层次分类 分3类\n事务型管理信息系统：主要服务于组织的基层管理者，目的是具体业务过程的自动化。操作型管理信息系统大多是事务型管理信息系统。 管理型管理信息系统：主要服务于组织的中层管理者，涉及多项业务的综合管理，目的是让中层管理人员了解和监视管理领域的运行情况。 战略型管理信息系统：主要服务于组织的高层管理者，目的是为战略计划的制订和调整提供辅助决策功能。数据来源前两个系统和企业外部。 1.2.4 按行业和业务职能分类 分法有很多，例如按行业或部门可以分为：\n铁路管理信息系统 林业管理信息系统 电力管理信息系统 港口管理信息系统 农业管理信息系统 房地产业管理信息系统 按业务职能可以分为：\n企业业务：销售、生产、采购、财务、统计、人力资源等。 铁路管理：铁路调度管理系统、客票预发售系统、危险品及安全管理系统等。 1.3 管理信息系统的结构 本书将管理信息系统的结构分为5类：\n概念结构 功能结构 管理职能结构 软硬件结构 网络计算结构 1.3.1 功能结构 任何一个管理信息系统均有明确的目标，并由若干具体功能组成。为了完成这个目标，各功能相互联系，构成了一个有机结合的整体，表现出系统的特征，这就是管理信息系统的功能结构。\n管理信息系统的功能结构反映了管理的业务职能。\n1.3.2 概念结构 如果对各个管理信息系统的功能结构进行抽象，会发现所有的管理信息系统均是由信息源、信息处理器、信息用户和信息管理者四大部件组成。\n四大部件主要作用：\n信息源：信息产生地。 信息处理器：担负信息的传输、加工、存储等任务。 信息用户：信息的最终使用者，他们应用信息进行管理决策。 信息管理者：负责信息系统的设计、实施、维护等工作。 1.3.3 管理职能结构 管理组织结构一般有3种：\n直线制 职能制 矩阵式 从2个角度进行分析。\n纵向视角 分层次，管理活动也可以划分为若干层次，不同层次所需的决策信息不同，具有金字塔结构，越往上越需要汇总性、全局性、非结构化的信息。\n一般分3层，对应建设的系统名称，以及所属类型。\n高，战略计划子系统，战略型。 中：管理控制子系统，管理型。 低（也称基层）：执行控制子系统，事务型管理信息系统。 系统主要任务：\n战略计划子系统：为企业战略计划的制订和调整提供辅助决策功能。 管理控制子系统：为企业各职能部门管理人员提供用于衡量企业效益、控制企业生产经营活动、制定企业资源分配方案等活动所需要的信息。 执行控制子系统：确保基层的生产经营活动正常、有效地进行。 横向视角 从横向来看一个组织，其管理活动是按职能排列的。\n比如制造类企业，其主要管理职能概括为：人、财、物、产、供、销等。\n也就是按职能划分管理子系统。\n综合视角 略。\n1.3.4 软硬件结构 硬件结构 软件结构 1.3.5 网络计算结构 客户服务器模式 浏览器服务器模式 1.4 管理信息系统的几种典型应用 1.4.1 MRP系统 第二章 管理信息系统的基本知识 2.1 管理的基本知识 2.1.2 组织结构 组织是保证管理目标实现的重要手段。了解管理的组织结构有助于分析和设计管理信息系统。\n分4种：\n直线制组织结构 职能制组织结构 矩阵式组织结构 事业部制组织结构 直线制组织结构 最早也最简单的组织。\n特点：是各级行政单位从上到下实行垂直领导，各级负责人对所属单位一切问题负责，是一种树状组织。 适用：任务明确，要求领导集中，控制严格的情况。 TODO 补图.jpg\n职能制组织结构 各级行政单位除主管负责人外，还设立了一些职能机构（财务部、采购部等），协助领导从事职能管理工作。\n优点：减少了最高领导者的负担。 缺点：容易造成办事效率低下，无人对整个任务或过程负责。 TODO 补图.jpg\n矩阵式组织结构 为了解决职能制组织结构的缺点，加强任务过程的负责制。\n特点：由两维组成，一维是直线组织，另一维是任务（如产品、项目、地区等）。 优点：加强了横向联系，具有较大机动性。 缺点：人员受双重领导，不易分清责任。 TODO 补图.jpg\n事业部制组织结构 由矩阵式组织引申而来，书上略，未赘述。\n2.2 信息的基本知识 2.2.2 信息的基本属性 信息的类型及其表现形式多种多样，千差万别，可分类为：\n按地位： 客观信息 主观信息 按作用大小： 有用信息 无用信息 干扰信息 按载体性质： 电子信息 光电信息 生物信息 按应用部门： 工业信息 农业信息 军事信息 政治信息 科技信息 文化信息 经济信息 市场信息 管理信息 它们都具有一些共同的基本属性：\n普遍性 事实性 层次性 可压缩性 扩散性 非消耗性 共享性 变换性 可转化性 扩散性 信息的本性，力图冲破保密的、非自然的约束，通过各种渠道和手段向四面八方传播。\n俗话说：\n没有不透风的墙。 坏事传千里。 2.2.4 管理信息与决策 管理信息与决策的关系 2个部分：\n决策需要信息支持，决策目的为了消除不确定性，决策过程是一个信息处理过程。 不同管理层次需要不同的信息。 管理层次和决策的关系： 高层：非结构化 中层：半结构化 低层（基层）：结构化 管理层次和信息的关系： 高层：战略信息，战略规划和某些全局性的问题处理，覆盖时间期限长。 中层：战术信息，时间期限短，如：市场预测、生产作业计划、物资采购计划等。 基层：作业信息，确保各项具体任务的完成，如：生产加工记录、物资出入库登记等。 信息要求 高层管理 中层管理 基层管理 信息来源 主要来自外部 以内部为主 主要来自内部 信息范围 较宽 较窄 较窄 概括性 概括 简单综合 具体 时间性 未来的 历史的 历史的 流通性 过去的 近期的 当前的 精度 较低 较高 高 发生频率 不常用 一般使用 经常使用 2.3 系统的基本知识 2.3.3 信息处理的生命周期 信息的生命周期分为5点：\n收集 传输 处理 存储 维护 2.3.4 系统的分解 系统分解的目的 系统通常由若干个子系统组成，子系统又可以有若干个孙系统。\n面对一个庞大而又复杂的系统，我们无法把系统所有元素之间的关系表达清楚，就需要将系统按一定的原则分解成若干个子系统。\n分解后的作用：其功能和结构的复杂程度都大大降低，降低了系统开发的复杂度。\n第三章 系统开发方法概述 3.2 管理信息系统的开发方法 3.2.2 结构化开发方法 目前最成熟、应用最广泛的管理信息系统开发方法之一。\n在20世纪70年代基于瀑布模型提出的。\n它是结构化分析Structured Analysis（SA）和结构化设计Structured Design（SD）的统称。\n结构化分析 基本思想概括为一句话：“自顶向下，由粗到细，逐步求精”。也有说“自顶向下，逐层分解”。\n基本手段：分解和抽象（解决复杂问题）。 分解：把大问题分解成若干个小问题，然后再分别解决。 抽象：抓住主要问题，忽略次要问题，优先解决主要问题。 结构化设计 分两步进行：总体设计和详细设计。\n特点是：\n相对独立、功能单一的模块结构。 块内联系大、块间联系小。 采用模块结构图的描述方式。 3.3 结构化方法的开发过程 3.3.2 各阶段主要内容 总体规划阶段工作有6点：\n对当前系统进行初步调查。 分析和确定系统目标。 分析子系统的组成以及基本功能。 拟定系统的实施方案。 进行系统的可行性研究。 编写可行性报告。 3.4 开发过程组织与管理方法 3.4.1 项目管理的主要内容 分为6点：\n任务划分 计划安排 经费管理 审计控制 风险管理 质量保证 审计控制的重要作用：对整个系统开发在预算范围内完成各项任务计划。\n3.4.2 项目管理组的组成 项目组长 一般称为项目负责人，整个项目的领导者，职责是保证整个开发项目的顺利进行。\n第四章 总体规划 4.1 总体规划的目的和步骤 4.1.2 总体规划的主要步骤 共6个步骤：\n需求初步调查 确定系统建设目标 初步确定子系统组成与基本功能 拟定系统实施方案 可行性分析 编制可行性分析报告 可行性分析 分4点：\n技术上。 经济上。 管理上的可行性。需要考虑3点： 新系统的必要性。 新系统运行后产生的影响。 当前系统的业务人员对新系统的适应能力。 开发环境的可行性。简单点说是企业能为新系统的开发建设提供一个长期的、良好的环境。影响因素有： 资金是否到位。 是否有骨干力量参加。 重点是企业领导意见是否一致。 4.2 企业系统规划法 用于管理信息系统总体规划的方法很多，常见有3种：\n关键成功因素法（Critical Success Factors, CSF）。 战略目标集转化法（Strategy Set Transformation, SST）。 企业系统规划法（Business System Planning, BSP），其应用最为广泛，具有系统性、简洁性等特点。 BSP实质上是一个把企业的战略转化成管理信息系统的战略的转化过程。\nBSP方法工作流程的核心部分：\n定义企业过程和数据类。 分析研究现行系统寻企业的支持。 研究管理部门对系统的要求。 确定新信息系统的体系结构。 确定新信息系统的实现优化顺序。 4.2.5 设计系统总体结构与开发顺序 子系统划分的基本原则 2个原则：\n子系统在功能上应有相对的独立性，通常子系统不应跨越两个或两个以上的企业过程。 子系统再数据上应有自身的完整性。一般一个数据类只能由一个子系统产生。 子系统的划分概括起来有3种：\n仅产生数据而不使用其他子系统数据的子系统。 既使用数据，也产生数据的子系统。 只使用数据而不产生数据的子系统。 第五章 系统分析 5.1 系统分析概述 5.1.1 系统分析的目的与困难 系统分析的任务 系统分析说明书的2个作用：\n用户与开发人员达成书面协议或合同的依据。 管理信息系统生命周期中的重要文档。 5.1.2 系统分析的逻辑与步骤 系统分析的思维逻辑 系统分析的主要步骤 4个：\n详细调查 业务流程分析 数据流程分析 编写系统分析说明书 5.2 详细调查 5.2.3 详细调查的方法与原则 详细调查的基本方法 4种：\n收集资料。好处是可以得到真实数据。 开调查会或个别访问。最有效的一种调查方法，让系统分析人员和用户直接交流。 书面调查。适合比较复杂的系统。 参加业务实践。是了解现行系统的最好方法。 详细调查的原则 6点：\n事先计划。 采访持关键信息的人。 自顶向下全面展开。 存在的不一定是合理的。 分工和协作相结合。 主动沟通的工作方式。 应注意的事项 4个注意原则：\n选择默契的语言。 倾听比表达更重要。 及时反映避免误解。 以学习的态度开展工作。 5.3 业务流程分析 5.3.1 业务流程的概念 业务流程的特点 目的性：流程的存在是为了完成将投入转化为产出的特定的任务。 逻辑性：组成流程的活动之间具有相互联系、相互作用的方式，这就构成了活动的逻辑关系。概括起来，分为串行、并行、反馈三种方式。 层次性：作为投入-产出系统的企业，它的流程复杂，具有层次性，可以由高至低一层一层地分解。 5.4 数据流程分析 5.4.4 数据字典与加工说明 数据字典 =：等价。 +：与。 [ | ]：或。 {}：重复。 ()：可选。 第六章 系统设计 6.3 系统详细设计 6.3.5 数据库设计 概念设计的方法 概念设计一般采用E-R图方法，绘制3要点：\n用长方形表示实体。 用椭圆形表示属性。 用菱形表示联系。 TODO ER图示例.png\n逻辑设计的方法 函数依赖于函数决定。 例：一个职工关系为（职工号，姓名，性别，年龄，职务），职工号用来标识每个员工，作为该关系的主键。 部分函数依赖。 传递函数依赖。 数据表设计范式与规范：\n第一范式First Normal Form，设一个关系为R，它的每个属性都是不可再分的，简称1NF。 第二范式Second Normal Form，设一个关系为R，它满足第一范式，R中不存在非主属性对主键的部分函数依赖，简称2NF。 第三范式Third Normal Form，设一个关系为R，它满足第二范式，R中不存在非主属性对主键的传递函数依赖，简称3NF。 6.3.6 安全控制设计 管理信息系统安全概述 保证计算机信息系统安全性的3个方面：\n计算机信息系统实体安全。 计算机信息系统的运行安全。 信息与数据安全。信息的安全性概括为信息的完整性、保密性和可用性。 完整性：信息必须按照其原型保存，不能被非法地篡改、破坏，也不能被偶然、无意地修改。 保密性：信息必须按照拥有者的要求保持一定的秘密性，防止信息在非授权的方式下被泄露。 可用性：在任何情况下，信息必须可以被拥有相应权限的人在权限范围内使用。 第七章 系统实施 7.2 系统测试 7.2.1 系统测试概述 系统测试的目的 测试的错误理解：\n测试是证明程序中不存在错误的过程。 测试的目的是要证明程序正确地执行了预期的功能。 程序测试的过程是使人们确信程序可完成预期要完成的工作过程。 测试是为了表明程序是正确的。 成功的测试是没有发现错误的测试。 测试的正确理解：为了发现程序中的错误而执行程序的过程。\n目的并不是证明程序是“好的”，而是通过测试从中发现尽可能多的错误。\n7.2.4 测试策略与原则 测试原则 共5个：\n确定预期输出结果。 应避免测试自己的程序。 进行破坏性测试。不仅要选用合理的输入数据进行测试，还应选出不合理的甚至错误的输入数据。 除了检查程序是否做了它应该做的工作，还应检查程序是否做了它不该做的事情。 应保留测试数据，以便程序修改后进行再测试。 第八章 运行管理 8.2 系统运行维护 8.2.2 系统维护的分类 分4类：\n改正性维护 适应性维护 完善性维护 预防性维护 在全部维护活动中一半以上是完善性维护。\n全部维护活动占比情况\n完善性维护50% ~ 60% 改正性维护17% ~ 21% 适应性维护18% ~ 25% 其他维护4% 考试重点 P数字表示知识点所在页码 以下是统计知识点在历史真题中各种题型曾经出现过的次数，仅供参考 X数字选择题 T数字填空题 M数字名词解释题 J数字简答题 第一章 管理信息系统导论 会计记账系统属于事务型管理信息系统。（P23; X1） 从管理信息系统的概念结构角度看，管理信息系统由信息源、信息管理者、信息用户和信息处理器四大部件组成。（P25; T1） 管理信息系统的功能结构反映了管理的业务职能。（P25; T1） 管理信息系统的网络计算模式可分为中央主机集中分时处理模式、文件服务器模式、客户机/服务器模式（C/S）和浏览器/服务器模式（B/S）。（P29; T1） ERP三个主要特征：顾客驱动、基于时间、面向整个供应链。四大元素：资金、货物、人员和信息。（P34; T1） 简要说明对管理信息系统的理解。（P21; J1） 答：管理信息系统是一个由人、机（计算机）组成的能进行管理信息的收集、传递、存储、加工、维护和使用的系统。它能监测企业或组织的各种运行情况，利用过去的数据预测未来；从全局出发辅助决策；利用信息控制企业或组织行为，帮助其实现长远的规划目标。 为什么要从”一体化“的角度构建管理信息系统？（P22; J1） 答：在进行管理信息系统建设过程中，应从总体出发，全面考虑，这样可以保证各种职能子系统共享数据，减少数据的冗余，保证数据的兼容性和一致性。 什么是MRP系统？它的基本内容是什么？（P31; J1） 答：MRP是一种以物料需求的计划与控制为主线的管理思想，基于此种管理方法形成的管理信息系统被称为MRP系统。基本内容是编制零件的生产计划和采购计划。 第二章 管理信息系统的基本知识 管理在于营造一种激励环境，使处于其中的所有工作人员努力工作，发挥群体的协同效应，以达到企业或组织的目标。（P39; T1） 在企业管理中，管理者对未来事件作出预测，以制定出行动方案，这属于管理的计划职能。（P40; T1） 一名管理者能有效地监督、管理其直接下属的人数，称为管理幅度。（P43; T1） 按照管理幅度的大小和管理层次的多少，管理的结构分为扁平结构和直式结构。（P43; T1） 为了达到有效管理，应尽可能地减少管理层次，这一过程称为管理扁平化。（P44; T1） 信息是经过加工的数据，是有一定含义，能减少不确定性、对决策或行为有现实或潜在价值的数据。（P45; T1） 俗语“坏事传千里”说的是信息的基本属性中的扩散性。（P46; X1） 信息识别是信息管理人员的职责。（P46; X1） 信息维护的主要目的是保证信息的准确性、及时性、安全性和保密性。（P50; T1） 管理信息系统为高层管理者提供的信息应尽可能为范围较宽的概括信息。（P52; X1） 如果一个系统的输出量对系统控制产生影响，则这样的系统称为闭环系统。（P54; T1） 闭环系统由五个部件组成：输入、处理、输出、控制和反馈。（P54; T1; M1） 开环系统由四个部件组成：输入、处理、输出和控制。（P54; ） 系统分解的主要目的是降低系统开发复杂度。（P55; X1） 系统的分解过程就是确定子系统边界的过程。（P55; T1） 按地理范围可以把各种网络划分为局域网和广域网两大类。（P56; T2） 闭环系统（P54; M1） 答：输出端和输入端之间存在反馈机制，一般包括输入、处理、输出、控制和反馈五个部件，系统控制单元通过比较系统行为和期望行为之间的偏差进行调解。 信息技术（P55; M1） 答：是有关信息的收集、识别、提取、变换、存储、处理、检索、检测、分析和利用等各种技术的总称。 计算机网络（P56; M2） 答：是利用通信设备和线路将地理位置不同、功能独立的两台或两台以上的计算机互联起来，以功能完善的网络软件实现资源共享和信息传递的系统。 第三章 系统开发方法概述 管理信息系统开发成败的决定性因素是企业领导是否重视。（P63; X1） 结构化分析的基本手段是分解和抽象。（P67; X1） 结构化设计的基本思想是将系统设计成相对独立、单一功能的模块组成的结构。（P67; T1） 在面向对象方法中，通常用来指代信息隐蔽技术的概念叫做封装。（P69; T1） 对象由标识、数据结构、操作集合和对外消息接口（MS）四部分组成。（P69; T2） 在面向对象方法中，对象是数据结构以及作用于此结构上的数据操作的封装体。（P69; T1） 在管理信息系统建设过程中，以新系统代替当前系统的过程通常称为系统切换。（P72; T1） 广义的项目管理包括系统开发期和系统维护期的管理。（P73; T1） 项目管理的质量保证分为三个阶段，即事前准备、过程监控、事后评审。（P74; T1） 质量保证（SQA）一般分为三个阶段，依次是事前准备、过程监控和事后评审。（P74; T1） 作为系统开发建设的生命线，系统开发的各个层次和阶段都要有相应的文档。（P77; T1） 造成系统开发困难的主要因素通常有哪些？（P64; J1） 答： 新系统对当前管理模式影响较大 管理信息系统的收益不易用货币形式直接反映 基础数据的准确性与完整性差 重视编程，轻视规划 采用增加开发人员的方式来加快进度 堆栈现象 简述原型化方法的原理。（P68; J1; X1） 答：原型化方法是一种确定用户需求的有效方法，它采用启发式的方法，引导用户逐渐加深对系统的理解，最终提出明确需求。在获得一组基本的用户需求后，快速地开发出新系统的一个原型。用户、开发者和其他有关人员在使用软件过程中加强通信和反馈，通过反复评价和反复修改原型系统，逐步确定各种需求的细节适应需求变化，从而最终提高新系统的质量。 简述面向对象方法中的消息与方法。（P69; J1） 答：消息由消息的标识、接受消息的对象、若干个变元组成；方法描述了对象执行操作的算法，定义了对象执行操作的机制。方法使对象具有了处理封装数据的功能，而消息则激活了这种功能并建立了对象之间通信的桥梁。 第四章 总体规划 管理信息系统总体规划方法：关键成功因素法CSF、战略目标集转化法SST、企业系统规划法BSP。（P85; X1） 管理可行性分析考虑点：新系统的必要性、新系统运行后产生的影响、业务人员对新系统的适应能力。（P85） 在对管理信息系统开发的可行性论证之后，编写的新系统开发的可行性报告，可称为总体规划报告。（P85; T1） 企业系统规划方法（BSP）实质上是一个把企业的战略转化成管理信息系统的战略的转化过程。（P86; T1） BSP活动的结果是得出信息系统体系结构及实施计划的描述性文档。（P86; T1） 作为BSP方法中最重要和关键的活动之一，定义企业过程是作出企业的过程和组织之间的关系矩阵。（P89; T1） 为了解当前的数据处理工作是如何支持企业的，需对目前的组织、企业过程、信息系统和数据文件进行仔细分析，发现不足和冗余之处。这个过程中，最关键的分析工具是矩阵（过程/组织矩阵）。（P89; T1） BSP方法的核心是定义企业过程。（P91; T1） 在BSP方法中划分子系统的过程本质上就是定义信息结构的过程。（P95; T2） 简述企业系统规划方法的工作流程的核心部分（P86; J2）。 答： 定义企业过程和数据类。 分析研究现行系统寻企业的支持。 研究管理部门对系统的要求。 确定新信息系统的体系结构。 确定新信息系统的实现优化顺序。 企业系统规划方法（P86; M1） 答：是一种对管理信息系统进行规划和设计的结构化方法，是一个把企业的战略转化成管理信息系统的战略的转化过程。它首先自上而下识别信息的目标，识别企业过程，识别数据，然后再自下而上设计信息系统，以支撑目标。 BSP方法中的数据类（P89; M1） 答：是指支持企业所必须的，在逻辑上相互联系的，并能组成相对独立的完整数据单位的那些数据部分。 信息系统总体结构（P90; M1） 答：信息系统总体结构是企业长期数据资源规划的一种图形表达方式，它是企业现在和将来信息系统开发和最终运行的系统所遵循的蓝图。 简述BSP方法中企业数据的识别方法。（P94; J1） 答： 企业实体法。企业的实体是指顾客、产品、材料及人员等企业中客观存在的东西，联系于每个实体的生命周期阶段就有各种数据，如事务型、计划型、统计型等。 企业过程法。利用以前识别的企业过程，分析每个过程利用的什么数据，产生什么数据，每个过程的输入和输出数据是什么。 UC矩阵（P95; M1） 答：是用来表达过程和数据两者之间的关系的矩阵。U表示过程对数据类的使用，C表示过程对数据类的产生。 第五章 系统分析 详细需求分析有两个重要方法，分别是业务流程分析和数据流程分析。（P99; T1） 系统分析的目的是将用户的需求及其解决方法确定下来。（P99; T1） 开发人员与用户单位签订协议和合同的依据是系统分析报告。（P100; X1） 系统分析工作是由系统分析人员与广大用户通过“理解”和“表达”来完成的。（P101; T1） 系统分析步骤：详细调查、业务流程分析、数据流程分析、编写系统分析说明书。（P102; X1） 数据流程调查的工作分为收集和分析两个步骤。（P105; T1） 为了解现行系统，最好的详细调查方法是参加业务实践。（P106; X1） 一般而言，组成流程的活动之间具有一定的逻辑关系，概括起来分为串行、并行、反馈三种方式。（P108; T1） BPR的协同工作、整体优化的思想集中体现在以流程的观点来分配工作，而不是以职能部门的设置来划分任务。（P110; T1） 数据流程分析用到三种工具，分别是分层的数据流图、数据字典和加工说明。（P111; T1） 数据字典符号，=等价、+与、[|]或，{}重复，()可选。（P119; X1） 一个好的加工说明至少需描述清楚数据来源、处理逻辑和数据去向。（P120; T2） 系统分析报告描述了新系统的逻辑模型，作为系统设计和实施的依据。（P122; T1） 系统分析报告一经确认，就成为具有约束力的指导性文件，成为下一阶段系统设计工作的依据和今后验收目标系统的检验标准。（P122; T1） 业务流程（P107; M1） 答：是指一组共同为顾客创造价值而又相互关联的活动。 业务流程重组（P110; M1） 答：是对企业的业务流程做根本性的思考和彻底重建，其目的是在成本、质量、服务和速度等方面取得显著的改善，使得企业能最大限度的适应以顾客、竞争、变化为特征的现代企业经营环境。 数据流（P112; M1） 答：是人们用以记录物流、事务流、资金流、人员流、机器设备流等各种流的抽象表达形式，通常伴随着上述各种流的出现而产生。 第六章 系统设计 系统设计分为总体设计和详细设计两个阶段。（P127; T1） 衡量系统可靠性的指标是平均维护时间和平均故障间隔时间。（P128; T2） 系统设计遵循一致性原则主要是为了子系统之间、多系统之间的联系与合作。（P128; X1） 模块间的调用可分为3类，即判断调用、循环调用和直接调用。（P131; T1） 将数据键盘输入、条码扫描器输入和扫描仪输入组合到一个模块中，此模块的内聚方式是逻辑内聚。（P132; X1） 从数据流图得到初始模块结构图的常用策略有两种，分别是以事务为中心的设计策略和以变换为中心的设计策略。（P133; T1） 将低层数据流图转换成模块结构图时，将输入模块放在左侧，变换模块放在中间，输出模块放在右侧。（P134; T1） 网络设计通常分为三步，分别是选择网络拓扑结构、安排网络上的设备布局和网络结点的权限设计。（P135; T1） 在系统详细设计中，用数字或字符来代表事物或属性的过程称为编码设计。（P137; T1） 编码设计的原则是唯一化、规律化、标准化以及可扩充且易修改。（P137; T1） 设一个关系为R，X和Y是它的两个属性集。若X函数决定Y，同时X的一个子集X\u0026rsquo;也能够函数决定Y，则称Y部分函数依赖于X。（P146; T1） 第二范式设一个关系为R，在满足第一范式的基础上，R中不存在非主属性对主键的部分函数依赖，简称2NF。（P148; X1） 数据未经授权不能进行改变的信息安全属性称为完整性。（P152; T1） 简述系统总体设计中的子系统划分方法。（P129; J1） 答：在总体设计中，子系统可以按照职能划分，按逻辑功能划分，按模块间通信划分，按业务处理顺序划分，按业务处理时间的关系划分。 模块结构图（P130; M1） 答：是模块组合的图形表示，由模块、调用、数据、控制和转接5种基本符号组成。 简述模块设计阶段的主要工作步骤。（P130; J1） 答：对各个子系统进行细化，确定每个子系统如何划分成多个模块，确定子系统之间、模块之间的数据交换和调用关系，并画出模块结构图，优化并改进模块结构的质量。 内容耦合（P132; M1） 答：两个模块不经过调用关系，彼此直接使用或修改对方的数据的耦合方式称为内容耦合。 功能内聚（P133; M1） 答：是指模块中各成分的联系是功能性的，即一个模块执行一个功能，且完成该功能所必须的全部成分都包含在模块中。 什么是编码？编码设计的原则有哪些？（P137; J1） 答：编码是用数字或字符来代表事物或属性的符号；编码设计的原则有：唯一化、规律化、标准化、可扩充且容易修改。 外关键字（P146; M1） 答：一个关系R1中的属性或属性组是另一个关系R2的主键，那么这个属性或属性组为R1的外关键字，简称外键。 第七章 系统实施 系统实施包括系统实现、系统测试和系统切换等活动。（P159; T1） 程序中的注释一般分为两类，分别是序言性注释和描述性注释。（P161; T1） 系统测试是为了发现程序中的错误而执行程序的过程。（P162; X1） 在一个开发项目组中，通常会安排专人负责阅读别人的代码，以发现代码中可能存在的问题并予以纠正，这种做法叫代码审查。（P162; T1） 程序设计中一般采用缩排法来写程序，把同一层次的语句行左端对齐，而下一层的语句则向右缩进若干空格，从形式上体现程序的逻辑结构和深度。（P162; T1） 代码审查是保证软件质量的一个重要环节，一般认为它属于单元测试的一种方法。（P162; T1） 测试者完全不考虑程序内部结构的特性，仅仅关心寻找程序未按规范运行的情况，这种测试方法称为黑盒测试法。（P164; T1） 为了加快测试速度，提高测试效率，人们一般按照“自底向上”的原则按模块测试、子系统测试、系统总体测试三个阶段进行系统测试工作。（P167; T1） 系统切换前的准备工作，可以从用户培训、数据准备、文档准备三个方面进行。（P169; T1） 在管理信息系统的各类用户中，对于操作管理员的培训是用户培训工作的重点。（P170; T1） 在常见的系统切换法中，分段切换是直接切换和平行切换这两种方式的结合。（P171; T1） 为保证平稳运行，一般比较大的系统采用平行切换或分段切换的方式较为适宜。（P171; T2） 一般比较大的系统采用分段切换的方式较为适宜，既能保证系统平稳运行，费用也不太大。 系统实现（P159; M1） 答：是指利用某种计算机语言，把系统设计的结果翻译成可为计算机理解、可执行的代码的过程，是指开发管理信息系统应用软件的过程，包括准备工作、编码、代码审查、缺陷跟踪与改错和调试等若干活动。 等价划分测试方法。（P164; M1） 答：把被测试的软件的所有可能的输入数据划分成若干个等价类，然后从每个等价类中只选取少量的、有代表性的一组测试数据来代替大量相类似的测试，把无限的随机测试变成有针对性的等价类测试，减少总的测试次数。 子系统测试（P168; M1） 答：是在模块测试的基础上进行的，它把经过测试的模块放在一起形成一个子系统来测试，主要测试各模块之间的协调和通信。 系统总体测试（P168; M1） 答：经过子系统测试，已经把一个模块装成若干子系统并经过充分测试，接着的任务是总调，也称为系统总体测试。 第八章 运行管理 当企业的信息化提高到战略层次后，出现了以CIO（首席信息官）为核心的企业信息化管理体制，成为企业信息化管理职能履行的基本保障。（P176; T1） 在信息系统交付前，一般要编写系统用户手册来规范信息系统运行的操作规程。（P179; T1） 硬件的维护包括定期保养性维护和突发性故障维修。（P180; T1） 在系统维护中，对数据及数据库的安全性、完整性以及并发性控制等维护工作一般由数据库管理员来负责。（P182; T1） 为了应付因介质、操作系统、软件和其它环境原因导致数据库文件严重损坏、系统运行瘫痪等系统灾难的发生，数据日常维护的主要工作一般包括数据备份和数据恢复。（P182; T1） 相对于全备份而言，增量备份只备份上一次备份后数据的改变量。（P183; T2） 将上一次备份后数据库中发生变化的数据复制到永久脱机存储介质中，这种备份方式称为增量备份。 将当前服务器数据库中的所有数据全部复制到永久脱机存储介质中，这种数据备份称为全量备份。（P183; T1） 有统计数据表明，在全部维护活动中占比最大的是完善性维护。（P184;） 新系统运行一段时间之后，应当由开发人员和用户共同进行新系统的全面评价。（P187; T1） 在系统维护工作中，为了避免改旧错出新错等现象的发生，修改程序代码后需要进行测试，直到确认和复审无错为止。（P187; T1） 系统维护的内容有哪些？（P180; J1） 答：硬件设备的维护、系统软件维护、应用软件系统维护、网络维护、数据维护和运行环境维护。 根据目的的不同，系统维护可分为哪些类别？（P184; J1） 答：改正性维护、适应性维护、完善性维护、预防性维护。 系统维护的组织机构一般由哪几类人员组成？（P184; J1） 答：维护主管、技术主管、系统软件硬件维护员、数据库管理员、应用软件维护员等。 简述系统维护的工作流程。（P185; J1） 答：系统维护可分为7个阶段，提出维护申请、技术评估、下达任务、制定详细计划、计划实施、组织验收、资料存档。 详细目录 第一章 管理信息系统导论 1.1 管理信息系统的概念及其发展 1.1.1 管理信息系统概念的起源 1.1.2 管理信息系统概念的演进 1.1.3 管理信息系统的定义 管理信息系统的基本定义 管理信息系统是一个人机系统 管理信息系统是一个一体化系统 1.2 管理信息系统的分类 1.2.1 按核心业务活动分类 电子业务系统 电子政务系统 电子商务系统 1.2.2 按数据处理方式分类 操作型管理信息系统 分析性管理信息系统 1.2.3 按管理应用层次分类 事务型管理信息系统 管理型管理信息系统 战略型管理信息系统 1.2.4 按行业和业务职能分类 1.3 管理信息系统的结构 1.3.1 功能结构 1.3.2 概念结构 1.3.3 管理职能结构 纵向视角 横向视角 综合视角 1.3.4 软硬件结构 硬件结构 软件结构 1.3.5 网络计算结构 客户服务器模式 浏览器服务器模式 1.4 管理信息系统的几种典型应用 1.4.1 MRP系统 MRP系统的产生与发展 MRP系统的逻辑流程 1.4.2 MRP Ⅱ 系统 MRP Ⅱ 系统的产生与发展 MRP Ⅱ 系统的逻辑流程 1.4.3 ERP系统 ERP系统的产生与发展 ERP系统的主要功能 第二章 管理信息系统的基本知识 2.1 管理的基本知识 2.1.1 管理的含义 管理的概念 管理与信息系统的关系 管理现代化 管理的基本职能 2.1.2 组织结构 直线制组织结构 职能制组织结构 矩阵式组织结构 2.1.3 管理部门的划分方法 2.1.4 管理幅度与层次 管理幅度 管理层次 管理的扁平化 2.1.5 管理层次与决策类型 结构化决策 半结构化决策 非结构化决策 2.2 信息的基本知识 2.2.1 信息与数据 2.2.2 信息的基本属性 普遍性 事实性 层次性 可压缩性 扩散性 非消耗性 共享性 变换性 可转化性 2.2.3 信息处理的生命周期 信息的收集 信息的传输 信息的处理 信息的存储 信息的维护 2.2.4 管理信息与决策 管理信息的分类和特性 管理信息与决策的关系 2.3 系统的基本知识 2.3.1 系统的概念 2.3.2 系统的分类 按复杂程度分类 按系统与环境的关系分类 按是否有反馈机制分类 按抽象程度分类 2.3.3 系统的属性 整体性 关联性 层次性 统一性 2.3.4 系统的分解 系统分解的目的 系统分解的原则 2.4 信息技术的基本知识 2.4.1 网络技术 计算机网络的概念 网络的分类 网络协议 网络拓扑结构 网络安全 2.4.2 数据库技术 数据库的概念 数据表的概念 数据库管理系统 结构化查询语言 2.4.3 计算机语言 机器语言 汇编语言 高级语言 第三章 系统开发方法概述 3.1 管理信息系统开发的基本问题 3.1.1 系统开发具备的条件 企业高层领导应重视和介入 企业业务人员要有积极性 企业要有一定的科学管理基础 要有一定的投资保证 3.1.2 系统开发前的准备工作 借鉴同类系统的开发经验 确定系统目标、开发策略和投资金额 收集和整理基础数据 3.1.3 系统开发的困难因素 新系统对当前管理模式影响较大 管理信息系统的效益不易用货币形式直接反映 基础数据的准确性与完整性差 重视编程，轻视规划 采用增加开发人员的方式来加快进度 堆栈现象 3.2 管理信息系统的开发方法 3.2.1 系统开发方法的产生背景 3.2.2 结构化开发方法 结构化分析 结构化设计 3.2.3 原型化开发方法 3.2.4 面向对象开发方法 3.3 结构化方法的开发过程 3.3.1 系统开发阶段划分 3.3.2 各阶段主要内容 总体规划阶段 系统分析 系统设计 系统实施 运行维护 系统评价 3.4 开发过程组织与管理方法 3.4.1 项目管理的主要内容 任务划分 计划安排 经费管理 审计控制 风险管理 质量保证 3.4.2 项目管理组的组成 项目组长 用户 系统分析员 硬件网络设计员 数据库管理员 系统设计员 程序员 3.4.3 文档的管理 文档要标准化和规范化 维护文档的一致性 维持文档的可追踪性 文档管理的制度化 第四章 总体规划 4.1 总体规划的目的和步骤 4.1.1 总体规划的目的 保证信息共享 协调子系统间的工作 使开发工作有序进行 4.1.2 总体规划的主要步骤 需求初步调查 新系统的目标 可行性分析 可行性分析报告 4.2 企业系统规划法 4.2.1 方法概述 4.2.2 工作流程 研究项目的确定 研究的准备活动 研究的开始阶段 定义企业过程 定义数据类 分析当前的系统支持 研究管理部门对系统的要求 提出判断和结论 设计信息系统总体结构 确定子系统开发的优先顺序 评价信息资源管理工作 制定建议书和开发计划 研究成果报告 4.2.3 定义企业过程 企业资源 资源的生命周期 企业过程定义的一般步骤 4.2.4 定义数据类 企业数据的4种类型 企业数据的识别方法 4.2.5 设计系统总体结构与开发顺序 子系统划分的基本原则 子系统划分的方法 子系统开发顺序 第五章 系统分析 5.1 系统分析概述 5.1.1 系统分析的目的与难点 系统分析的目的 系统分析的任务 系统分析阶段的工作要点 系统分析工作的难点与对策 5.1.2 系统分析的逻辑与步骤 5.2 详细调查 5.2.1 详细调查的目的和难点 5.2.2 详细调查的主要内容 组织结构的调查 业务流程的调查 数据流程调查 薄弱环节的调查 其他信息的调查 5.2.3 详细调查的方法与原则 详细调查的基本方法 详细调查的原则 应注意的事项 5.3 业务流程分析 5.3.1 业务流程的概念 流程的概念 业务流程的特点 业务流程的功能 5.3.2 业务流程分析的方法 业务流程分析的步骤 业务流程图 业务流程图画法举例：会计账务处理 5.3.3 业务流程重组 BPR的概念 BPR的基本特征 BPR的原则 5.4 数据流程分析 5.4.1 数据流程分析的概念 什么是数据流 为什么要进行数据流程分析 5.4.2 数据流程分析的步骤 5.4.3 数据流图的基本画法 数据流图的基本符号 绘制数据流图的指导原则 绘制方法 绘制数据流图应注意的事项 数据流图检查：正确性和可读性 5.4.4 数据字典与加工说明 数据字典 加工说明 5.5 新系统逻辑模型 新系统逻辑模型的任务 建立新系统的初步逻辑模型 对初步逻辑模型进行补充和完善 5.6 系统分析报告 系统分析报告的作用 系统分析报告的组成 相关问题 第六章 系统设计 6.1 系统设计概述 6.1.1 系统设计的任务 6.1.2 系统设计的原则 简单性 一致性和完整性 灵活和适应性 可靠性 安全性 经济性 6.2 系统总体结构设计 6.2.1 子系统的划分和确认 子系统划分的原则 子系统划分的方法 6.2.2 模块结构设计 模块结构图 模块结构的质量标准 模块结构图与框图、数据流图的区别 模块结构图推导策略：从数据流图得到初始模块结构图 模块结构图的改进 6.2.3 网络设计与设备配置方法 网络设计的主要步骤 设备选配的依据 网络设计举例 6.3 系统详细设计 6.3.1 编码设计 编码设计的原则 编码的种类 6.3.2 输出与输入设计 确定输出要求 输出方式 输入方式 输入校对方式 6.3.3 人机界面设计 人机界面的主要形式 系统输入人机界面实现的原则 6.3.4 处理过程设计 设计原则 设计工具 6.3.5 数据库设计 数据库设计的任务与步骤 概念设计的方法 逻辑设计的方法 6.3.6 安全控制设计 管理信息系统安全概述 安全设计需要考虑的具体内容 6.4 系统设计报告 引言 系统设计方案 第七章 系统实施 7.1 系统实现 7.1.1 系统实现概述 7.1.2 开发语言的选择 7.1.3 程序质量的评价 可靠性 规范性 可读性 可维护性 适应性 7.1.4 编程风格 程序的注释 程序的书写格式 变量名的选择 7.1.5 代码审查 7.2 系统测试 7.2.1 系统测试概述 系统测试的目的 测试的基本工作流程 7.2.2 黑盒测试法 基本原理 具体方法 7.2.3 白盒测试法 基本原理 具体方法 7.2.4 测试策略与原则 测试策略 测试原则 7.2.5 系统测试的步骤 模块测试 子系统测试 系统总体测试 7.3 系统切换 7.3.1 系统切换前的准备工作 用户培训 数据和文档准备 7.3.2 系统切换的方式 直接切换 平行切换 分段切换 第八章 运行管理 8.1 系统运行的管理组织 8.1.1 运行管理机构发展的历程 8.1.2 运行管理机构设置的原则 效率原则 精简原则 灵活性原则 因事设岗，因岗定编 8.1.3 运行管理机构的人员构成 8.1.4 运行管理体制 CIO的主要职能 CIO机制 8.1.5 运行管理制度 机房管理制度 系统维护制度 运行操作规程 运行记录制度 8.2 系统运行维护 8.2.1 系统维护的内容 硬件维护 系统软件维护 应用软件维护 网络维护 数据维护 运行环境维护 8.2.2 系统维护的分类 改正性维护 适应性维护 完善性维护 预防性维护 8.2.3 系统维护的步骤 8.2.4 系统的可维护性 可维护性的评价指标 提高可维护性的方法 8.3 系统评价 8.3.1 系统评价概述 新系统是否达到了预期的目标 新系统是否具有较好地适应性和安全性 新系统是否为企业带来了良好的间接效益 新系统是否为企业带来了良好的直接效益 8.3.2 系统的经济评价 显性效益 隐性效益 8.3.3 系统的技术评价 系统效率 系统可靠性 可扩展性 可移植性 8.3.4 系统评价报告 引言 评价内容 第九章 系统开发综合实例 9.1 系统开发实例一 9.1.1 系统开发背景 公司概况 新的管理问题 信息化总体规划 开发策略 9.1.2 业务流程分析 9.1.3 数据流程分析 数据流图 数据字典和加工说明 9.1.4 系统设计 9.1.5 系统开发总结 9.2 系统开发实例二 9.2.1 系统开发背景 9.2.2 业务流程分析 9.2.3 数据流程分析 数据流图 数据字典 9.2.4 系统设计 模块结构 详细设计 9.2.5 系统开发总结 ","date":"2024-03-06T11:00:20+08:00","image":"https://ghjayce.github.io/asset/blog/009YvB3LFELPlaoVaw6TMjAyNDAzMDZfMTQyNTE1.png","permalink":"/p/book/080901/04757/summary/","title":"04757《信息系统开发与管理》概要笔记"},{"content":"阅读说明 环境说明 php v8.2.8 hyperf/constants v3.1.0 前言 Hyperf 枚举类文档中，主要分为了两个部分：\n枚举，主要是通过错误码获取到错误内容的作用。 异常，则是对抛异常的使用带来了便利，仅传入错误码，就能从枚举类中获得错误内容。 本文主要分析枚举类获取错误内容的源码实现过程。\n代码示例 hyperf/constants的使用如下。\n枚举类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php declare(strict_types=1); namespace App\\Constants; use Hyperf\\Constants\\AbstractConstants; use Hyperf\\Constants\\Annotation\\Constants; #[Constants] class ErrorCode extends AbstractConstants { /** * @Message(\u0026#34;Server Error！\u0026#34;) */ const SERVER_ERROR = 500; /** * @Message(\u0026#34;系统参数错误\u0026#34;) */ const SYSTEM_INVALID = 700; } 错误内容通过注释的方式定义，与错误码紧挨着，这样的实现有两个好处：\n阅读方便，文件简洁。 书写便捷，省工作量。 为什么？看看传统的实现方式你就知道了。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php class ErrorCode { const SERVER_ERROR = 500; const PARAMS_INVALID = 1000; public static $messages = [ self::SERVER_ERROR =\u0026gt; \u0026#39;Server Error\u0026#39;, self::PARAMS_INVALID =\u0026gt; \u0026#39;参数非法\u0026#39; ]; } $message = ErrorCode::messages[ErrorCode::SERVER_ERROR] ?? \u0026#39;未知错误\u0026#39;; 当错误码定义足够多的情况下，就会显得臃肿和繁琐。\n（如果你选择把错误码拆到多个文件，每个文件内容不超过一个屏幕画面的话，当我没说😂）\n异常类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php declare(strict_types=1); namespace App\\Exception; use App\\Constants\\ErrorCode; use Hyperf\\Server\\Exception\\ServerException; use Throwable; class BusinessException extends ServerException { public function __construct(int $code = 0, string $message = null, Throwable $previous = null) { if (is_null($message)) { $message = ErrorCode::getMessage($code); } parent::__construct($message, $code, $previous); } } 抛异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php declare(strict_types=1); namespace App\\Controller; use App\\Constants\\ErrorCode; use App\\Exception\\BusinessException; class IndexController extends AbstractController { public function index() { throw new BusinessException(ErrorCode::SERVER_ERROR); } } 分析 根据使用方式，先来猜测一下。\n如果要获取类文件中的注释，那必定会用到反射类：ReflectionClass或者是ReflectionClassConstant，然后再通过正则取出想要的内容。\n疑问 KQ1：怎么获取到注释里的错误内容的？ KQ2：在什么时候进行获取的？ Q3：难道每次获取错误内容都要反射一次？那会对性能有影响啊？ Q4：都PHP8了为什么不用注解的写法？例如：#[Message(\u0026quot;Server Error！\u0026quot;)] 废话不多说，马上开始逐个分析问题。\n获取错误内容 先从获取错误内容的代码入手：\n1 ErrorCode::getMessage($code); 再看下枚举类，是继承了Hyperf\\Constants\\AbstractConstants的抽象类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; /** * @method static string getMessage(int|string $code, array $translate = null) */ abstract class AbstractConstants { use ConstantsTrait; } 用了一个Hyperf\\Constants\\ConstantsTrait的trait，继续点进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; use Hyperf\\Constants\\Exception\\ConstantsException; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\NotFoundExceptionInterface; /** * @method static string getMessage(int|string $code, array $translate = null) */ trait ConstantsTrait { use GetterTrait; /** * @throws ConstantsException * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public static function __callStatic(string $name, array $arguments): string|array { return static::getValue($name, $arguments); } } 是一个__callStatic魔术方法，再点进Hyperf\\Constants\\GetterTrait这个 trait。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;?php declare(strict_types=1); /** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://hyperf.wiki * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */ namespace Hyperf\\Constants; use Hyperf\\Constants\\Exception\\ConstantsException; use Hyperf\\Context\\ApplicationContext; use Hyperf\\Contract\\TranslatorInterface; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\NotFoundExceptionInterface; use function array_shift; use function is_array; use function sprintf; use function strtolower; use function substr; trait GetterTrait { /** * @throws ConstantsException * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public static function getValue(string $name, array $arguments): string|array { if (! str_starts_with($name, \u0026#39;get\u0026#39;)) { throw new ConstantsException(\u0026#34;The function {$name} is not defined!\u0026#34;); } if (empty($arguments)) { throw new ConstantsException(\u0026#39;The Code is required\u0026#39;); } $code = array_shift($arguments); $name = strtolower(substr($name, 3)); $message = ConstantsCollector::getValue(static::class, $code, $name); $result = self::translate($message, $arguments); // If the result of translate doesn\u0026#39;t exist, the result is equal with message, so we will skip it. if ($result \u0026amp;\u0026amp; $result !== $message) { return $result; } if (! empty($arguments)) { return sprintf($message, ...(array) $arguments[0]); } return $message; } /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ protected static function translate(string $key, array $arguments): array|string|null { if (! ApplicationContext::hasContainer() || ! ApplicationContext::getContainer()-\u0026gt;has(TranslatorInterface::class)) { return null; } $replace = array_shift($arguments) ?? []; if (! is_array($replace)) { return null; } $translator = ApplicationContext::getContainer()-\u0026gt;get(TranslatorInterface::class); return $translator-\u0026gt;trans($key, $replace); } } 到这里可以得知：ErrorCode::getMessage($code); 的调用，最终是Hyperf\\Constants\\GetterTrait::getValue() 在处理。\n第一感觉有点绕啊，跳来跳去最后才见到了庐山真面目。\n为什么要这样设计呢？那么多层trait，不如直接写一个getMessage方法方便？挖坑#1002。\n但是这样实现有一个好处，比如可以通过ErrorCode::getTest($code);获取到自定义注释的错误内容，这是文档中没有介绍到的，挖到一点宝藏用法，但是毕竟属于没公布的内容，在业务中使用还得谨慎一些。\n1 2 3 4 5 /** * @Message(\u0026#34;Server Error！\u0026#34;) * @Test(\u0026#34;服务错误\u0026#34;) */ const SERVER_ERROR = 500; 回到主线任务，从实现中可以看出，错误内容的获取关键代码是：\n1 $message = ConstantsCollector::getValue(static::class, $code, $name); 它是一个自定义的收集器，在Hyperf\\Constants\\ConfigProvider中可以看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; class ConfigProvider { public function __invoke(): array { return [ \u0026#39;annotations\u0026#39; =\u0026gt; [ \u0026#39;scan\u0026#39; =\u0026gt; [ \u0026#39;collectors\u0026#39; =\u0026gt; [ ConstantsCollector::class, ], ], ], ]; } } 进去Hyperf\\Constants\\ConstantsCollector：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; use Hyperf\\Di\\MetadataCollector; class ConstantsCollector extends MetadataCollector { protected static array $container = []; public static function getValue($className, $code, $key): string { return static::$container[$className][$code][$key] ?? \u0026#39;\u0026#39;; } } 错误内容是从一个数组类型的静态变量（这里称为容器）中获取的，并且容器中存储不止一个枚举类的数据。\nswoole静态变量的生命周期是多久？和传统PHP有什么区别？挖坑#1000。\n把容器的数据结构打印出来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 var_dump(ConstantsCollector::list()); [ \u0026#39;App\\Constants\\ErrorCode\u0026#39; =\u0026gt; [ 500 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;Server Error！\u0026#39;, \u0026#39;test\u0026#39; =\u0026gt; \u0026#39;服务错误\u0026#39;, ], 700 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;系统参数错误\u0026#39;, ], ], ]; 也就是ErrorCode::getMessage($code);获取错误内容实际是从Hyperf\\Constants\\ConstantsCollector::$container静态变量里取出来的。\nKQ2和Q3的问题回答了一半，那容器里的数据是怎么来的？也就是调用收集器的地方。\nhyperf注解和收集器的工作原理是怎样的？挖坑#1001。\n获取时机 在对hyperf的配置加载、注解和收集器的机制了解完以后（挖坑#1003），我们知道，hyperf会在启动的时候对annotations.scan.paths配置的目录进行扫描，配置结构如下。\n1 2 3 4 5 6 7 \u0026#39;scan\u0026#39; =\u0026gt; [ \u0026#39;paths\u0026#39; =\u0026gt; [ BASE_PATH . \u0026#39;/app\u0026#39;, BASE_PATH . \u0026#39;/src\u0026#39;, ], ... ] 然后会把所有后缀是.php的类文件，进行ReflectionClass反射处理。\n并通过getAttributes()逐个检查类文件中的class、method和properties是否存在注解，存在就会通过newInstance()实例化这个注解类，然后执行注解类中的collectClass() / collectProperty() / collectMethod()方法，最后会将所有collector给序列化serialize然后存放到./runtime/container/scan.cache中以便下次启动时加速。\n回到主线任务，也就是说，在启动的时候会扫描到枚举类文件，发现使用到了#[Constants]注解，对应Hyperf\\Constants\\Annotation\\Constants会被实例化，看下这个文件的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants\\Annotation; use Attribute; use Hyperf\\Constants\\AnnotationReader; use Hyperf\\Constants\\ConstantsCollector; use Hyperf\\Di\\Annotation\\AbstractAnnotation; use ReflectionClass; #[Attribute(Attribute::TARGET_CLASS)] class Constants extends AbstractAnnotation { public function collectClass(string $className): void { $reader = new AnnotationReader(); $ref = new ReflectionClass($className); $classConstants = $ref-\u0026gt;getReflectionConstants(); $data = $reader-\u0026gt;getAnnotations($classConstants); ConstantsCollector::set($className, $data); } } collectClass()就会被执行，来分析一下这段代码。\n这里的$className正是App\\Constants\\ErrorCode枚举类，可以看到用了ReflectionClass反射该文件来获取所有的常量。\n这里为什么不用Hyperf\\Di\\ReflectionManager::reflectClass复用的方式来获取反射呢？毕竟composer都已经依赖hyperf/di包了🤔。\n哈哈，找到了一个优化点，想提交PR的心正在蠢蠢欲动🤣。\n进去Hyperf\\Constants\\AnnotationReader::getAnnotations()方法得到了证实，代码太多我就不放出来，它是通过getDocComment()和正则拿到了注释中的错误内容。\n$data结构参考如下：\n1 2 3 4 5 6 7 500 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;Server Error！\u0026#39;, \u0026#39;test\u0026#39; =\u0026gt; \u0026#39;服务错误\u0026#39;, ], 700 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;系统参数错误\u0026#39;, ], 最后将数据存到了Hyperf\\Constants\\ConstantsCollector::container静态变量中，梳理完毕。\n整个过程简单点说就是，在hyperf启动时，枚举类文件会被扫描，由注解类将收集到的数据存放到收集器中，扫描逻辑将所有收集器的数据缓存到本地文件中，下次再启动时就不需要重复扫描，直接使用本地缓存文件。\n至此，KQ1、KQ2、Q3都得到了回答。\n等等，是不是还有Q4没有回答？\n嘿嘿，偷个懒，留个课后作业给你思考一下。\n总结 枚举类中的错误内容是通过ReflectionClass反射，对每个常量getReflectionConstants()的注释内容getDocComment()用正则的方式取出来。 ErrorCode::getMessage($code)实际是从Hyperf\\Constants\\ConstantsCollector::container取出错误内容，数据来源则是在hyperf启动的时候，由Hyperf\\Constants\\Annotation\\Constants注解将文件中所有常量的错误内容收集起来后，以文件类名为key，存放到container静态变量中，并且最后会将收集到的数据缓存到./runtime/container/scan.cache中，这样下次就不需要再重复这个收集过程。 ","date":"2024-02-26T10:01:00+08:00","image":"https://ghjayce.github.io/asset/blog/FhYnPBeIezDAGMZ0BQgUMjAyNDAzMDFfMTU0NzE4.jpeg","permalink":"/p/language/php/hyperf/hyperf-constants/","title":"hyperf constants实现机制"},{"content":"阅读说明 为了方便文章描述，文中词汇的含义、未提及的场景如下：\n内链图片：和站点同一个域名下的图片。 外链图片：和站点非同一个域名下的图片，通常以http开头的链接。 内联图片：文字和图片处于同一行。 图像组件：将图片处理成在页面中可以进行交互的组件。 图片交互效果：经过图像组件处理以后，在页面进行交互的效果。 文中的相对目录路径，如没有特殊说明，均以一个hugo项目为准，可以参考我的项目结构。 文字非常多，图片很少，大部分是干货和细节，请耐心阅读。\n太多字啦，让我直接看你的解决方案，它最好是改动小且不影响现有的功能。\n背景 在此之前使用了一段时间CaiJimmy/hugo-theme-stack的主题，发现它只支持内链图片生成图像组件，并不支持外链图片，意味着外链图片没有办法在页面内点击图片进行一些交互。\n比如我想放大某张外链图片，我得对着图片右键，然后在新的页面中打开，用浏览器的方式对这张图片进行放大，非常的不方便。\n虽然瑕不遮瑜，但在外链需求特别多，又不想使用内链方式（不想放在项目中增加项目的大小）的情况下还是会很抓狂，所以在早些时候，尝试寻找了一些解决办法，于是找到了这个讨论：引用于 cdn 的图片 没法生成图册吗？Discussion #659 · GitHub。\n看来不止我一个人有着同样的需求。\n不巧的是，作者没有直接给出具体的解决办法，只是提供了解决思路，对hugo模板语法、工作机制不熟的我看的是一头雾水，提问的老哥看起来好像是解决了问题，怎么不分享一下啊，好东西不能藏着啊喂。\n于是打算白嫖的发问一下，白嫖失败。\n那么就跟着作者的提示，着手捣鼓一下：\nlayouts/_default/_markup/render-image.html模板文件，hugo markdown渲染的钩子之一。 resource.GetRemote相关语法文档。 初步解决方案 就如我在讨论中提到的，我在layouts/_default/_markup/render-image.html钩子模板做了以下的修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{- $Permalink := .Destination | relURL | safeURL -}} {{- $image := \u0026#34;\u0026#34; -}} {{- if hasPrefix $Permalink \u0026#34;http\u0026#34; -}} {{- $image = resources.GetRemote $Permalink -}} {{- else -}} {{- $image = .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; (.Destination | safeURL)) -}} {{- end -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} ... 使用一段时间之后发现了以下的问题：\nQ1：外链的图片在启动服务(hugo server)的时候会将资源下载到resources/_gen/images目录下，然后观察渲染以后的img，链接的正是该目录下的图片，外链了个寂寞，还是会增加项目的大小 :(。 Q2：如果遇到图片下载超时，会出现服务启动不了的问题。 Q3：如果外链图片比较多，可能会导致启动服务缓慢。 这些问题的描述会有不恰当的地方，下面会有说明。\n因为影响还是比较大，还不如不改呢，所以我去除了这些改动，暂时放下了这个糟心的问题。\n再次捣鼓 正好最近有空，于是打算对hugo-theme-stack图库的实现研究一番，好好解决这个糟心的问题。\n并将研究过程、当中发现到的一些细节记录下来，写下这篇文章。\n研究 环境说明 hugo v0.113.0 hugo-theme-stack v3.21.0 图像库组件PhotoSwipe v4.1.3 分析 从头开始，要解决图像库支持外链图片，那么就要知道：\nhugo是怎么解析markdown中的image语法的？ 用的是哪个图像组件？怎么做到图片处理成组件的？在什么时候做了介入处理？ 在上文中我们知道，CaiJimmy/hugo-theme-stack主题中的layouts/_default/_markup/render-image.html对markdown渲染的img标签做了介入处理。\n为了确定使用的是哪个图像组件，看它渲染以后的img标签是怎样的，那就要做一个内链图片来观察下。\n梳理过程 img 处理成图像组件 通过Writing | Stack和Page bundles | Hugo得知内链图片和文章要放在同级目录。\n目录结构如下：\n1 2 3 4 5 6 7 8 content/ ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── image1.jpg │ │ ├── image2.jpg │ │ └── index.md | └── _index.md index.md内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- title: Test description: something date: 2023-12-07 slug: test image: image2.jpg --- ![img1](image1.jpg) ![img2](image2.jpg) External images: ![img3](https://cn.bing.com/th?id=OHR.CheetahDay_EN-CN5641048727_1920x1080.webp\u0026amp;qlt=50) ![img4](https://cn.bing.com/th?id=OHR.ManateeMama_EN-US7376333243_UHD.jpg\u0026amp;pid=hp\u0026amp;w=1920\u0026amp;h=1080\u0026amp;rs=1\u0026amp;c=4) 你会发现content1.md在页面上看不到生成的这篇文章。\n当你将my-post里面的index.md改成content2.md的时候，content1.md和content2.md生成的文章都能够在页面中看到了，为什么？ 而如果在my-post里新建一个_index.md，content1.md和index.md生成的文章也可以在页面中看到了，为什么？ 然后1和2中content2.md和index.md中的内链图片都失效了，为什么？ 这不是本文的重点，避免在这上面浪费时间，挖个坑，后续会写一篇文章专门介绍它。\n打开浏览器，我们看到内链图片和外链图片分别解析如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;div class=\u0026#34;gallery\u0026#34;\u0026gt; \u0026lt;figure class=\u0026#34;gallery-image\u0026#34; style=\u0026#34;flex-grow: 66; flex-basis: 160px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://xxxx/p/test/image1.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/p/test/image1.jpg\u0026#34; width=\u0026#34;667\u0026#34; height=\u0026#34;1000\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img1\u0026#34; class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;66\u0026#34; data-flex-basis=\u0026#34;160px\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;figcaption\u0026gt; img1 \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;figure class=\u0026#34;gallery-image\u0026#34; style=\u0026#34;flex-grow: 149; flex-basis: 359px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://xxxx/p/test/image2.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/p/test/image2.jpg\u0026#34; width=\u0026#34;1000\u0026#34; height=\u0026#34;667\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img2\u0026#34; class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;149\u0026#34; data-flex-basis=\u0026#34;359px\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;figcaption\u0026gt; img2 \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;img src=\u0026#34;https://cn.bing.com/th?id=OHR.CheetahDay_EN-CN5641048727_1920x1080.webp\u0026amp;amp;qlt=50\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img3\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://cn.bing.com/th?id=OHR.ManateeMama_EN-US7376333243_UHD.jpg\u0026amp;amp;pid=hp\u0026amp;amp;w=1920\u0026amp;amp;h=1080\u0026amp;amp;rs=1\u0026amp;amp;c=4\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img4\u0026#34;\u0026gt; 通过在项目中搜索gallery-image，找到了themes/hugo-theme-stack/assets/ts/gallery.ts，一个TypeScript文件，从里面的代码看出使用的是PhotoSwipe图像组件。\n接着就是createGallery函数，看了下里面的代码的作用，猜测90%的可能性就是这里将img图片处理成图像组件的，也就是上面的HTML结构。\n处理时机 继续，是constructor(...)里面调用了这个函数，PHPer表示很熟悉，是一个构造函数。\n继续往上找，是themes/hugo-theme-stack/assets/ts/main.ts的init()方法中调用了上面的构造函数，在底部看到了window.addEventListener('load')调用了init()，这就是将图片处理成图像组件的时机。\n紧接着找到了themes/hugo-theme-stack/layouts/partials/footer/components/script.html，这里引入了main.ts，结合了页面渲染以后的结构进行比对，实锤了。\npartials是hugo的模板结构目录，相关文档。\n至此，猜测得到了证实，从markdown到img再到PhotoSwipe图像组件的实现过程，梳理完毕。\n解决 分析 render-image.html 模板语法、变量和函数代表的含义？ 做了哪些事情？ 源文件 以下是v3.21.0，layouts/_default/_markup/render-image.html的源码内容，贴上来方便查看。\n源文件仓库在这。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 {{- $image := .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; (.Destination | safeURL)) -}} {{- $Permalink := .Destination | relURL | safeURL -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} {{/* SVG and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryImage := false -}} {{- if $image -}} {{- $notSVG := ne (path.Ext .Destination) \u0026#34;.svg\u0026#34; -}} {{- $Permalink = $image.RelPermalink -}} {{- if $notSVG -}} {{- $Width = $image.Width -}} {{- $Height = $image.Height -}} {{- $galleryImage = true -}} {{- if (default true .Page.Site.Params.imageProcessing.content.enabled) -}} {{- $small := $image.Resize `480x` -}} {{- $big := $image.Resize `1024x` -}} {{- $Srcset = printf `%s 480w, %s 1024w` $small.RelPermalink $big.RelPermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $Permalink }}\u0026#34; {{ with $Width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryImage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.Width 100) $image.Height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.Width 240) $image.Height }}px\u0026#34; {{ end }} \u0026gt; 语法 {{- -}}和{{ }}的写法有什么不同？ 以if为例 {{- if ... -}}：在该语法中，横杠 - 的作用是去除 if 语句前后的空白字符（包括换行符、空格等），以保持输出结果更加紧凑。 {{ if ... }}：在标准的 if 语句语法中，并没有 - 符号。这意味着在渲染过程中，会保留 if 语句前后的空白字符。 .Page.Resources.GetMatch有什么用？ .Page.Resources 是返回页面资源集合。 resource.GetMatch 简单点说就是寻找某个匹配规则的资源文件。 .Destination 获取[](xxx)中的xxx链接。 | 管道操作符。 safeURL 将字符串处理成安全的URL字符串。 relURL 返回相对URL，例如http://xxx.com/p/test/image1.jpg得到/p/test/image1.jpg。 .PlainText 获取[](xxx \u0026quot;text\u0026quot;)中的text。 safeHTML 将字符串处理成安全的HTML字符串。 ne 比较两个值是否相等。 path.Ext 获取后缀，例如/p/test/image1.jpg得到image1.jpg。 .Page.Site.Params.imageProcessing.content.enabled获取hugo.xxx中的配置项，.Page.Site.Params。 default 第二个参数未设置时，使用第一个参数。 with 表达式为true时进入代码块，可以使用.代替表达式。 div 将一个数字除以一个或多个数字。 mul 将多个数字进行相乘返回积。 作用 结合以上，render-image.html主要做了以下几件事：\nE1：从页面资源集合中找到名称一致的图片。 E2：如果hugo.yaml文件中imageProcessing.content.enabled的配置开启了，Resize会对这张图片进行裁剪，裁出480宽、1024宽的两张图片并放到了resources/_gen/images/post/your_post_slug_name/目录下。 E3：$galleryImage是能否生成图像库组件的关键，它为img添加了关键的属性。 这里需要解释和纠正一下初步解决方案中，我对Q1的描述：\nE2回答了为什么resources/_gen/images/目录下会有图片的原因。 hugo server启动的时候因为resources.GetRemote的关系，它会去访问这张图片，而且在首次访问成功后会对这个图片进行缓存（但至于缓存在哪里，我也想知道，如果你知道的话请告诉我），因为在首次之后再执行hugo server会非常快，得到证实。 很抱歉我在早期的解决反馈中做了一些过于草率的结论。 解决方案 在原基础上支持 效果 先来看效果，经过我几天简单测试和使用下来，在文章内使用内链图片和外链图片，均能够生成图像库组件的交互效果。\n我的改动 我在源文件的基础上，增加了resources.GetRemote获取外链图片的部分，并且在hugo.yaml中增加了一个params.render.image.externalLink.enabled开关进行控制，是否启用外链图片的逻辑。\n1、layouts/_default/_markup/render-image.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 {{- $Permalink := .Destination | safeURL -}} {{- $image := \u0026#34;\u0026#34; -}} {{- if and (hasPrefix $Permalink \u0026#34;http\u0026#34;) (default false .Page.Site.Params.render.image.externalLink.enabled) -}} {{- with resources.GetRemote $Permalink -}} {{- with .Err -}} {{- $warnMsg := printf \u0026#34;%s\u0026#34; $Permalink -}} {{- warnf \u0026#34;%s.\\nPlease check the link: %s\\n\u0026#34; . $warnMsg -}} {{- else -}} {{- $image = . -}} {{- end -}} {{- else -}} {{- warnf \u0026#34;Unable to get remote resource %q\u0026#34; $Permalink -}} {{- end -}} {{- else -}} {{- $image = .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; $Permalink) -}} {{- if $image -}} {{- $Permalink = $image.RelPermalink -}} {{- end -}} {{- end -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} {{/* SVG and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryImage := false -}} {{- if $image -}} {{- $notSVG := ne (path.Ext .Destination) \u0026#34;.svg\u0026#34; -}} {{- if $notSVG -}} {{- $Width = $image.Width -}} {{- $Height = $image.Height -}} {{- $galleryImage = true -}} {{- if (default true .Page.Site.Params.imageProcessing.content.enabled) -}} {{- $small := $image.Resize `480x` -}} {{- $big := $image.Resize `1024x` -}} {{- $Srcset = printf `%s 480w, %s 1024w` $small.RelPermalink $big.RelPermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $Permalink }}\u0026#34; {{ with $Width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryImage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.Width 100) $image.Height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.Width 240) $image.Height }}px\u0026#34; {{ end }} \u0026gt; 2、hugo.yaml 以下只显示改动的地方\n1 2 3 4 5 6 7 8 params: imageProcessing: content: enabled: false render: image: externalLink: enabled: true 发现的问题 1、问题NQ1：\n如果你发现图片并没有生成组件，可以检查下markdown语法里图片是不是完全独占一行的，如果不是，把它改成独占一行再去页面查看，出来了对不对。\n这是因为themes/hugo-theme-stack/assets/ts/gallery.ts中createGallery函数里有这么一段代码：\n1 2 let isNewLineImage = paragraph.classList.contains(\u0026#39;no-text\u0026#39;); if (!isNewLineImage) continue; 结合注释和它解析之后的HTML结构得知，它不支持内链图片生成图像组件（无论是内链图片还是外链图片），因为这会影响到内联图片的效果。\n这个问题在我改动之前就已经存在了，毕竟解析之后的结构和内联图片效果肯定是冲突的，很遗憾内联图片不支持图像组件的交互效果。\n2、问题NQ2：\n如果外链图片比较多的情况下，hugo server启动的时候确实会有时间性能的损耗，毕竟它要对每一张图片都进行访问。\n如果你的外链图片访问足够快的话，不存在任何问题。\n如果你像我一样外链图片访问可能会存在缓慢的情况下，那么在启动的时候可能会遇到超时的问题，导致启动失败，错误内容如下：\n1 ERROR 2023/12/05 21:17:31 render of \u0026#34;page\u0026#34; failed: \u0026#34;/project/themes/hugo-theme-stack/layouts/_default/baseof.html:4:12\u0026#34;: execute of template failed: template: _default/single.html:4:12: executing \u0026#34;_default/single.html\u0026#34; at \u0026lt;partial \u0026#34;head/head.html\u0026#34; .\u0026gt;: error calling partial: partial \u0026#34;head/head.html\u0026#34; timed out after 30s. This is most likely due to infinite recursion. If this is just a slow template, you can try to increase the \u0026#39;timeout\u0026#39; config setting. 有三种解决办法：\n解决掉外链图片访问慢的问题。 在平常写文章的时候，把params.render.image.externalLink.enabled关闭，没错外链图片没有交互效果了，但你只是想写文章而已，写完以后可以再打开。 不需要解决，大可以挑一个网络顺畅的时刻去做这件事，之后再启动时它会使用缓存，启动会很快，也就首次成功启动会受影响而已。 总结一下：\nNQ1：内联图片不支持图片交互效果，这在我改动之前就已经存在的问题。 NQ2：hugo server首次启动时会有影响，但外链图片访问足够快的情况下，不成问题，唯一需要处理的是外链图片超时的问题，解决方案如下： 解决掉图片访问缓慢的问题。 平时写文章不用时可以关闭，需要用时再打开。 挑网络顺畅的时候完成首次启动，之后的启动都会走缓存，启动会非常快。 更换组件 这个我就不展开了，因为解决方案一已经能够满足我的需求了，除非你想内联图片也需要图片交互效果，并且能够彻底解决掉启动缓慢的问题。\n留到下次有这个需求时我再回来填坑。\n届时我将会采用fengyuanchen/viewerjs的组件。\n致谢 能看完这篇文章很不容易，为你的耐心鼓掌。\n","date":"2023-12-05T11:45:25+08:00","image":"https://ghjayce.github.io/asset/blog/z4EOqI2zCdlD5ce5EawUMjAyNDAyMjVfMTU1MjIy.png","permalink":"/p/static-site-generator/hugo/hugo-theme-stack-gallery-study/","title":"Hugo Theme Stack图库是怎么工作的？怎样才能支持外链图片？"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 下面是我从历年试题和书本中整理出来的重点。Enjoy it!\n如果这篇文章对你有帮助，也请你将这篇文章分享给有需要的人。\n第一章 概论 数据结构是计算机组织数据和存储数据的方式。 数据结构是指一组相互之间存在一种或多种特定关系的数据的组织方式和它们在计算机内的存储方式，以及定义在该组数据上的一组操作。 1976年瑞士计算机科学家尼克劳斯·维尔特（Niklaus Wirth）曾提出一个著名的公式：算法 + 数据结构 = 程序。 数据由若干个数据元素组成，数据元素由若干个数据项组成。 逻辑结构、存储结构、运算\n数据的逻辑结构是指数据元素之间的逻辑关系。逻辑关系是指数据元素之间的关联方式或邻接关系。 四类基本的逻辑结构：集合、线性结构、树形结构、图结构。 集合结点之间没有邻接关系；线性结构结点之间一对一的关系；树形结构结点之间一对多的关系；图结构结点之间多对多的关系。 与数据元素本身的形式、内容、相对位置、个数无关的是数据的逻辑结构。 数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。 存储结构一般有四种形式：顺序存储、链式存储、索引存储、散列存储。 运算是指在某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象。 运算的实现是指该运算的算法；算法指的是求解给定问题所需的处理步骤及其执行顺序。 时间复杂度、空间复杂度\n算法时间复杂度指的是算法在给定输入下的计算量。 算法的空间复杂度指的是算法中除了输入数据占用的存储空间之外所需的附加存储空间的大小，即所需的存储量。 在估算算法空间复杂度时，一般只需要分析辅助变量所占用的空间。 常数阶 $O(1)$，对数阶 $O(log_{2}n)$，线性阶 $O(n)$，线性对数阶 $O(nlog_{2}n)$，多项式阶有：平方阶 $O(n^2)$、立方阶 $O(n^3)$、K次方阶 $O(n^k)$，指数阶 $O(2^n)$。 第二章 线性表 顺序表\n顺序表插入新元素，需要移动元素的个数为 $n-i+1$（i为下标从1开始就需要+1，否则不需要）。 顺序表删除元素，需要移动元素的个数为 $n-i$（i为下标，从1开始）。 顺序表插入算法的平均移动次数约为 $\\frac{n}{2}$，算法时间复杂度为 $O(n)$。 顺序表删除算法的平均移动次数约为 $\\frac{n-1}{2}$（下标从0开始），算法时间复杂度为 $O(n)$。 单链表和双向循环链表插入操作顺序不可以颠倒。 双向循环链表删除操作顺序可以颠倒。 用顺序存储实现的线性表称为顺序表，一般使用数组来表示。 链表\n在单链表中，指针p所指的结点为最后一个结点的条件是p-\u0026gt;next == NULL。 第三章 栈、队列和数组 栈和队列可看作是特殊的线性表，运算受限的线性表。 函数的嵌套调用和程序递归的处理都是用栈来实现的。操作系统中进程调度、网络管理中的打印服务等都是用队列来实现的。 术语： 进栈：指插入运算。出栈：指删除运算。栈顶：允许进栈和出栈的一端。栈底：栈顶的另一端。 空栈：不含任何数据元素的栈。栈顶元素：处于栈顶位置的数据元素。 上溢：栈的容量已经满了，此时再进行进栈就会发生上溢。下溢：空栈做出栈就会产生下溢，因为栈中没有任何数据元素。 栈、双栈的运算\n顺序栈使用数组实现，栈顶top默认为下标0，判断栈空的核心stack-\u0026gt;top == 0，判断栈满的核心stack-\u0026gt;top == maxSize -1，进栈操作的核心stack-\u0026gt;top++; stack-\u0026gt;data[stack-\u0026gt;top] = x;，出栈操作的核心stack-\u0026gt;top--;。 双栈判断上溢的条件为：$top+1=top2$。 队列的基本概念\n栈是后进先出（Last In First Out），队列是先进先出（First In First out）。 入队列：在队列尾部进行插入运算；出队列：在队列首部进行删除运算。 链队列是一个带有头结点的单链表组成，队列首部的指针指向头结点，头指针指向首结点，队列尾部的指针指向尾结点，队列空的时候，队列首部和尾部的指针均指向头结点。 队列、循环队列的运算\n顺序队列入队列操作的核心SQ.rear = SQ.rear + 1; SQ.data[SQ.rear] = x;，出队列操作的核心SQ.front = SQ.front + 1。 循环队列解决了假溢出问题，队首和队尾都指向下标0的位置，少使用一个元素空间以解决无法区分空和满的情况。 循环队列入队列操作的核心CQ.rear = (CQ.rear + 1) % maxSize; CQ.data[CQ.rear] = x;，出队列操作的核心CQ.front = (CQ.front + 1) % maxSize;，队列满的条件(CQ.rear + 1) % maxSize == CQ.front;，队列空的条件CQ.rear == CQ.front;。 数组、矩阵\n计算数组元素的存储地址公式 $(n * i + j) \\times k$，其中m是行数量，n是列数量，i是在m行的下标，j是在n列的下标，k是每个元素占用的存储大小。 可将 $n^2$ 个元素压缩存储到含有 $\\frac{n(n + 1)}{2}$ 个元素的一维数组中。 假设m行n列的矩阵有t个非零元素，当$t\u0026laquo;m*n$时，则称矩阵为稀疏矩阵；三元组表示法：((i, j, v), (i, j, v), ...)，其中i是行，j是列，v是非零元素的值。 第四章 树和二叉树 术语： 结点的度：某一个结点有多少个直接孩子。树的度：结点的度的最大值，也就是所有结点里直接孩子最多的那个。 结点的层次：把一棵树比作一个层级金字塔，从根结点为1，每下一层+1，数到结点所在的层级。树的高度/深度：结点的层次的最大值，也就是树一共有多少层。 二叉树的基本概念\n一棵树的结点个数最少为0；二叉树第 i（i≥1）层上至多有 $2^{i-1}$ 个结点；深度为 k（k≥1）的二叉树至多有 $2^{k}-1$ 个结点。 对任何一棵二叉树，若度数为0的结点个数为$n_0$，度数为2的结点个数为$n_2$，则 $n_0=n_2+1$。 含有n个结点的完全二叉树的深度为 $⌊log_2n⌋+1$。 对于完全二叉树，根结点为1对结点进行编号，$i\u0026gt;1$ 时（i是指被编号的那个结点），结点双亲的编号为 $⌊\\frac{i}{2}⌋$。 二叉树不是完全二叉树，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 二叉树的先序遍历次序为根左右，中序遍历次序为左根右，后序遍历次序为左右根，层次遍历次序为每层从左往右。 存储结构\n具有n个结点的二叉树（链表结构）中，有 $2n$ 个指针域，其中只有 $n-1$ 个用来指向结点的左、右孩子，其余的 $n + 1$ 个指针域为NULL。 树的存储结构分别有：孩子链表表示法、孩子兄弟链表表示法、双亲表示法。孩子兄弟链表的结构形式与二叉链表完全相同。 树和二叉树\n树转换成二叉树： 加线，所有兄弟结点之间加一条线，彼此连接起来。 抹线，除了结点的第一个左孩子，其他孩子与结点的连线全部抹掉。 旋转，以根节点为轴心，对树进行顺时针的适当旋转。 森林转换成二叉树： 将森林中的每棵树转换成二叉树。 加线，转换以后的二叉树，从第二棵二叉树开始，将其根节点作为前一棵二叉树根结点的右子树，以此类推。 二叉树转换成森林： 抹线，断开根结点与右孩子的连线，此时得到两棵二叉树。 抹线再加线，二叉树根节点的左子树的右子树们均断开连接，改成均与根节点之间连接，如果根节点有右子树，重复步骤1的操作。 剩下的二叉树重复按以上步骤进行处理。 判断树和哈夫曼树\n一棵判定树描述了一种分类方法；用于描述分类过程的二叉树称为判定树。 有n个叶子结点的哈夫曼树，其结点的总数为 $2n-1$。 第五章 图 术语： 顶点：即图中的圆圈。边：即图中圆圈之间的连线，也称为顶点的偶对。权：即连线旁边的数值，也称为边的权。 带权图：每条边都带有权的图。有向图：顶点的偶对是有序的。无向图：顶点的偶对是无序的。 弧：有向图的边又称为弧。弧头：表示弧的终点，即弧有箭头的一端。弧尾：表示弧的始点/起点。 有向完全图：任何两个顶点之间都有弧的有向图。无向完全图：任何两个顶点之间都有边的无向图。 顶点的度：与该顶点相关联的边的数目。 入度：把以顶点v为终点的弧的数目称为v的入度，记为ID(v)。 出度：把以顶点v为始点的弧的数目称为v的出度，记为OD(v)。 路径：从一个顶点x到另一个顶点y之间的路线。路径长度：路径上边/弧的数目。 简单路径：序列中顶点不重复出现的路径。回路：第一个顶点和最后一个顶点相同的路径，也称为环。简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。 连通：顶点x到顶点y有路径，则称顶点x和顶点y是连通的。 连通图：图中任意两个顶点都是连通的。连通分量：无向图中的极大（最大）连通子图。 强连通相关术语含义与连通一样，只是强连通用于描述有向图，不做赘述。 有序偶对用尖括号\u0026lt;\u0026gt;括起来，无序偶对用圆括号()括起来。 无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。 一个具有n个顶点的有向完全图的弧的数量为：$P_{n}^{2}=n(n-1)$；一个具有n个顶点的无向完全图的边的数量为：$C_{n}^{2}=\\frac{n(n-1)}{2}$。 存储结构\n邻接表是顺序存储与链式存储相结合的存储方法。 无向图的邻接矩阵是一个对称矩阵，有向图的邻接矩阵是一个稀疏矩阵。 在含n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为$n^{2}-2e$；而有向图的邻接矩阵中，零元素个数为$n^{2}-e$。 遍历\n图的遍历方法有两种：深度优先搜索DFS、广度优先搜索BFS。 图的遍历操作类似于树的遍历操作；深度搜索的顶点的访问序列不是唯一的。 深度优先搜索类似于树的先序遍历；广度优先搜索类似于树的层次遍历。 以邻接表为存储结构，深度优先搜索算法的时间复杂度是$O(n+e)$，其中n为图的顶点数，e为图的边数。 以邻接矩阵作为存储结构，深度优先搜索算法的时间复杂度是$O(n^2)$，其中n为图的顶点数。 应用\n一个图的最小生成树是图所有生成树中权总和最小的生成树；最小生成树有两种算法：普里姆Prim算法、克鲁斯卡尔Kruskal算法。 克鲁斯卡尔Kruskal方法的思想，初始时将每个顶点看成一个单独的连通分量，找所有连通分量之间的权值最小的一条边，将该边添加到两个连通分量中，并合并成一个新的单独的连通分量，重复这个过程，直到所有顶点最终形成一个连通分量。 最短路径算法可以采用迪杰斯特拉Dijkstra算法，思想是按照最短路径长度递增的方法产生从一点到其他顶点的最短路径。 完成拓扑排序的前提条件是AOV网中不允许出现回路。 以邻接表作为存储结构，拓扑排序算法的时间复杂度为$O(n+e)$，n是图的顶点个数，e是图的弧的数目。 第六章 查找 对于一种数据结构，查找表的逻辑结构是集合。 顺序表为(b1, b2, b3)，查找b1，b2，b3的概率分别为0.2、0.2、0.6，则顺序查找法的平均查找长度为$(0.2\\times3)+(0.2\\times2)+(0.6\\times1)=1.6$。 顺序表\n向一个长度为n的顺序表中第i($1{\\leq}i{\\leq}n$)个元素之前插入一个元素时，需向后移动$n-i+1$个元素。 从一个长度为n的顺序表中删除第i个元素($1{\\leq}i{\\leq}n$)时，需向前移动$n-i$个元素。 在长度为n的带有岗哨的顺序表中，进行顺序查找，查找不成功时，与关键字比较次数为$n+1$。 采用顺序查找方法查找长度为n的顺序表时，平均查找长度为$\\frac{(n+1)}{2}$。 二叉排序树\n中序遍历一棵二叉排序树可得到一个键值的升序序列。 二叉排序树的平均查找长度介于 $O(n)$ 和 $O(log_2n)$ 之间。 散列表、散列法、解决冲突方法\n散列法：数字分析法、除留取余法、平方取中法、基数转换法。 除留取余法$H(key)=key{\\quad}mod{\\quad}p(p{\\leq}n)$，p通常选小于散列表长度n的素数，如果p是偶数，得到的散列值总是偶数，如果是奇数则总是奇数。 解决冲突方法：线性探测法、二次探测法、链地址法、多重散列法、公共溢出区法。 非同义词之间对同一个散列地址的争夺现象称为堆积。 线性探测法容易产生堆积。二次探测法缺点不容易探测到整个散列表的所有空间。 链地址法实际上也可能存在堆积，退化成链表（书上未提及，仅个人观点）。 多重散列法优点不容易产生堆积，缺点计算量大。 公共溢出区法，在发生冲突的情况下，将同义词存入溢出表，基本表就不可能发生堆积（书上原话）。 要完全避免散列所产生的“堆积”现象，通常采用链地址法解决冲突（书中课后题的答案，按书中教的来）。 用线性探测法解决冲突，可能要探测多个散列地址，这些位置上的键值不一定都是同义词。 第七章 排序 稳定性是排序方法本身的特性，与数据无关。 当待排序序列已基本有序时，插入排序和交换排序比较有效（性能高）。当待排记录数量较大时，选择排序比较有效（性能高）。 插入排序\n插入排序方法有直接插入排序、折半插入排序、表插入排序、希尔排序。 直接插入排序类似图书馆整理图书的过程，时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是稳定的，不适宜n较大的序列。 交换排序\n交换排序方法有冒泡排序、快速排序。 冒泡排序时间复杂度为$O(n^2)$，空间复杂度$O(1)$，是稳定的。 快速排序实质上是对冒泡排序的一种改进。快速排序时间复杂度为$O(nlog_2n)$，最坏情况下时间复杂度近似$O(n^2)$，空间复杂度取决于实现的算法，是不稳定的，对数量n较小算法效果不明显，数量较大效果明显。 选择排序\n选择排序方法有直接选择排序、堆排序。 直接选择排序时间复杂度为$O(n^2)$，空间复杂度$O(1)$，是不稳定的，不适宜n较大的序列。 堆排序平均和最坏情况下时间复杂度都是$O(nlog_2n)$，空间复杂度为$O(1)$，是不稳定的，不适宜待排序记录较少时使用，记录数很多效果明显。 归并排序\n归并排序方法有有序序列的合并、二路归并排序。 有序序列的合并算法时间复杂度为$O(n-h+1)$。 二路归并排序时间复杂度为$O(nlog_2n)$，空间复杂度$O(n)$，是稳定的。 ","date":"2023-10-22T09:27:30+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/exam-focus/","title":"《数据结构导论》考试重点"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 阅读说明 以下排序方法均以按递增（即升序）排列的方式对序列进行排序。\n概述 排序就是将一组对象按照规定的次序重新排列的过程，是数据处理中一种很重要也很常用的运算。\n排序是为检索服务的，例如图书馆书的摆放是按照索引号排序以后的结果，再例如电话号码簿、字典等。\n而排序又分为两大类：\n内部排序（Internal Sorting）：待排序的记录全部存放在计算机内存中进行的排序过程。 外部排序（External Sorting）：待排序的记录数量很大，内存不能存储全部记录，需要对外存进行访问的排序过程。 排序的方法有很多，例如插入排序、交换排序、选择排序和归并排序等等。\n而排序方法一般会关注以下指标：\n稳定性：对于相当的元素，排序前和排序后的相对位置（位置关系）是否有发生变化，如果没有，则说明排序的方法是稳定的，否则是不稳定的。 例如一个序列中有两个66，分别用R0和R1表示，排序前R0在R1的前面，而稳定是指排序以后R0仍然在R1的前面。 稳定性是排序方法本身的特性，与数据无关，也就是说，一种排序方法如果是稳定的，则排序处理对数据序列中的所有数据都是稳定的，相反如果有一组数据出现不稳定，该方法就是不稳定的。 时间复杂度和空间复杂度。 插入排序 常用的插入排序有：\n直接插入排序，文中只介绍了这一种。 折半插入排序。 表插入排序。 希尔排序。 直接插入排序 Straight Insertion Sorting是一种简单的排序方法，它的思想是将未排序区的元素逐个有序地插入到已排序区的合适位置，并始终保持已排序区的有序性。\n直接插入排序类似图书馆中整理图书的过程。\n步骤如下：\n将待排序的序列分成已排序区和未排序区。 从未排序区中取出第一个元素，在已排序区中，从后往前比较，小的话就往前面的位置放，直到找到插入位置并进行插入操作，此时已排序区依然是有序的。 重复步骤2，直到所有元素都被插入到已排序区中。 例如有一个待排序的序列：(45, 38, 66, 90, 88, 10, 25, 45)，序列中有两个45以说明算法的稳定性。\n排序过程如下：\n已排序区为空，未排序区为如上序列。 未排序区中取出第一个元素45，直接放进已排序区中。 取出第二个元素38，在已排序区中从后往前对元素进行比较，即45和38比，大了，让38排在前面。 此时已排序区序列：(38, 45)。 取出第三个元素66，比45大，排在45的后面，90同理，不做赘述。 此时已排序区序列：(38, 45, 66, 90)。 取出第五个元素88，90和88比，大了，再往前找一个元素进行比较，即66和88比，小了，说明再往前的元素都是比66还要小，无需再往前找了，就排在90的前面。 此时已排序区序列：(38, 45, 66, 88, 90)。 后面的元素同理，不再赘述。 给出具体的算法，说明：\n序列R的0的位置不使用，用于岗哨的作用。 n为表长。 1 2 3 4 5 6 7 8 9 10 11 12 13 void StraightInsertSort(List R, int n) { int i, j; for (i = 2; i \u0026lt;= n; i++) { R[0] = R[i]; j = i-1; while (R[0].key \u0026lt; R[j].key) { R[j+1] = R[j]; j--; } R[j+1] = R[0]; } } 该算法，R[0]的位置起到了两个作用：\n保存了R[i]位置的值，拿上面例子的步骤6为例，把已排序区中大于88的元素全部往后一个位置覆盖，当和66比较的时候结束了while循环，这个时候就从岗哨的位置即R[0]里取出88，避免了覆盖导致的丢失，最终放到了R[j+1]的位置，已排序区保持有序。 在while循环条件中起到了监视数组下标变量j是否越界，实现了自动控制while循环的结束，而不必特意去检查越界的情况。 一个字，妙 啊。\n总结规律：\n直接插入排序算法简单，易于理解，容易实现。 来看下指标： 45的相对位置没有变化，具有稳定性。 时间复杂度为O(n²)。 只需要一个记录的辅助空间，并不随循环的变化而导致空间的增加，空间复杂度为O(1)。 若待排序记录的数量很大时，一般不选用直接插入排序。 交换排序 交换排序的基本思想：比较两个记录键值的大小，如果结果是逆序，则交换这两个记录。\n递增排序，记录值小的放到前面，大的放到后面。 递减排序，大的放到前面，小的放到后面。 冒泡排序 冒泡排序Bubble Sorting是一种交换排序方法，其处理过程是：\n将第一个记录键值和第二个记录键值比较。 若为逆序，即第一个记录比第二个记录大，则交换这两个记录。 不为逆序，不操作。 然后继续比较第二个和第三个记录键值，依次类推，直至比较完最后一个记录键值。 以上过程称为第一趟起泡，作用是将记录键值最大的记录移到第n个位置上，即第n个位置已经是排序好的区域了。 第二趟起泡将从步骤1重新开始，直到未排序区域的最后一个记录键值结束。 重复以上过程，直到未排序区域仅剩下一个时，整个排序过程终止。 举个例子，现有一组待排序序列：(45，38，66，90，88，10，25，45)，排序过程如下：\n第一趟排序结果：38，45，66，88，10，25，45，90。 45和38比较，45大，交换两者位置。 交换后序列：38，45，66，90，88，10，25，45。 45和66比，无逆序，不操作。 66和90比，不操作。 90和88比，90大，交换位置。 交换后序列：38，45，66，88，90，10，25，45。 90和10比，90大，交换位置。 交换后序列：38，45，66，88，10，90，25，45。 后者同理，不再赘述。 第二趟排序结果：38，45，66，10，25，45，88，90。 第三趟排序结果：38，45，10，25，45，66，88，90。 第四趟排序结果：38，10，25，45，45，66，88，90。 第五趟排序结果：10，25，38，45，45，66，88，90。 第六趟排序结果：10，25，38，45，45，66，88，90。 第七趟排序结果：10，25，38，45，45，66，88，90。 算法如下：\n1 2 3 4 5 6 7 8 9 10 11 void bubbleSort(int arr[], int n) { for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = 0; j \u0026lt; n - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } 总结：\n冒泡排序时间复杂度为$O(n^2)$。 冒泡排序是稳定的排序方法。 快速排序 快速排序Quick Sorting是交换排序的一种，实际上是对冒泡排序的一种改进。思想是：\n选择排序 直接选择排序 堆排序 归并排序 二路归并排序 ","date":"2023-10-20T09:27:30+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter7/","title":"第七章 排序 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 分析查找运算的时间性能可以将“查找成功时的平均查找长度”作为评价查找算法时间性能的度量。\n静态查找表 书中主要讨论查找操作在不同存储结构下的实现。\n顺序表上的查找 静态查找表最简单的实现方法是以顺序表作为存储结构。\n用C语言表示如下：\n1 2 3 4 5 6 7 8 9 10 const int maxSize = 20; typedef struct { int key; } tableEle; typedef struct { tableEle data[maxSize+1]; int lastEleIndex; // 最后一个数据元素的下标 } sequenceTable; data[0]用于设置“岗哨”，不存储数据元素，以便简化查找运算的实现。\n在以上存储结构上实现顺序查找Sequential Search操作的步骤如下：\n从表的最后一个数据元素位置开始，从后往前依次将各个位置的数据元素和给定值比较。 如果相等，则查找成功，返回该下标位置作为结果。 如果查找到第一个元素，仍然与给定值不等，则查找不成功。 算法如下\n1 2 3 4 5 6 7 8 9 10 // 返回0表示查找失败。 int searchSequenceTable(sequenceTable table, int key) { table.data[0].key = key; i = table.lastEleIndex; while (table.data[i].key != key) { i--; } return i; } 该算法巧妙利用data[0]存储待查找的key，从而免去了每次查找都要检测表是否查找完毕，保证了while循环一定会终止，起到了岗哨的作用，这一改进对一次查找所花费的平均时间减少一半。\n因此对于分析查找运算的时间性能，通常用“数据元素的值与给定值的比较次数”作为衡量查找算法的好坏依据，其中的比较次数称为查找长度。\n例如：\n若待查找值在顺序表的第n个位置上，则查找长度为1。 而待查找值在顺序表的第1个位置上，查找长度为n。 那么可以将查找成功时的平均查找长度记为ASL，作为评价查找算法时间性能的度量。\n公式为：\n$ASL=\\displaystyle \\sum^{n}_{i=1}P_iC_i$\n$P_i$：查找第i个元素的概率，即给定值与顺序表中第i个元素值相等的概率，且$\\displaystyle \\sum^{n}_{i=1}P_i=1$。 $C_i$：表示在找到第i个元素时，顺序表中值与给定值已进行比较的个数。 假设顺序表为(b1, b2, b3)，查找b1，b2，b3的概率分别为0.2、0.2、0.6，则顺序查找法的平均查找长度为：\n$(0.2\\times3)+(0.2\\times2)+(0.6\\times1)=1.6$，即平均需要1.6次与给定值的比较才能找到待查找元素。\n由于多种因素的影响，$P_i$的值是难以确定的，通常假设$P_i$概率相等，即对所有i，有$P_i=\\frac{1}{n}$，并在此假设下确定查找算法的平均查找长度，因此得到顺序查找算法的平均查找长度为： $$ASL=\\displaystyle \\sum^{n}_{i=1}\\frac{1}{n}\\times(n-i+1)=\\frac{n+1}{2}$$\n有序表上的查找 二分查找 有序表：顺序表中的数据元素按照值的大小顺序排列。\n思想：在有序表中，用给定值和表中间位置的值进行比较，确定值所在的区间，然后逐步缩小查找区间，重复这个过程直到找到或者确认找不到为止，简单点说就是每找一次，区间缩小为原来的二分之一，因此得名二分查找。\n例如《幸运52》节目中的“看商品猜价格（13:40）”环节里，可以很好地应用二分查找的思想猜价格。\n例如有一个有序表：(10, 13, 17, 20, 30, 55, 68, 89, 95)，需要找17的值，以下是过程：\n确定搜索区间，low为1，即10的位置，high为9，即95的位置，区间就是[1, 9]。 取区间的中间位置，$(1+9)\\div2=5$，也就是30，发现大了，往左重新确定搜索区间。 接下来要搜索的区间是[1, 4]。 取中间位置，$(1+4)\\div2=2.5$，向下取整，为2，也就是13，发现小了，往右重新确定搜索区间。 接下来要搜索的区间是[3, 4]。 取中间位置，$(3+4)\\div2=3.5$，为3，也就是17，成功找到。 总结规律：\n二分查找的查找长度不超过⌊log2n⌋-1。 二分查找的平均查找长度为：$ASL_b = \\frac{n+1}{n}log_2(n + 1) - 1$。 当n较大时可得：$ASL_b \\approx log_2(n + 1) - 1$。 因此二分查找算法的时间复杂度为O(logn)。 散列表 用散列技术实现动态查找表，通过使数据元素的键值和存储位置之间建立某种联系，以减少比较次数。\n本文中键值是指一个东西，键值和值是两个东西。例如拿数组来说，键值是指下标，值就是下标指向的值。\n散列函数：数据元素的键值和存储位置之间建立的对应关系，也称为哈希（hash）函数。 散列值：经过散列函数处理以后的值，也称哈希值、哈希码。 散列：指用键值通过散列函数来获取存储位置的映射过程。 散列地址：指其中的存储位置。 散列表（Hash Table）：通过散列进行存储的方式，即这种存储结构。 冲突：也称哈希冲突，设有散列函数H，键值key有k1、k2，k1≠k2，冲突是指$H(k1)=H(k2)$。 即不同的键值散列到了同一个存储位置上。 这种情况在实际应用中经常出现，只能尽可能减少而不能完全避免。 因此使用散列技术时需要考虑两个问题：\n如何构造均匀的散列函数？ 用什么方法有效地解决冲突？ 散列法 数字分析法 数字分析法（Digit Analysis Method），大概说一下它的思想：\n将键值经过转换成数字。 例：abc转换成了301482。 再将数字进行分析，取出这些数字或者这些数字中的一部分。 例：将这些数字拆成单独的一个个数字，3，0，1，4，8，2。 将这些数字通过某种方式组织成一个值，这个值就是散列值。 例：把这些数字加起来，得到18。 除留余数法 是一种简单有效且最常用的方法。\n它的基本思想是：\n将键值转换成非负整数。 将该整数除以n（一般是散列表的长度），并取余数，这个余数就是散列值。 例如：整数37，n是10，37除以10，得到商3和余数7。 这个过程在C语言中可以用%进行运算。 在书中的表示是：$H(key) = key {\\quad} mod {\\quad} p(p{\\leq}n)$\nmod是指取余运算。 p是指除数（正整数）。 该方法对p的选取比较关键，通常选n为小于散列表长度的素数。\n素数是指除了1和自身，再没有其他正整数能够整除它。\n例如2、3、5、7、11都是素数。 如果p选的不合适的情况下，容易发生冲突，会遇到以下的问题：\n遇到奇数键值，散列值总是得到奇数。 遇到偶数键值，散列值总是得到偶数。 平方取中法 平方取中法（Square-Then-Choose Method）是一种简单的伪随机数生成算法。\n它的基本思想是：\n先将某个种子值进行平方运算。 再从中间选取若干位作为新的种子值。 重复以上过程直到得到想要的随机数。 而用在散列函数中，因为计算简单，也是一种较为常用的方法。\n一般步骤如下：\n将键值转换为一个初始种子值x0，x0是数字。 对x0进行平方运算，得到x1。 从x1的中间取出若干位作为值，这个值就是散列值。 基数转换法 \u0026hellip;\n散列冲突解决 冲突解决的核心思想：给冲突的键值找一个空闲的散列地址，如果仍然冲突，重复这个过程，直到不发生冲突为止。\n那么接下来就是介绍都有哪种方式去找一个空闲的散列地址。\n线性探测法 设H(key)=d，d是散列值，散列表容量为m，那么线性探测法找一个空闲的散列地址遵循以下的规律：\nd+1。 d+2。 d+3。 \u0026hellip;。 m-1。 0。 1。 2。 \u0026hellip;。 d-1。 举个例子，有长度13（即m=13）的散列表，存储地址的下标有0-12，采用除留余数法进行散列，表中已有16、30、54的元素，分别位于下标为3、4、2的存储空间。\n此时插入一个键值为29的元素，散列函数求出散列地址为3，即下标为3，而下标为3已经被占用了，采用线性探测法进行冲突解决，过程如下：\n进行第一次找空闲空间，d+1，即3+1，找到了下标为4的空间，发现仍然被占用。 继续第二次找空间空间，d+2，即3+2，找到了下标为5的空间，是空闲的，那就将29放到这个空间里。 线性探测法：当键值冲突时，将得到的散列值按照顺序依次往后寻找空闲的空间，直到散列值下标的前一个空间为止。\n可以看出寻找空闲散列地址的计算过程（书上称为生成后继散列地址）还是很简单的。\n但是，存在一个问题：以键值16和29为例，它们并不相同（书上称为不是同义词）却发生了冲突。\n这种非同义词之间对同一个散列地址的争夺现象称为堆积。\n因为某个键值冲突而被安排到一个空闲空间，而本该被分配到这个空闲空间的键值出现时，又因为被占用，而需要重新寻找空闲空间。\n这个方法实际上非常容易出现堆积现象，意味着插入时间复杂度非常高，特别是在散列表快满了的时候。\n二次探测法 思想：生成的后续散列地址不是连续的，而是跳跃式的，目的是减少堆积问题。\n二次探测法找一个空闲的散列地址遵循以下的计算方式： $$d_0 = H(key)$$ $$d_i = (d_0 \\pm i){\\quad}mod{\\quad}m$$ 其中i的规律是：\n$i = 1^2$ $i = -1^2$ $i = 2^2$ $i = -2^2$ $i = 3^2$ $i = -3^2$ \u0026hellip; $i = {\\pm}k^2(k \\leq\\frac{m}{2})$ 举个例子，有长度11（即m=11）的散列表，存储地址的下标有0-10，采用除留余数法进行散列，序列为：（20，38，16，27，5，23，56，29），建立出对应的散列表以及计算出等概率的情况下查找成功的平均查找长度。\n以下是过程：\n20取余，得到下标9。 查找长度为1，经过1次散列函数才找到。 38取余，得到下标5。 16取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间空闲可用（以下可用时不再赘述）。 查找长度为2，经过2次散列函数才找到（以下同理不再赘述）。 27取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间被（16）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标4。 5取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间被（16）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标4，空间被（27）占用。 第三次空闲空间：$(5 + 2^2){\\quad}\\%{\\quad}11$，得到下标9，空间被（20）占用。 第四次空闲空间：$(5 - 2^2){\\quad}\\%{\\quad}11$，得到下标1。 23取余，得到下标1，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标2。 56取余，得到下标1，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标2，空间被（23）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标0。 29取余，得到下标7。 得出序列：\n下标 0 1 2 3 4 5 6 7 8 9 10 序列 56 5 23 27 38 16 29 20 查找长度 1 1 2 3 5 2 3 1 等概率情况下查找成功的平均查找长度为：$ASL=\\frac{1+1+2+3+5+2+3+1}{11}=\\frac{18}{11}$。\n链地址法 多重散列法 ","date":"2023-10-19T12:23:25+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter6/","title":"第六章 查找 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 为了方便文章表述，以下内容有一些调整：\n书中顶点v0、v1、v2，在文中以v0、v1、v2的方式进行描述（文字以及配图）。 概要 概念 应用背景 假如有这样一个问题，在N个城市间建立通信网络，使得其中任意两个城市之间有直接或间接的通信线路，假设已知每两个城市之间通信线路的造价，要求找出一个总造价最低的通讯网络。\n当N很大时，这个问题十分复杂，就需要用到计算机来求解，而使用到的数据结构就是图结构。\n这里有几个需要解决的问题：\n如何描述该问题的数据？ 如何在计算机中存储数据？ 解决问题的算法是什么？ $$图1$$\n顶点：即上图的圆圈。 如图1a)，v0、v1、v2等。 在上面的例子圆圈代表一个城市。 边：即上图圆圈之间的连线，也称为顶点的偶对。 如图1a)，v0和v1之间的连线。 权：即连线旁边的数值，也称为边的权。 如图1a)，v0和v1的权为50。 在实际应用中，权可以表示一个顶点到另一个顶点的距离、代价或耗费等。 带权图：每条边都带有权的图。 如图1a)。 $$图2$$\n图Graph由两个集合V和E组成，记为$G=(V, E)$，其中：\nV是顶点的有穷非空集合，一般表示为：V = {v0, v1, v2}。 E是边的集合，一般表示为：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v2\u0026gt;}。 有向图：顶点的偶对是有序的。 有序偶对用尖括号括起来，例：\u0026lt;v0, v1\u0026gt;，含义是从顶点v0到顶点v1有一条边。 如图2a)是一个有向图，可以看到边是带有箭头的，即有方向的。 无向图：顶点的偶对是无序的。 无序偶对用圆括号括起来，例：(v0, v1)，含义与有向图一样。 如图2b)是一个无向图。 弧：有向图的边又称为弧（无向图可没有这种说法，大概用于区分的作用）。 弧头：表示弧的终点，即弧有箭头的一端。 例：\u0026lt;v0, v1\u0026gt;，图2a)的v0和v1的弧，v1就是弧头的一端。 弧尾：表示弧的始点/起点。 例：\u0026lt;v0, v1\u0026gt;，图2a)的v0和v1的弧，v0就是弧尾的一端。 无向图中(v0, v1)和(v1, v0)是同一条边，但对于有向图来说，\u0026lt;v0, v1\u0026gt;和\u0026lt;v1, v0\u0026gt;可是两条不同的弧。\n有向完全图：任何两个顶点之间都有弧的有向图。 一个具有n个顶点的有向完全图的弧的数量为：$n(n-1)$。 为什么？怎么得出来的公式？ 将所有顶点连接起来只需要顶点数量-1条边就足够了，例如2个顶点只需1条线，3个顶点只需2条线，因此得出n-1。 而作为有向完全图来说，两个顶点都有弧则需要两条边才行，例如2个顶点需要2条线，3个顶点需要6条线，就是在上面的基准下再加多一条线，因此得出n(n - 1)。 无向完全图：任何两个顶点之间都有边的无向图。 一个具有n个顶点的无向完全图的边的数量为：$\\frac{n(n-1)}{2}$。 怎么得出来的公式？根据定义得知，无向图顶点之间的边是同一条边，即2个顶点只需要1条线，因此拿有向完全图的公式除2就能够得出无向完全图的边的数目了。 顶点的度：与该顶点相关联的边共有多少，记为D(v)。 D全称：degree。 v表示顶点。 顶点度 = 入度 + 出度之和，即D(v) = ID(v) + OD(v)。 以图2a)，v2为例： ID(v2) = 1。 OD(v2) = 2。 D(v2) = 3。 以图2b)为例： D(v1) = 2。 D(v2) = 3。 入度：仅有向图，以顶点为终点的弧共有多少，记为ID。 I全称：input。 出度：仅有向图，以顶点为始点的弧共有多少，记为OD。 O全称：output。 子图：$G=(V, E)$是一个图，若E'是E的子集，V'是V的子集，并且E'中的边仅与V'中的顶点相关联，则图$G\u0026rsquo;=(V\u0026rsquo;, E\u0026rsquo;)$称为图G的子图。 路径：从一个顶点x到另一个顶点y之间的路线，这个路径也称为顶点的序列。 例图2b)，无向图的顶点v0到v3的路径共有2条： 顶点序列v0，v1，v2，v3，路径长度为3。 顶点序列v0，v2，v3，路径长度为2。 路径长度：路径上边/弧的数目。 简单路径：序列中顶点不重复出现的路径。 例图2b)，顶点序列v0，v1，v2，v3就是一条简单路径。 回路：第一个顶点和最后一个顶点相同的路径，也称为环。 例图2b)，以下路径都是回路： v0→v1→v2→v0→v2→v0 v0→v1→v2→v0 简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。 例图2b)，以下是简单回路： v0→v1→v2→v0 连通：顶点x到顶点y有路径，则称顶点x和顶点y是连通的。 连通图：图中任意两个顶点都是连通的。 例图2b)是一个连通图。 v0和v3没有直接的边但也能通过v0-\u0026gt;v2-\u0026gt;v3进行连通，因此符合连通图的定义。 例图2f)是非连通图，因为存在多个不连通顶点，例如v0和v3是不连通的。 连通分量：无向图中的极大（最大）连通子图。 简单点说，以图2f)为例，把一个图中的所有顶点看成一个整体的图，而单独取v0、v1、v2三个顶点构成的子图来说，就像图2g)，它就是一个连通图，也是一个连通分量，它是一个整体图中的一个连通分量，包括v3和v4构成的子图也是一样是一个连通分量。 连通相关的术语是针对无向图的，而强连通相关术语就是用来描述有向图的。\n强连通：与连通的含义一样，区别是无向图的连通本身就是双向的，如果是有向图，则要求顶点和顶点之间是双向相连才称为强连通。 强连通图：与连通的含义一样，任意两个顶点都是强连通的。 强连通分量：与连通分量的含义一样，不做赘述（估计是用来区分有向和无向的专业术语）。 如果极大（最大）连通子图是用来讨论分量的，那么极小（最小）连通子图就是用来讨论生成树的。\n生成树：一个连通图例图2b)，含有全部顶点的一个极小连通子图就是生成树，就像例图2g)所示。 观察规律得知： 如果连通图G的顶点数量为n，G的生成树的边数则为n-1。 如果G的一个子图G\u0026rsquo;的边数大于n-1，则G\u0026rsquo;子图中一定有环。 相反，如果边数小于n-1，则G\u0026rsquo;一定不连通。 特征 在图Graph结构中，任意两个结点之间都可能有关系，结点之间的邻接关系可以是任意的，即多对多的关系。\n存储结构 图的存储结构有很多种：\n邻接矩阵。 邻接表。 十字链表。 邻接多重表。 等等等等\u0026hellip;。 文中主要介绍邻接矩阵和邻接表。\n邻接矩阵 使用二维数组很容易就能够实现。\n以\u0026lt;vi, vj\u0026gt;或者(vi, vj)为例，定义如下：\n用0表示vi和vj之间，即偶对并没有关联。 用1表示vi和vj之间，即偶对存在关联。 以图2为例，有向图G1和无向图G2的邻接矩阵，M1和M2分别如下：\n无向图的邻接矩阵是一个对称矩阵，有向图的邻接矩阵是一个稀疏矩阵。\n配图5，p134，待补充\u0026hellip; $$图5$$ 如图5，反映出了顶点之间的邻接关系，即逻辑关系，其中：\n矩阵M1的有向图为例： \u0026lt;v0, v1\u0026gt;第0行第1列为1，表示顶点v0和v1之间存在关联。 顶点的集合是：V = {v0, v1, v2, v3}，即顶点共有4个。 弧的集合是：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v0\u0026gt;, \u0026lt;v1, v2\u0026gt;, \u0026lt;v2, v0\u0026gt;, \u0026lt;v2, v3\u0026gt;}，弧共有5条。 矩阵M2的无向图为例： \u0026lt;v0, v1\u0026gt;第0行第1列和\u0026lt;v1, v0\u0026gt;第1例第0行都是1，表示顶点v0和v1之间存在关联，注意是双向的。 这两个偶对实际上是指同一条边，要和有向图区分开来。 顶点的集合是：V = {v0, v1, v2, v3}，即顶点共有4个。 边的集合是：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v2\u0026gt;, \u0026lt;v0, v2\u0026gt;, \u0026lt;v2, v3\u0026gt;}，边共有4条。 仅邻接关系还不够，用C语言完整的表示是：\n1 2 3 4 5 6 7 8 9 10 11 const int num = 20; // 一般为x*y数量的积 typedef struct vertexType { char val; } typedef struct graph { vertexType vexs[num]; // 顶点信息 int matrix[num][num]; // 邻接矩阵 int vertexNum, sideNum; // 顶点数，边数 } graph; 若是带权的邻接矩阵，则是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int num = 20; // 用于标识矩阵下没有数值的情况，值的大小按实际情况定义，只要能与权值区分开即可 const int maxNum = 32767; typedef struct vertexType { char val; } typedef struct weightType { int weight; } weightType; typedef struct graph { vertexType vertexs[num]; weightType matrix[num][num]; int vertexNum, sideNum; } graph; 邻接表 邻接表是顺序存储与链式存储相结合的存储方法。\n图的应用 最小生成树 Prim 遍历 图的遍历是指从图中的某个顶点出发，系统地访问图中的每个顶点，每个顶点仅访问一次。\n图的遍历操作类似于树的遍历操作，遍历的方式有两种，且都适用于有向图和无向图：\n深度优先搜索遍历，类似于树的先序遍历。 广度优先搜索遍历，类似于树的层次遍历。 由于图的顶点可能会与多个顶点相关联，在遍历过程中可能会多次访问到某个顶点，为了避免重复访问的问题，要记下每个已访问的顶点。可以用到数组，当顶点被访问后，对应下标的位置标记成1。\n参考 【精选】【数据结构】连通图、连通分量与强连通图、强连通分量—区别在于强，强强在哪里？ ","date":"2023-10-16T10:31:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter5/","title":"第五章 图 - 《数据结构导论》笔记"},{"content":"前言 比如现在来看一组幂运算（也叫求幂）：\n22，2的2次方，也就是2×2，结果是4。 23，就是2×2×2，结果是8，其中2是底数，3是指数。 那假如只给出结果16，底数是2，2x = 16，求x也就是指数是多少？要怎么做？\n猜得没错，这里就需要用到对数去解决。\n概念 对数是求幂的逆运算，正如除法是乘法的逆运算，定义为$N = a^x (a \u0026gt; 0, a \\neq 1)$，即a的x次方等于N。\n记作 $x = log_aN$ ，也就是 $a^x = N$ 等同于$x = log_aN$\n其中：\na叫做底数。 N叫做真数。 x叫做以a为底N的对数。 以上面的例子为例，用对数的表示就是：$x = log_216$\n当底数a=10的时候，叫做常用对数，可以缩写为：$lgN$ 当底数a=无理数e的时候，叫做自然对数，缩写为：$lnN$ 性质 零和负数无对数。 1的对数为0，$0 = log_a1$，也就是$a^0 = 1$ 底数和真数相同时，对数是1，$1 = log_aa$，也就是$a^1 = a$ 练习 1、将下面指数式写成对数式：\n$5^4=625$ 答：$4 = log_5625$ $2^{-6} = \\frac{1}{64}$ 答：$-6 = log2\\frac{1}{64}$ 2、将下面对数式写成指数式：\n$log_\\frac{1}{2}16 = -4$ 答：$\\frac{1}{2}^{-4} = 16$ $log_2128 = 7$ 答：$2^7 = 128$ 运算 $$a^x = M, \\quad a^y = N$$ $$a^x \\times a^y = a^{x+y}$$ $$M \\times N = a^{x+y}$$ $$log_a(M \\times N) = x + y$$\n运算法则 以下将介绍求出对数的方法都有哪些。\n1、$log_aN = \\frac{log_mN}{log_ma}$（a＞0，且a≠1，m＞0，且m≠1，N＞0）\n又称换底公式，用m替换a，m可以是任意一个数。\n以 $log_216$ 为例，将2替换成10，就是 $\\frac{log_{10}16}{log_{10}2}$ ，用计算器算一算：\n$log_{10}16$的精确结果是：1.204119982655948。 $log_{10}2$的精确结果是：0.3010299956639812。 相除以后的精确结果是：4.000000000000077，计算器取了近似值，所以答案是4，先取近似值再相除或者用精确结果相除再取近似值都可以，取决于计算时的选择。 2、$log_a(MN) = log_aM + log_aN$（a＞0，且a≠1，M、N＞0）\n对数的乘法法则。\n3、$log_a\\frac{M}{N} = log_aM - log_aN$（a＞0，且a≠1，M、N＞0）\n对数的除法法则。\n4、$a^{log_aM} = M$（a＞0，且a≠1，M＞0）\n5、$log_{a^{m}}b^{n} = \\frac{n}{m}log_ab$（a、b＞0，且a、b≠1）\n疑问 1、为什么定义中$a \u0026gt; 0, a\\neq1$？ 因为这些取值都是没有意义的，所以要限制，比如：\n当a=0时，无论指数是多少，最终结果都是0。 当a=1时，无论指数是多少，最终结果都是1。 当a＜0时，即负数时，求幂的结果可能会有两种情况，要么是正数要么是负数，带来的多义性无法保证对数运算结果的唯一性，比如： 指数为奇数时，求幂的结果是负数。 指数为偶数时，求幂的结果是正数。 应用 1、一棵完全二叉树中有65个结点，请算出完全二叉树的深度。\n根据二叉树的性质4我们知道计算深度对应的公式是：$⌊log_2n⌋+1$。\n将数据代入公式可以得到$⌊log_265⌋+1$，使用换底公式，把底数2换成10，就是$\\frac{log_{10}65}{log_{10}2}$。\n我们用计算器算一下，精确结果是：6.022367813028454，向下取整就是6，代入公式。\n最终答案是：$⌊log_{2}65⌋+1=6+1=7$。\n如果在不能使用计算器的情况下，当然还有一种笨方法，把$log_{2}65$写成指数式，即$2^x=65$。\n把不同的数字代入x，用穷举法来找一找哪个数字最接近65：\n来大一点的数字，直接上5，即$2^5$，答案是32，还差的远，继续往上递增。 上6，即$2^6$，答案是64，非常接近了。 再往上递增看看，$2^7$，结果是128，超过65了。 那么估算答案可能是6和7之间的小数：6.xxx，因为有向下取整函数，无论有多少个小数，最终答案都是6。\n所以实际上我们并不需要精确的结果，同样也能够解决问题。\n参考 对数_百度百科 03.什么是对数__哔哩哔哩_bilibili 指数函数、对数函数、幂函数 -快速入门到完美精通_哔哩哔哩_bilibili （高一）对数（一）（对数的基本性质和性质）_哔哩哔哩_bilibili ","date":"2023-09-28T14:47:45+08:00","permalink":"/p/subject/math/sequence/logarithm/","title":"什么是对数？"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 涉及知识点 数学知识 对数 概要 树 概念 结构 森林 相关术语和计算 基本运算的功能描述 二叉树 概念 左、右子树 基本运算 性质特征 满二叉树 完全二叉树 存储结构 顺序存储 链式存储 用C语言描述 遍历算法 递归实现 先序遍历 中序遍历 后序遍历 层次遍历 非递归实现 树和森林 树的存储结构 孩子链表表示法 孩子兄弟链表表示法 双亲表示法 树、森林和二叉树的关系与转换 树转二叉树 森林转二叉树 二叉树转森林 遍历 判定树和哈夫曼树 概念 判定树 哈夫曼树 哈夫曼编码 分类和判定树的关系 哈夫曼树构造过程 哈夫曼算法 树 概念 树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。\n特征：树形结构结点之间具有一对多的关系，一个结点可以有一个或多个直接后继。\n双亲：指父结点，parent node翻译过来的意思。 例，如图a)： A没有双亲。 B、C、D的双亲是A。 E、F的双亲是B。 直接孩子：指结点的孩子，孩子的孩子不算，只是为了方便区分，一般简称孩子。 例，如图a)： A的孩子有B、C、D。 B的孩子有E、F。 祖先：沿着某个结点向上追溯，直到根结点结束，路径上的所有结点都是祖先。 例，如图a)： A没有祖先。 B的祖先是A。 H的祖先分别是G、D、A。 子孙：除了根结点以外的其他结点。 例，如图a)： B的子孙分别是E、F。 D的子孙分别是G、H、I、J。 兄弟结点：某个结点的直接孩子们，它们之间是兄弟关系，拥有同一个父结点。 例，如图a)： B、C、D它们之间是兄弟。 E、F是兄弟。 叶子：没有孩子的结点，也称叶子结点、终端结点。 例，如图a)：E、F、C、H、I、J都是叶子。 子树：某个结点的所有子孙（后代结点）所构成的树结构。 例，如图a)： D、G、H、I、J所构成的树结构是根结点A的子树。 C不算子树，因为它没有子孙。 B、E、F这棵树是根结点A的子树。 结点的度：某一个结点有多少个直接孩子。 例，如图a)： A结点的度为3。 B结点的度为2。 D结点的度为1。 树的度：结点的度的最大值，也就是所有结点里直接孩子最多的那个。 例，如图a)：树的度为3。 结点的层次：把一棵树比作一个层级金字塔，从根结点为1，每下一层+1，数到结点所在的层级。 例，如图a)： B的层次是2。 E的层次是3。 H的层次是4。 树的高度/深度：结点的层次的最大值，也就是树一共有多少层。 例，如图a)：树高为4。 有序树：结点的孩子之间的按照一定的顺序排序，典型的例子是二叉树。 无序树：结点的孩子之间的顺序可以任意排列，典型的例子是普通树，也称自由树。 一棵树需要满足的条件：\n当n=0时，称为空树。 当n\u0026gt;0时： 仅有一个称为根的结点，简称根结点。 根结点有它的直接孩子，构成父子关系，直接孩子也有自己的孩子，构成根结点的子树。 孩子之间没有关联，互不相交，把孩子作为一个单独的根结点时，以上条件同样适用。 上图b)、c)不是一棵树，存在两个根节点，d)也都不是一棵树，因为孩子之间相交了。\n以上第2个条件是我个人方便理解的总结，贴上书上原话：有且仅有一个称为根的结点，除根节点外，其余结点分为m(m≥0)个互不相交的非空集合T1，T2，\u0026hellip;，Tm，这些集合中的每一个都是一棵树，称为根的子树。\n森林Forest是m(m≥0)棵互不相交的树的集合，简单点说就是有多棵树，且它们之间互不相交，例如图b)、c)。\n基本运算的功能描述 求根Root(T)：求树T的根节点。 求双亲Parent(T, X)：求结点X在树T上的双亲节点，若X是根结点或不在T上，则返回特殊标志。 求孩子Child(T, X, i)：求结点X的第i个孩子结点，若X不在T上或X上没有i孩子，则返回特殊标志。 建树Create(X, T1, \u0026hellip;, Tk)，k\u0026gt;1：建立一棵以X为根，以T1，\u0026hellip;，Tk为第1，\u0026hellip;，k棵子树的树。 剪枝Delete(T, X, i)：删除树T上结点X的第i棵子树，若T无第i棵子树，则为空操作。 遍历TraverseTree(T)：遍历树，即访问树中每个结点，且每个结点仅被访问一次。 二叉树 概念 二叉树Binary Tree是n(n≥0)个元素的有限集合，即在树的基础上，一棵二叉树需要满足其中一个条件：\n空树，什么结点都没有。 只有一个根结点，即左右子树均为空。 右子树为空。 左子树为空。 由一个根结点和两棵互不相交的左子树和右子树组成，子树之间是有次序关系的，且均是一棵二叉树。 $$图4.2$$\n性质特征 二叉树的5个性质特征：\n性质1：二叉树第i（i≥1）层上至多有2i-1个结点，也就是： 第一层最多有1个结点。 第二层最多有2个结点。 第三层最多有4个结点。 第四层最多有8个结点，以此类推。 性质2：深度为k（k≥1）的二叉树至多有2k-1个结点，也就是例如二叉树高为3，那么最多有4个结点。 符合该性质的称为满二叉树。 性质3：对任何一棵二叉树，若度数为0的结点个数为$n_0$，度数为2的结点个数为$n_2$，则 $n_0=n_2+1$。 例如上图c)，度数为0的结点个数是3（D、G、F），度数为2的结点个数是2（A、B）。 完全二叉树：如果对满二叉树按从上到下，从左到右的顺序编号，并在树的最后一层删去部分结点（最后一层至少还剩一个结点），删完以后整棵树的结点还是顺序的排列，这就是棵完全二叉树，其性质有：\n性质4：含有n个结点的完全二叉树的深度为$⌊log_2n⌋+1$。 其中⌊x⌋表示不大于x的最大整数，即向下取整函数，指⌊$log_2n$⌋，$log_2n$是对数，什么是对数？ 例如上图b)，共有10个结点，即⌊log210⌋+1，对数结果是3.32..向下取整后是3，最终深度是4。 性质5：按上面完全二叉树的定义对结点进行顺序编号，对任意一编号为i(1 ≤ i ≤ n)的结点x，性质有： 若i = 1，结点x是根。 若i \u0026gt; 1，结点x的双亲的编号为：⌊i / 2⌋。 若2 * i ＞ n，结点x无左和右孩子；若有左孩子，其编号为2 * i。 若2 * i + 1 ＞ n，结点x无右孩子，若有右孩子，其编号为2 * i + 1。 书上原话：二叉树不是完全二叉树，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。\n基本运算的功能描述 初始化Initiate(BT)：建立一棵空二叉树，BT=∅。 求双亲Parent(BT, X)：找出结点X的双亲结点，若X是根结点或X不在BT上，返回NULL。 求左孩子Lchild(BT, X)：求X结点的左孩子，若X是叶子结点或X不在BT上，返回NULL。 求右孩子Rchild(BT, X)：与求左孩子逻辑一样，区别是求X结点的右孩子。 建二叉树Create(BT)：建立一棵二叉树BT。 先序遍历PreOrder(BT)：按先序对二叉树BT进行遍历，每个结点仅被访问一次。BT为空不操作。 中序遍历InOrder(BT)：与先序遍历逻辑一样，区别是以中序进行。 后序遍历PostOrder(BT)：与先序遍历逻辑一样，区别是以后序进行。 层次遍历LevelOrder(BT)：按层从上往下，每层从左往右对二叉树进行遍历，每个结点仅被访问一次。BT为空不操作。 存储结构 二叉树通常有两种存储结构：顺序存储和链式存储结构。\n顺序存储 二叉树的顺序存储可以用一维数组来实现，按照性质5的特性，对结点进行从上到下从左到右的顺序进行编号，从根结点1开始，将结点顺序地存进数组的对应下标位置，下标0不使用。\n顺序存储分为两种情况：\n如果二叉树是完全二叉树，如下图a)、b)的方式进行存储。 如果二叉树非完全二叉树： 首先必须用某种方法将其转换成完全二叉树。 对不存在的结点的位置可增设虚拟结点（阴影表示）的方式，如下图e)。 对应虚拟结点下标的位置使用特殊记号∧表示。 非完全二叉树的顺序存储虽然可以用转换完全二叉树，以完全二叉树的顺序存储进行处理，这样只要是一棵二叉树（不管是哪种类型）都能够用同一种运算方式进行处理，但这种方法最大的缺点是造成了空间的浪费。\n链式存储 二叉树最常用的是链式存储结构，其中又分为二叉链表和三叉链表。\n其中：\nlchild表示指向左孩子的指针，即左指针。 没有左孩子时左指针域的值为NULL。 rchild表示指向右孩子的指针，即右指针。 没有右孩子时右指针域的值为NULL。 每个二叉链表必须有一个指向根结点的指针，即根指针，例如上图 c) 中的root，与链表头指针类似。 访问二叉链表只能从根指针开始。 若二叉树为空，则root = NULL。 三叉链表在每个结点增加了一个指针域parent，用于指向该结点的双亲。 因此总结出规律，在具有 n 个结点的二叉树中，有2n个指针域： 其中只有n - 1个用来指向结点的左、右孩子。 其余的n + 1个指针域为NULL。 用C语言描述 二叉树 1 2 3 4 5 typedef struct binaryTreeNode { dataType data; struct binaryTreeNode *lchild, *rchild; } *binaryTree; 三叉树 1 2 3 4 5 6 typedef struct TBNode { dataType data; struct TBNode *lchild, *parent, *rchild; } *ThreeBinaryTree; ThreeBinaryTree root; 遍历 二叉树的遍历是指按某种次序访问二叉树上的所有结点，且每个结点仅访问一次。\n一棵二叉树由三部分组成：根、根的左子树、根的右子树。\n因此遍历二叉树总共有三个步骤：\n访问根结点。 遍历根的左子树。 遍历根的右子树。 遍历共有三种次序，不同的次序只是三个步骤的顺序不同：\n下面会以图4.2中的c)二叉树为例，分别说明对应次序的序列。\n先序遍历。 步骤顺序，简记为：根左右。 访问根结点。 先序遍历根的左子树。 先序遍历根的右子树。 先序遍历结点的序列为：ABDEGCF，以下是遍历过程： 访问A。 先序遍历A的左子树（BDEG）。 访问B。 先序遍历B的左子树（D）。 访问D。 先序遍历D的左子树（空）。 先序遍历D的右子树（空）。 先序遍历B的右子树（EG）。 访问E。 先序遍历E的左子树（G）。 访问G。 先序遍历G的左子树（空）。 先序遍历G的右子树（空）。 先序遍历E的右子树（空）。 先序遍历A的右子树（CF）。 访问C。 先序遍历C的左子树（空）。 先序遍历C的右子树（F）。 访问F。 先序遍历F的左子树（空）。 先序遍历F的右子树（空）。 中序遍历。 步骤顺序，简记为：左根右。 中序遍历根的左子树。 访问根结点。 中序遍历根的右子树。 结点的序列为：DBGEACF。 后序遍历。 步骤顺序，简记为：左右根。 后序遍历根的左子树。 后序遍历根的右子树。 访问根结点。 结点的序列为：DGEBFCA。 递归实现 先序、中序和后序都是基于递归的实现，下面给出各次序具体的算法。\n假设visit(bt)函数是访问指针bt所指结点。\n先序遍历 1 2 3 4 5 6 7 8 void preorder(binaryTree bt) { if (bt != NULL) { visit(bt); preorder(bt-\u0026gt;lchild); preorder(bt-\u0026gt;rchild); } } 中序遍历 1 2 3 4 5 6 7 8 void inorder(binaryTree bt) { if (bt != NULL) { inorder(bt-\u0026gt;lchild); visit(bt); inorder(bt-\u0026gt;rchild); } } 后序遍历 1 2 3 4 5 6 7 8 void postorder(binaryTree bt) { if (bt != NULL) { postorder(bt); postorder(bt); visit(bt); } } 层次遍历 不是重点，待补充\u0026hellip;\n非递归实现 不是重点，待补充\u0026hellip;\n应用 1、根据先序遍历和中序遍历次序创建一棵二叉树。\n先序遍历次序：ABDEGCF。 中序遍历次序：DBGEACF。 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 binaryTree createByPreInOrder(char preArr[], char inArr[], int preArrMinIndex, int preArrMaxIndex, int inArrMinIndex, int inArrMaxIndex) { if (inArrMaxIndex \u0026lt; 0) { return NULL; } int k; // 如下申请内存的方式出自书上，是高度概括的，会存在内存越界导致结果出现一些不可预料的问题。 // binaryTree bt = malloc(sizeof(binaryTree)); // 以下是正确的申请方式，两者之间在64位机器上相差16字节，前者8字节，后者24字节 binaryTree bt = malloc(sizeof(struct binaryTreeNode)); bt-\u0026gt;data.val = preArr[preArrMinIndex]; k = inArrMinIndex; while ((k \u0026lt;= inArrMaxIndex) \u0026amp;\u0026amp; (inArr[k] != preArr[preArrMinIndex])) { k++; } if (k \u0026gt; inArrMaxIndex) { return NULL; } bt-\u0026gt;lchild = createByPreInOrder(preArr, inArr, preArrMinIndex + 1, preArrMinIndex + k - inArrMinIndex, inArrMinIndex, k - 1); bt-\u0026gt;rchild = createByPreInOrder(preArr, inArr, preArrMinIndex + k - inArrMinIndex + 1, preArrMaxIndex, k + 1, inArrMaxIndex); return bt; } 实现思路：\n以递归的方式，逐个将先序遍历次序的结点在中序遍历次序范围中查找，简称在中序遍历中找根结点。 找到根节点以后，在中序遍历次序中分出该根节点的左子树（根结点的左边）和右子树（根结点的右边）的范围。 以A根结点为例，在中序遍历次序中： A的左子树即DBGE。 A的右子树即CF。 在左子树和右子树的范围中，再重复步骤1，在范围中寻找先序遍历次序的下一个结点，从而得到完整的左右子树。 2、根据中序遍历和后序遍历次序创建一棵二叉树。\n中序遍历次序：BACDEFGH。 后序遍历次序：BCAEDGHF。 思路：与先序遍历和中序遍历一样，都是从中序遍历中找到左右子树。\n步骤：\n由后序遍历次序确定F是根结点，那么在中序遍历次序中，F的左子树是BACDE，右子树是GH。 即得出后序遍历次序中，BCAED是F的左子树，GH是F的右子树。 那么从后序遍历次序的左子树范围中确定左子树的根结点是D，重复步骤1。 在中序遍历次序中： D的左子树是：BAC。 D的右子树是：E。 在后序遍历次序中即： D的左子树是：BCA。 D的右子树是：E。 继续下一个根节点A，A的左孩子是B，右孩子树C。 回到F的右子树：GH，H是根结点，H的左孩子是G。 算法：\n待补充\u0026hellip;\n树和森林 树的存储结构 $$图4.5$$\n孩子链表表示法 用C语言表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const int MAX_NODE_NUM = 20; typedef struct dataType { char val; } dataType; typedef struct node { int index; struct node *next; } *childLink; typedef struct childLinkArr { dataType data; childLink firstChild; } childLinkArr; int main() { childLinkArr link[MAX_NODE_NUM]; return 0; } 结合C语言定义和上图b)所示，其中：\nchildLinkArr是一个数组，数组元素个数与上图a)树T的结点的数量相同，结点存放的顺序按树T从上到下从左到右依次排列。 数组元素由数据域 + 首个孩子指针域组成。 数据域：用于存放结点值。 首个孩子指针域：指向从左到右的第一个孩子。 首个孩子指针域可以看作是头结点，其所指向的孩子链表（childLink）是一个单链表，分别是结点的第一个孩子、第二个孩子、第三个孩子以此类推。 孩子链表也由数据域 + 指针域组成。 数据域：存放孩子在数组childLinkArr中的下标位置。 指针域：指向下一个孩子，也是当前孩子的兄弟结点。 为了便于找到双亲，对childLinkArr结构体改进一下：\n增加一个双亲域parentIndex，存储结点双亲在数组childLinkArr中的下标位置，如上图c)。\n用C语言表示：\n1 2 3 4 5 6 typedef struct childLinkArr { dataType data; childLink firstChild; int parentIndex; } childLinkArr; 孩子兄弟链表表示法 如上图d)、e)所示，孩子兄弟链表的结构表示形式和二叉链表完全相同，只是结点含义不同：\n二叉链表，当前结点分为左孩子指针和右孩子指针。 孩子兄弟链表，当前结点分为首个左孩子指针（简称孩子指针）和兄弟结点指针，剩下的孩子通过遍历孩子指针的兄弟结点指针找到。 用C语言表示：\n1 2 3 4 5 typedef struct brotherNode { dataType data; struct brotherNode *son, *brother; } *treeLink; 双亲表示法 如上图f)所示，是当中存储结构最简单的一种，同样也是采取数组的方式，由数据域+双亲域组成：\n数据域：将树T所有的结点按从上到下从左到右的顺序，结点从下标0开始，一一存进数组。 双亲域：存储双亲结点在数组中的下标位置，没有双亲存储-1。 用C语言表示：\n1 2 3 4 5 6 7 const int size = 10; typedef struct { dataType data; int parentIndex; } Node; Node treeParentArr[size]; 疑问：\n只靠双亲怎么知道有哪些孩子？以及孩子的顺序？ 答： 双亲parentIndex是同一个值的，就表示这些都是孩子。 因为存储已经按从左到右顺序存储，把同一个双亲的所有结点找出来，数组下标的顺序就是孩子直接的顺序，即保证了孩子之间的逻辑结构。 树、森林和二叉树之间的转换 树转换成二叉树 转换方法：\n加线，所有兄弟结点之间加一条线，彼此连接起来。 抹线，除了结点的第一个左孩子，其他孩子与结点的连线全部抹掉。 旋转，以根节点为轴心，对树进行顺时针的适当旋转。 森林转换成二叉树 转换方法：\n将森林中的每棵树转换成二叉树。 加线，转换以后的二叉树，从第二棵二叉树开始，将其根节点作为前一棵二叉树根结点的右子树，以此类推。 二叉树转换成森林 转换方法：\n抹线，断开根结点与右孩子的连线，此时得到两棵二叉树。 抹线再加线，二叉树根节点的左子树的右子树们均断开连接，改成均与根节点之间连接，如果根节点有右子树，重复步骤1的操作。 剩下的二叉树重复按以上步骤进行处理。 树和森林的遍历 树 以图4.5的a)树为例。\n先序遍历 访问根结点 从左往右依次遍历孩子，以孩子为根节点，重复步骤1和步骤2。 先序遍历次序为：HABEGFDC。\n后序遍历 后序遍历根的孩子子树。 访问根结点。 后序遍历次序：BGFDEACH。\n层次遍历 访问根结点。 逐层往下遍历，每层从左到右依次访问结点。 层次遍历次序：HACBEGFD。\n森林 森林有两种遍历方法：\n先序遍历 从左到右访问第一棵树的根结点。 先序遍历根结点的子树。 先序遍历森林中的其他树，重复以上步骤。 中序遍历 从左到右中序遍历第一棵树根结点的第一个孩子的子树。 访问第一棵树的根节点。 中序遍历剩下的孩子的子树。 中序遍历森林中的其他树，重复以上步骤。 判定树和哈夫曼树 分类和判定树 树有广泛的应用，其中一种重要的应用是描述分类的过程。\n分类是一种常用的运算，将输入数据按照标准划分成不同的种类，例如：\n类别 A B C D 年龄值 age age \u0026lt; 18 18 ≤ age ＜ 45 45 ≤ age ＜ 60 age ≥ 60 百分比 0.2 0.3 0.25 0.25 插图..\n用于描述分类过程的二叉树称为判定树，其中上图a)的分类算法为：\n1 2 3 4 5 6 7 8 9 10 11 12 char classify(int age) { if (age \u0026lt; 18) { return \u0026#39;A\u0026#39;; } else if (age \u0026lt; 45) { return \u0026#39;B\u0026#39;; } else if (age \u0026lt; 60) { return \u0026#39;C\u0026#39;; } else { return \u0026#39;D\u0026#39;; } } 假设人口有N=10000人，C类别人口占25%，根据a)的判断树，区分1个人是否属于C类别需要进行3次比较，那么10000个人就需要$10000 \\times 0.25 \\times 3$，即7500次。\n所有类别总共需要的比较次数就是：23000次。\n1 2 3 4 SUM = (N × 0.2 × 1) + (N × 0.3 × 2) + (N × 0.25 × 3) + (N × 0.25 × 3) = N × (0.2 + 0.6 + 0.75 + 0.75) = 10000 × 2.3 = 23000 平均比较次数是：$SUM \\div N$ 即$23000 \\div 10000 = 2.3$次。\n而如果是b)的判断树，区分1人属于C类别则只需要2次比较，10000个人则需要5000次。\n所有类别总共需要比较20000次。\n1 2 3 4 SUM = (N × 0.2 × 2) + (N × 0.3 × 2) + (N × 0.25 × 2) + (N × 0.25 × 2) = N × (0.4 + 0.6 + 0.5 + 0.5) = 10000 × 2 = 20000 平均比较次数是2次，相较a)，总共减少了3000次比较，平均比较次数减少了0.3次。\n这说明，按不同判定树进行分类的计算量是不同的，有时可以相差很大，怎样才能构造出像b)一样，平均比较次数最少的判定树呢？\n没错，可以用到哈夫曼树和哈夫曼算法。\n哈夫曼树和哈夫曼算法 以上面的例子为例，给定一组权值为{p1, \u0026hellip;, pk}的序列，如何构造出一棵有k个叶子结点分别以权为值的判定树，并且平均比较次数是最小的？\n步骤如下：\n根据一组权值为{p1, \u0026hellip;, pk}的序列，构造森林F={T1, \u0026hellip;, Tk}，其中Ti是一棵只有根结点，权为pi的二叉树。 如图a)。 从F中选取两个权最小的两棵二叉树，组成一棵新的二叉树，左右孩子分别是两个权最小的二叉树 如图b)。 从F中删掉步骤2已经合并的两棵二叉树，并将新的二叉树加入F，如图c)。 此时再看是否还有多个二叉树。 如果是，继续重复步骤2。 直到只剩下一棵二叉树，这棵二叉树就是哈夫曼树，如图d)。 从中得出规律：\n需要经过$n-1$次合并，最终得出一棵哈夫曼树，其中n是指权值的数目，以上面的例子，权值数目为4。 最终得到的哈夫曼树共有$2n-1$个结点，其中： 哈夫曼树没有度数为 1 的分支结点。 用C语言实现，即哈夫曼算法，采用顺序存储，大小是2n-1的数组，数组中的元素有四个域，分别是：\n权值。 双亲下标值。 左孩下标值。 右孩下标值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;float.h\u0026gt; const int n = 10; typedef struct { float weigh; int parent, lchild, rchild; } node; typedef node huffmanTree[2*n-1]; void huffman(int size, float weigh[], huffmanTree tree) { int index, j, x, y; float m, n; // 初始化 for (index = 0; index \u0026lt; 2 * k - 1; index++) { tree[index].parent = -1; tree[index].lchild = -1; tree[index].rchild = -1; if (index \u0026lt; size) { tree[index].weigh = weigh[index]; } else { tree[index].weigh = 0; } } for (index = 0; index \u0026lt; size - 1; index++) { x = 0; y = 0; m = FLT_MAX; n = FLT_MAX; for (j = 0; j \u0026lt; size + index; j++) { if ((tree[j].weigh \u0026lt; m) \u0026amp;\u0026amp; (tree[j].parent == -1)) { n = m; y = x; m = tree[j].weigh; x = j; } else if ((tree[j].weigh \u0026lt; n) \u0026amp;\u0026amp; (tree[j].parent == -1)) { n = tree[j].weigh; y = j; } } tree[x].parent = size + index; tree[y].parent = size + index; tree[size + index].weigh = m + n; tree[size + index].lchild = x; tree[size + index].rchild = y; } } 哈夫曼编码 在通信领域中，通常希望字符在传输过程中总的编码长度越短越好，即对字符的存储进行压缩，能否找到最短的编码方案呢？\n没错，还是哈夫曼树，不过要加点编码。\n思路：\n通过对字符出现次数进行统计，字符是值，权是出现次数或者叫出现频率。 让出现频率较多的字符采用较短的编码。 出现频率较少的字符采用较长的编码。 哈夫曼二叉树的每个结点的左分支标记为0，右分支为1（如下图f)），这样，从根结点到每个叶子结点的路径，把路径所在的分支标记全部加起来就是对应字符的编码，这些编码就称为哈夫曼编码。\n例如：某个通信系统需要传输一个字符串”aaa bb cccc dd e“，它们出现的频率分别是：\n字符 a \u0026rsquo;\u0026rsquo; (空) b c d e 频率 3 4 2 4 2 1 频率序列从小到大排列后是：\n字符 e b d a \u0026rsquo;\u0026rsquo; (空) c 频率 1 2 2 3 4 4 经过哈夫曼树编码后，如上图f)，字符对应的编码分别是：\n字符 a \u0026rsquo;\u0026rsquo; (空) b c d e 编码 00 01 110 10 1111 1110 即字符串”aaa bb cccc dd e“对应的编码序列为”0000000111011001101010100111111111011110“。\n为了方便大家查看比对，用|对每个字符编码进行分开：\n1 00|00|00|01|110|110|01|10|10|10|10|01|1111|1111|01|1110 哈夫曼编码序列在还原成字符串的过程是，以上面的序列为例：\n拿接下来的第一个编码，即0，在哈夫曼树中寻找。 未找到，则把第一个编码和下一个编码加在一起，即00（a），继续在哈夫曼树中寻找。 没找到则一直重复步骤2。 找到了，即拿到了编码对应的字符串。 重置这个过程，继续走步骤1，直至结束。 参考 4.树与二叉树的转换 树与二叉树的转换 数据结构——哈夫曼树（Huffman Tree） 详细图解哈夫曼Huffman编码树 ","date":"2023-09-26T09:47:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter4/","title":"第四章 树和二叉树 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 本文涉及到的代码描述均为C语言。 概要 栈 概念 特征 用C语言描述 顺序栈 链栈 基本运算 初始化 栈空 栈满 进栈 出栈 取栈顶元素 应用 解决简单问题 队列 概念 特征 用C语言描述 顺序队列 循环队列 基本运算 初始化 队列空 队列满 入队列 出队列 取队列首元素 应用 解决简单问题 数组 一维和二维数组 逻辑结构 存储结构 存储位置计算 矩阵的压缩存储 特殊矩阵 对称矩阵 三角矩阵 上三角矩阵 下三角矩阵 稀疏矩阵 三元组表示法 简单的综合运用 栈 概念 栈Stack可以看作是特殊的线性表，特殊性在于基本运算是线性表运算的子集，是一种运算受限的线性表。而受限是指插入和删除运算限定在表的某一端进行。\n进栈：指插入运算。 出栈：指删除运算。 栈顶：允许进栈和出栈的一端。 栈底：栈顶的另一端。 空栈：不含任何数据元素的栈。 栈顶元素：处于栈顶位置的数据元素。 上溢：栈的容量已经满了，此时再进行进栈就会发生上溢。 下溢：空栈做出栈就会产生下溢，因为栈中没有任何数据元素。 栈是计算机科学中广泛使用的数据结构之一，例如：函数的嵌套调用和程序递归的处理都是用栈来实现的。\n特征 栈的修改原则是后进先出（Last In First Out），好比桌面上叠放着待清洗的碗碟，收拾以后的碗碟被放在栈顶，而在栈顶的碗碟会优先得到清洗。因此又称为后进先出线性表，简称后进先出表。\n生活中的例子 具有栈特征的生活场景：\n购物篮：顾客往购物篮放商品会放在栈顶，结账时从栈顶取出商品。 购物推车：顾客的购物车在结账完以后会被回收，叠放在栈顶，下一个顾客需要时会从栈顶取出。 射击：先装的子弹最后才被打出来，特殊子弹夹除外，例如左轮。 添饭：新加的米饭放在栈顶，栈顶的米饭先吃。 水杯加水：这个例子可能不太严谨，因为水流动的特性也有可能喝到非栈顶的水。 实现 栈的实现有两种方式：\n顺序栈：用一组连续的存储单元存放数据元素，通常用一个一维数组和一个记录栈顶位置的变量来实现顺序存储。 链栈：用带头结点的单链表实现，命名LS（linkStack），LS指向头结点，LS-\u0026gt;next指向栈顶结点，也是首结点，尾结点是栈底结点，通过各结点的指针连接组成栈。 栈的基本运算的功能描述：\n初始化InitStack(S)：构造一个空栈S。 判断栈空EmptyStack(S)：若为空栈返回1，否则返回0。 进栈Push(S, x)：将元素x插入栈S中，x成为栈顶元素。 出栈Pop(S)：删除栈顶元素。 取栈顶GetTop(S)：返回栈顶元素。 顺序栈 定义 顺序栈相关代码放在了ghjayce/code-example - sequence stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 const int maxSize=10; // 顺序栈的容量 typedef struct sequenceStack { dataType data[maxSize]; // 存储栈中数据元素的数组 int top; // 指向栈顶位置 } seqStack; 初始化 1 2 3 4 5 6 seqStack init() { seqStack stack; stack.top = 0; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(seqStack *stack) { if (stack-\u0026gt;top == 0) { return 1; } return 0; } 栈满 1 2 3 4 5 6 7 int isFull(seqStack *stack) { if (stack-\u0026gt;top == maxSize-1) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 8 9 10 int push(seqStack *stack, dataType x) { if (isFull(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈已满\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top++; stack-\u0026gt;data[stack-\u0026gt;top] = x; return 1; } 出栈 1 2 3 4 5 6 7 8 9 int pop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top--; return 1; } 取栈顶元素 1 2 3 4 5 6 7 8 dataType getTop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } return stack-\u0026gt;data[stack-\u0026gt;top]; } 双栈 为了节省空间，可以让两个数据元素类型一致的栈共享同一个一维数组空间，这种做法使一维数组空间构成了双栈。\n两个栈的栈底分别设在数组的两端，栈顶分别用top1、top2表示，两个栈分别做进栈运算时，彼此会迎面增长，那么判断为上溢的条件为：$top+1=top2$。\n上溢条件为什么是top+1？\n假设数组长度为40，0-19是第一个栈的空间范围，20-39是第二个栈的空间范围，而19+1则会超出第一个栈的空间范围，出现上溢。\n双栈示意图，待补充..\n用C语言表示双栈的数据结构：\n1 2 3 4 5 6 const int maxSize = 40; typedef struct doubleStack { dataType data[maxSize]; int top1, top2; } doubleStack; 双栈运算，待补充..\n链栈 定义 链栈相关代码放在了ghjayce/code-example - link stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 typedef struct { int id; } dataType; typedef struct node { dataType data; struct node *next; } linkStack; 初始化 1 2 3 4 5 6 linkStack *init() { linkStack *stack = (linkStack *)malloc(sizeof(linkStack)); stack-\u0026gt;next = NULL; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(linkStack *stack) { if (stack-\u0026gt;next == NULL) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 void push(linkStack *stack, dataType x) { linkStack *newNode = (linkStack *)malloc(sizeof(linkStack)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = stack-\u0026gt;next; stack-\u0026gt;next = newNode; } 出栈 1 2 3 4 5 6 7 8 9 10 int pop(linkStack *stack) { if (!isEmpty(stack)) { linkStack *removeNode = stack-\u0026gt;next; stack-\u0026gt;next = removeNode-\u0026gt;next; free(removeNode); return 1; } return 0; } 取栈顶元素 1 2 3 4 5 6 7 dataType *getTop(linkStack *stack) { if (isEmpty(stack)) { return NULL; } return \u0026amp;(stack-\u0026gt;next-\u0026gt;data); } 应用 1、将链栈中的结点进行逆置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 linkStack *reverse(linkStack *stack) { linkStack *newStack = init(); linkStack *stackNode = stack-\u0026gt;next; while (stackNode != NULL) { push(newStack, stackNode-\u0026gt;data); stackNode = stackNode-\u0026gt;next; } stackNode = stack-\u0026gt;next; while (!isEmpty(newStack)) { dataType *data = getTop(newStack); if (data != NULL) { stackNode-\u0026gt;data = *data; pop(newStack); } stackNode = stackNode-\u0026gt;next; } return stack; } 思路：\n遍历（逐个访问链表元素）要逆置的链栈（称为A链栈）的结点，将结点通过进栈的方式放到新的链栈（称为B链栈）中，此时B链表中结点的顺序已经与A链栈相反。 对B链栈进行逐一出栈，将出栈的结点按A链表的顺序对结点进行覆盖，完成逆置。 2、递归和栈，用递归实现阶乘函数\n待补充\u0026hellip;\n练习 1、设栈S的初始状态为空，若元素a、b、c、d、e、f依次进栈，得到的出栈序列是b、d、c、f、e、a，则栈S的容量至少是多少？\n答：至少3。\na进，b进，容量2。 b出，容量1。 c进，d进，容量3。 d出，c出，容量1。 e进，f进，容量3。 f出，e出，a出，容量0。 2、设一个链栈的输入序列为A、B、C，试写出所得到的所有可能得输出序列。\n答：共有5种可能的输出序列。\n输出ABC，A进，A出，B进，B出，C进，C出。 输出ACB，A进，A出，B进，C进，C出，B出。 输出BAC，A进，B进，B出，A出，C进，C出。 输出BCA，A进，B进，B出，C进，C出，A出。 输出CBA，A进，B进，C进，C出，B出，A出。 3、有一个整数序列，其输入顺序为20，30，90，-10，45，78，试利用栈将其输出序列改变为30，-10，45，90，78，20，试给出该整数序列进栈和出栈的操作步骤，用push(x)表示x进栈，pop(x)表示x出栈。\n答：\npush(20)，20 push(30)，20、30 pop(30)，20 push(90)，20、90 push(-10)，20、90、-10 pop(-10)，20、90 push(45)，20、90、45 pop(45)，20、90 pop(90)，20 push(78)，20、78 pop(78)，20 pop(20) 队列 概念 队列Queue，和栈一样可以看作是特殊的运动受限的线性表，受限在于插入和删除分别在两端进行。\n入队列：在队列尾部进行插入运算。 出队列：在队列首部进行删除运算。 队列首元素：队列首部第一个数据元素。 队列尾元素：队列尾部最后一个数据元素。 队列也是计算机科学中广泛使用的数据结构之一，例如：操作系统中进程调度、网络管理中的打印服务等都是用队列来实现的。\n特征 队列的修改原则是先进先出（First In First out），就像排队一样，但不允许插队，新加入的成员只能排在队列尾部，先加入的成员先离开队伍。\n生活中的例子 排队做核酸。 银行办业务。 排队上车/登机等。 实现 队列也有两种存储实现方式：\n顺序队列：由一个一维数组以及两个分别指向队列首部元素和队列尾部元素的指针。 链队列：由一个带头结点的单链表实现，头指针front指向链表的头结点，头结点的next指向队列首结点，尾指针rear指向队列的尾结点。 队列的基本运算的功能描述：\n队列初始化InitQueue(Q)：设置一个空队列Q。 判断队列为空EmptyQueue(Q)：若队列Q为空，返回1，否则返回0。 入队列EnQueue(Q, x)：将数据元素x从队尾一段插入队列。 出队列OutQueue(Q)：删除队列首元素。 取队列首元素GetHead(Q)：返回队列首元素的值。 顺序队列 定义 1 2 3 4 5 6 7 const int maxSize = 20; typedef struct sequenceQueue { dataType data[maxSize]; int front, rear; } seqQueue; seqQueue SQ; front表示队列首部，rear表示队列尾部，默认值均为0，也就是指向数组的0下标，该位置不存放数据元素。\n那么入队列的操作核心关键是：\n1 2 SQ.rear = SQ.rear+1; SQ.data[SQ.rear] = x; 出队列的操作：\n1 SQ.front = SQ.front+1; 这里出队列并不会去删除队列首元素，而是移动指向队列首部的指针。\n但是会存在一个问题，举一个例子：\na)为空队列，SQ.rear指向0的下标，SQ.front指向0的下标。 b)为20入队后，SQ.rear指向下标1，SQ.front为0。 c)为入队列30、40、50后的队列，SQ.rear为4，SQ.front为0。 d)为出队列20、30、40、50后的队列，SQ.rear为4，SQ.front为4。 e)为入队列60后，SQ.rear为5，SQ.front为4。 如果在e)的状态下，要做入队列的操作，SQ.rear将会超出数组下标的范围，也就是新元素没有办法入队列，但是1-4的位置明明是空的，数组的实际空间并没有被占满，这就是假溢出现象。\n另外还有一个问题是，队列空和队列满没有办法区分，就如a)和d)的情况。\n循环队列 为了解决顺序队列的假溢出问题，于是就有了循环队列，它将顺序队列数组的首尾进行相接，形成了一个环状，思路就是当入队列操作SQ.rear即将要超出数组下标范围的时候，将SQ.rear=0进行重置，也就是SQ.data[0]作为新的队列尾，这样新的元素就能够利用上空闲的空间，达到循环使用。\n至于没有办法区分队列空和队列满的解决方法有两种：\n为队列另设一个标志，也就是多加一个变量用作区分。 队列少用一个元素空间，当只剩最后一个空间时就认为队列满，也就是CQ.rear差一步就要追上CQ.front，如图b)，书中采用了该解决方法。 循环队列的环状让我想起了MySQL redo log的checkpoint和write pos。\n定义 循环队列相关代码放在了ghjayce/code-example - cycle queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 typedef struct cycleQueue { dataType data[maxSize]; int front, rear; } cycleQueue CQ; 按以上的解决思路，以下是几个操作的关键核心：\n入队列的操作：\n1 2 CQ.rear = (CQ.rear + 1) % maxSize; CQ.data[CQ.rear] = x; 出队列的操作：\n1 CQ.front = (CQ.front + 1) % maxSize; 队列满的条件：\n1 (CQ.rear + 1) % maxSize == CQ.front; 队列空的条件：\n1 CQ.rear == CQ.front; 初始化 1 2 3 4 5 void init(cycleQueue CQ) { CQ.front = 0; CQ.rear = 0; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(cycleQueue CQ) { if (CQ.front == CQ.rear) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 9 10 int push(cycleQueue CQ, dataType x) { if ((CQ.rear + 1) % maxSize == CQ.front) { printf(\u0026#34;\\s\\n\u0026#34;, \u0026#34;队列满\u0026#34;); exit(EXIT_FAILURE); } CQ.rear = CQ.rear + 1; CQ.data[CQ.rear] = x; return 1; } 出队列 1 2 3 4 5 6 7 8 int pop(cycleQueue CQ) { if (isEmpty(CQ)) { return 0; } CQ.front = (CQ.front + 1) % maxSize; return 1; } 取队列首元素 1 2 3 4 5 6 7 8 dataType getHead(cycleQueue *CQ) { dataType data; if (isEmpty(CQ)) { return data; } return CQ-\u0026gt;data[(CQ-\u0026gt;front + 1) % maxSize]; } 为什么是CQ-\u0026gt;front + 1？\n上面有提到过，别忘了数组的第0个位置是不使用的，而front默认所指向的位置是0，即front所指向的空间是不存储元素的或者即使有也是已被出队列的元素。\n链队列 再重复一遍，链队列是一个带有头结点的单链表组成，队列首部的指针指向头结点，头指针指向首结点，队列尾部的指针指向尾结点，队列空的时候，队列首部和尾部的指针均指向头结点。\n链接的实现需要动态申请内存空间，所以不会出现队列满的情况。\n定义 链队列相关代码放在了ghjayce/code-example - link queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int id; } dataType; typedef struct linkQueueNode { dataType data; struct linkQueueNode *next; } linkQueueNode; typedef struct linkQueue { linkQueueNode *front, *rear; } linkQueue; 初始化 1 2 3 4 5 6 7 8 9 10 linkQueue *init() { linkQueue *LQ = (linkQueue *)malloc(sizeof(linkQueue)); // 生成队列的头结点 linkQueueNode *node = (linkQueueNode *)malloc(sizeof(linkQueueNode)); LQ-\u0026gt;front = node; LQ-\u0026gt;rear = node; (LQ-\u0026gt;front)-\u0026gt;next = NULL; reutrn LQ; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(linkQueue LQ) { if (LQ.rear == LQ.front) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 void push(linkQueue *LQ, dataType x) { linkQueueNode *newNode = (linkQueueNode *)malloc(sizeof(linkQueueNode)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = NULL; (LQ-\u0026gt;rear)-\u0026gt;next = newNode; LQ-\u0026gt;rear = newNode; } 出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 void pop(linkQueue *LQ) { if (isEmpty(LQ)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;队列空\u0026#34;); exit(EXIT_FAILURE); } linkQueueNode *deleteNode = LQ-\u0026gt;front-\u0026gt;next; LQ-\u0026gt;front-\u0026gt;next = deleteNode-\u0026gt;next; if (deleteNode-\u0026gt;next == NULL) { LQ-\u0026gt;rear = LQ-\u0026gt;front; } free(deleteNode); } 取队列首元素\n1 2 3 4 5 6 7 8 dataType *getHead(linkQueue *LQ) { if (isEmpty(LQ)) { return NULL; } linkQueueNode *node = LQ-\u0026gt;front-\u0026gt;next; return \u0026amp;(node-\u0026gt;data); } 应用 待补充\u0026hellip;\n数组 概念 数组array可以看成是线性表的一种推广，由一组相同类型的数据元素组成，并存储在一组连续的存储单元中。\n一维数组：又称向量。 二维数组：一维数组中的数据元素是一维数组，一般写成a[m][n]，可看作由m行n列组成的线性表。 三维数组：一维数组中的数据元素是二维数组。 n维数组：一维数组中数据元素为n-1维数组。 运算 通常只有两种基本运算：\n读：返回指定下标的数据元素。 写：修改指定下标的数据元素。 存储结构 一维数组数据元素的内存地址是连续的，而二维数组的数据元素有两种存储方法：\n以列序为主序的存储。 以行序为主序的存储，C语言编译数组采用的正是该方法。 存储结构演示和数组的逻辑结构插图.png（待补充\u0026hellip;）\n计算存储位置 有一个二维数组a[m][n]，每个数据元素占用k个存储单元大小，以行为主序，数组元素a[i][j]的存储位置是多少？要怎么计算？\nm：行数量。 n：列数量。 i：在m行的下标。 j：在n列的下标。 下标是从0开始，那么数据元素a[i][j]：\n该下标之前总共有：n * i + j + 1个数据元素，其中： 每行有n（列的数量）个元素。 在第i行，有i行元素，在第j列，有j+1个元素。 第一个元素a[0][0]与a[i][j]相差n * i + j + 1 - 1个位置。 a[i][j]的存储位置计算公式为： $$loc[i, j] = loc[0, 0] + (n * i + j) * k$$ 实战一下，例如：\n有一个二维数组a[10][20]，每个数据元素占用2个存储大小，数组的起始内存地址为2000，求：\na[5][10]的存储位置是多少？ 整理数据： m：10。 n：20。 i：5。 j：10。 k：2。 将数据套入公式：2000 + (20 * 5 + 10) * 2，存储位置最终为：2220。 a[8][19]呢？交给你来试试。 矩阵的压缩存储 待补充\u0026hellip;\n特殊矩阵 对称矩阵 如果一个n阶的方阵满足以下条件，则是一个对称矩阵：\n$a_{ij} = a_{ji}$ $0 \\leq i, j \\leq n - 1$ 三角矩阵 稀疏矩阵 应用 1、对一个$N{\\times}N$阶的矩阵A进行逆置，请设计出算法。\n1 2 3 4 5 6 7 8 9 10 11 void MM(int A[n][n]) { int i, j, temp; for (i = 0; i \u0026lt; n; i++) { for (j = 0; j \u0026lt; i; j++) { temp = A[i][j]; A[i][j] = A[j][i]; A[j][i] = temp; } } } 综合运用 待补充\u0026hellip;\n","date":"2023-09-18T12:24:10+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter3/","title":"第三章 栈、队列和数组 - 《数据结构导论》笔记"},{"content":"概念 数列：按特定规律排列的一组数字的集合。 等差数列：指从第二项起，每一项与它的前一项的差都是同一个常数，这个常数称为公差。 例如：\n1、4、7、10、13、16、19 这是一组等差数列，每个数字之间相差3，其中：\n公差为：3。 首项（数列的第一个数字）是：1。 末项（数列的最后一个数字）是：19。 项数（数列的总数）：7。 数列的项（简称项）：数列中的一个个数字。 辨认 以下数列是否是等差数列？\n2、6、10、14、18、22，是 1、2、1、2、3、4、5、6，不是 1、2、4、8、16、32、64，不是 9、8、7、6、5、4、3、2，是 计算 求项的数 2、5、8、11、14、\u0026hellip;、?，求？第21项的数字是多少？\n如果项是最后一个也称为求末项\n分析：\n公差是3，找一下规律：\n5，序号2，和2之间差1个3。 8，序号3，和2之间差2个3（2+2个3）。 11，序号4，和2之间差3个3（2+3个3）。 14，序号5，和2之间差4个3（2+4个3）。 \u0026hellip; 根据规律问题变成了：序号21，2到底要加几个3？\n答案是：2 + (序号 - 1)个3，也就是2+20个3，所以第21项的数字是：62。\n因此得出公式：$$第n项的数 = 首项 + (n的序号 - 1) \\times 公差$$ 如果求第1个项的数字，也就是求首项，那么公式是： $$首项 = 末项 - (项数 - 1) ×公差$$\n求项的序号 5、8、11、14、17、20、\u0026hellip;、65是其中的第几项？\n如果项是最后一个也称为求项数\n直接套公式：$$某项的序号 = (某项的数 - 首项) \\div 公差 + 1$$ 公差是3，也就是：(65 - 5) / 3 + 1，65项的序号是：21。\n求和 2、4、6、8、10、12、14，这个数列各项加起来的和是多少？\n分析：\n倒序相加求和\n正序 S = 2 + 4 + 6 + 8 + 10 + 12 + 14 倒序 S = 14 + 12 + 10 + 8 + 6 + 4 + 2 2+14、4+12、6+10，正序和倒序的值加在一起都是相等的，于是可以写成：\n2S = (2 + 14) × 7 S = (2 + 14) × 7 ÷ 2 最终各项加起来的和是：56。\n得出公式，这个公式也称为高斯求和： $$和 = (首项 + 末项) \\times 项数 \\div 2$$\n参考 小学数学—计算之等差数列_哔哩哔哩_bilibili 小学奥数——高斯求和公式，简单问题的再思考 ","date":"2023-09-07T19:05:42+08:00","permalink":"/p/subject/math/sequence/arithmetic/","title":"什么是等差数列？"},{"content":"前言 一开始打算在手机上安装git，想到的是安装app，于是各种找，找到了有如：\nagit MGit \u0026hellip; 但是试过这些app以后发现要么BUG很多，要么根本不能正常使用，而且项目也很久没有更新了，只能另外再找别的app。\n机缘巧合下，让我找到了口袋git（com.aor.pocketgit）的app，正常使用了一段时间，最近再用的时候，频繁出现了Failed to fetch my_project.，没有办法fetch项目，也就没法继续使用了。\n开始我以为是账号密码的认证方式出了问题，于是我尝试换另一种认证方式——私钥，但是它的私钥是.ppk的格式，和ssh生成的密钥不太一样，一轮搜索以后：\n说是需要用到PuTTy的PuTTY Key Generator来对ssh的密码进行转换处理得到.ppk的文件。 按照步骤转换好以后再放到app上，显示了感叹号，感觉不太对劲，进行fetch操作时果然，提示Invalid Private Key. 好家伙，ppk的方式也不行，也不想再试了，那为什么用的好好的账密认证方式出了问题呢？\n我估计是最近github强制使用2FA的关系，登录账号需要经过两步验证，app应该是没有做这个异常处理，而且在app内也没有办法升级。\n于是我放弃了这个app，换了另一条路。\n安装git环境 在逛Stack Overflow时发现了Termux这个app，它是在Android上运行的一个终端软件，也就是直接敲命令在手机上安装git环境。\n打开app，执行以下命令安装：\n1 2 $ apt update $ apt install git 安装完以后，熟悉的操作方式就回来了：\n1 2 $ git --version git version 2.42.0 剩下的就不用多说了，ssh-keygen走一波，下面贴一下我遇到的问题和解决过程。\n操作过程 第一时间就是进入到项目目录，先看看自己在哪个目录：\n1 2 3 4 5 $ pwd /data/data/com.termux/files/home # 然后查看根目录都有些什么 $ ls / ls: cannot open directory \u0026#39;/\u0026#39;: Permission denied 竟然没权限，whoami一看，哦，看来还是root用习惯了，普通用户只拥有/data/data/com.termux目录下的权限，而/data/data之前的目录都没有权限。\n那怎么搞？没有权限我怎么知道我的项目在哪个路径下？？\n熟悉安卓开发的同学或者搞过机的同学就知道，我们在文件管理看到的根目录，是在/storage/emulated/0/下，我也是在折腾了一番以后才得知。\n这么长的路径，不行，我得设置成全局变量才行\n1 2 3 4 5 6 7 8 # 习惯用vim去编辑，其实还有别的方式 $ vim ~/.bash_profile The program vim is not installed. Install it by executing: pkg install vim or pkg install vim-gtk, after running pkg in x11-repo or pkg install vim-python 这里我执行了pkg install vim，然后你懂的。\n然后cd进项目路径，查看配置信息：\n1 2 3 $ git config --list fatal: detected dubious ownership in repository at \u0026#39;/xxx/xxx\u0026#39; To add an exception for this directory, call: git config --global --add safe.directory /xxx/xxx 跟着提示将我们的项目路径设置成安全目录就行。\n1 2 3 $ ssh-keygen -t rsa -C \u0026#34;your@email.com\u0026#34; The program ssh-keygen is not installed. Install it by executing: pkg install openssh 跟着提示执行pkg install openssh，然后遇到连续四个CANNOT LINK EXECUTABLE \u0026quot;ssh-keygen\u0026quot;: library \u0026quot;libcrypto.so.3\u0026quot; not found。\n这里需要执行pkg install openssl安装相关依赖，再重新执行安装命令就可以了。\n1 2 $ git fetch origin CANNOT LINK EXECUTABLE \u0026#34;/data/data/com.termux/files/usr/libexec/git-core/git-remote-https\u0026#34;: library \u0026#34;libssl.so.1.1\u0026#34; not found 解决：\n1 2 3 4 5 6 7 $ find /data/data/com.termux/files -name \u0026#39;libssl.so.*\u0026#39; /data/data/com.termux/files/usr/lib/openssl-1.1/libssl.so.1.1 /data/data/com.termux/files/usr/lib/libssl.so.3 # 如果没有的话，先执行 pkg install openssl1.1-tool # 添加环境变量 echo \u0026#34;export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile \u0026amp;\u0026amp; source ~/.bash_profile 新的问题：\n1 2 3 4 $ git fetch origin fatal unable to access \u0026#39;https://github.com/xxx.git\u0026#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream # 解决： $ git config --global http.version HTTP/1.1 参考 How to use Git on Android? - Stack Overflow 生成Git ssh公钥和私钥（ppk）文件 Termux-setup-storage - Termux Wiki library “libssl.so.1.1“ not found 安卓神器termux使用命令时的报错。_4ustn1ne的博客-CSDN博客 ","date":"2023-08-30T13:26:26+08:00","permalink":"/p/system/android/env/install-git/","title":"在android上安装git环境"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 线性表 概念 特征 基本运算的功能描述 初始化 求表长 读取元素 定位 插入 删除 线性表的顺序存储结构——顺序表 概念 用C语言描述 运算实现的关键步骤和算法 容量 表长 插入 删除 定位 应用 实现简单算法 算法实现的分析 线性表的链式存储结构——单链表 特点和结构 基本概念 头指针 头结点 首结点 尾结点 空链表 用C语言描述 运算实现的关键步骤和算法 插入 删除 定位 综合应用 设计算法解决应用问题 顺序表和链表的优缺点、适用场景 循环链表和双向循环链表 特点和结构 用C语言描述 基本运算 插入 删除 线性表 概念 线性表Linear List是一种线性结构，它是由n（n ≥ 0）个数据元素组成的有穷序列，其中：\n数据元素又称为结点。 这里的n代表线性表的总结点个数，又称为表长。 当表长为0时，也就是线性表没有任何结点，称为空表，用 () 或 Ø 表示。 线性表通常表示成：(A1, A2, A3, ..., An)，其中： A1称为起始结点。 An称为终端结点。 A1是A2的直接前驱，A3是A2的直接后继，其他结点同理。 特征 线性表中结点之间具有一对一的关系。 非空表的情况下： 除了起始结点没有直接前驱（例：A1），其他的结点有且仅有一个直接前驱（例：A2、A3等）。 除了终端结点没有直接后继（例：An），其他的结点有且仅有一个直接后继（例：A1、A2等）。 基本运算的功能描述 以下的no指的是序号，文中所有提到的“位置”都是指序号。\n避免用i命名是怕和数组的下标混在一起，数组的下标是从0开始，而序号是从1开始。\n初始化Initiate(L)：建立一个空表L=()，L不包含任何结点。 求表长Length(L)：返回线性表L的长度，以下简称表L。 读取元素Get(L, no)：返回表L的第no个结点，当no超出Length(L) ≥ no ≥ 1范围，返回一特殊值。 定位Locate(L, x)：返回表L中第一个结点的值等于x值的序号，如果找不到则返回0。 插入Insert(L, x, no) ：两个步骤。 在表L的第no个结点之前插入一个新结点x，no的合法范围：Length(L) + 1 ≥ no ≥ 1。 表长度加1。 删除Delete(L, no)：两个步骤。 删除表L的第no个结点，no的合法范围：Length(L) ≥ no ≥ 1。 表长度减1。 顺序表 概念 顺序存储：将结点依次存放在计算机内存中一组连续的存储单元中，逻辑结构中相邻的结点它的存储位置也相邻。 顺序表：用顺序存储实现的线性表，一般使用数组来表示顺序表。 用C语言描述 假设线性表的数据元素的类型为DataType，顺序表的结构定义如下：\n1 2 3 4 5 6 7 const int Maxsize = 100; // 预先定义一个足够大的常数 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 顺序表的实际长度 } SeqList; // 顺序表类型名为SeqList SeqList L; // 定义L为一个顺序表 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const int Maxsize = 7; // 预先定义数组大小 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 线性表的实际长度 } SeqList; // 顺序表的类型 SeqList student; // student是顺序表的名称 运算 以下相关运算的代码已经整理好，放在了ghjayce/code-example - sequence list中，感兴趣的话可以clone到本地查看运行结果。\n插入 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SeqList insertSeqList(SeqList L, DataType x, int no) { if (L.length \u0026gt;= Maxsize) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;表已满\u0026#34;); exit(EXIT_FAILURE); } // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 2 if (no \u0026lt; 1 || no \u0026gt; L.length + 1) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;插入位置不正确\u0026#34;); exit(EXIT_FAILURE); } for (int i = L.length; i \u0026gt;= no; i--) { L.data[i] = L.data[i - 1]; } L.data[no - 1] = x; L.length++; return L; } 步骤：\n检查插入位置是否合法。 表容量，表满了以后不能再插入。 插入位置： 不能插入序号no = 0及之前的位置，no = 1的位置可以插入。 要插入的位置，它前面的位置不能是空的，也就是不能断开插入。 例：插入第5个位置，第4个位置是空的。 为插入位置腾出空位，从最后一个结点开始从后往前循环，将结点往后移一个位置，直到插入位置结束。 插入新的结点x，也就是序号no的位置，对应下标为：no-1。 表长度加一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n}{2}$。 插入算法中，元素的移动次数不仅与顺序表的长度n有关，还和插入的no位置有关：\n当插入位置是n+1时，移动次数为0。 当插入位置是n时，移动次数为1，这个称为首项（从存在的元素中选取，它也可以是尾项）。 当插入位置是n-1时，移动次数为2。 当插入位置是n-2时，移动次数为3。 \u0026hellip; 当插入位置是1时，移动次数为n，这个称为末项。 根据移动次数变化的规律可以看出：\n比较和移动次数的计算方式为：n - no + 1。 可插入的位置有：n + 1个。 这是个等差数列。 使用高斯求和公式可以得出总的移动次数为：$\\frac{(n + 1) \\times n}{2}$。 因此平均移动次数：$\\frac{总移动次数}{可插入位置}$也就是$\\frac{\\frac{(n + 1) \\times n}{2}}{n + 1}$约为$\\frac{n}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n删除 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 SeqList deleteSeqList(SeqList L, int no) { // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 1 if (no \u0026lt; 1 || no \u0026gt; L.length) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;非法位置\u0026#34;); exit(EXIT_FAILURE); } for (int i = no; i \u0026lt; L.length; i++) { L.data[i-1] = L.data[i]; } L.length--; return L; } 步骤：\n检查删除位置是否合法，不能是0及之前的位置，也不能是超出表长之后的位置。 覆盖结点，从删除位置开始，后一个结点移动到前一个位置，直到最后一个结点结束，即表示删除。 表长度减一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n-1}{2}$。 跟插入算法一样：\n当删除位置是n时，移动次数为0。 当删除位置是n-1时，移动次数为1。 当删除位置是n-2时，移动次数为2。 \u0026hellip; 当删除位置是1时，移动次数为n-1。 根据规律得出：\n移动次数的计算方式：n - no。 可删除的位置有：n个。 同样是等差数列。 使用高斯求和公式得出总的移动次数：$\\frac{(0 + n - 1) \\times n}{2}$。 平均移动次数：$\\frac{总移动次数}{可删除的位置}$也就是$\\frac{\\frac{(0 + n - 1) \\times n}{2}}{n}$约为$\\frac{n-1}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n定位 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 int locateSeqList(SeqList L, DataType x) { int i = 0; // 为了简化运算，这里只比对DataType里的id while ((i \u0026lt; L.length) \u0026amp;\u0026amp; (L.data[i].id != x.id)) { i++; } if (i \u0026lt; L.length) { return i + 1; } return 0; } 步骤：\n初始化一个下标值：0。 从头到尾逐个比对，数组中的结点是否与结点x相等： 不相等则继续循环。 相等则表示已经找到，停止循环。 返回查找结果。 表长 只需要返回L.length即可\n链表 概念 链表的结点：由数据域（数据元素）和指针域或者叫链域（表示数据元素之间的逻辑关系）组成。 数据域：相当于火车厢。 指针域：相当于连接火车厢的车钩。 链式存储：各个结点在内存中的存储位置并不一定连续，逻辑结构中相邻的结点其存储位置不一定相邻。 链表：用链式存储实现的线性表，所有结点通过指针链接形成链表Link List，结点之间可以重新链接。 单链表：每个结点由一个数据元素和一个指向下一个结点（后继结点）的next指针构成。 循环链表：单链表的基础上，尾结点的指针指向首结点。 双向循环链表：循环链表的基础上，每个结点增加一个指向上一个结点（前驱结点）的prio指针。 组成介绍： head：头指针变量，有两个作用： 它的值指向链表的第一个结点。 也可以用来命名链表，例如下图链表称为：表head、head表。 首结点：链表中第一个数据元素结点。 尾结点：也称终端结点，指链表中最后一个数据元素结点。 空指针：尾结点的指针域的值为NULL。 空链表：head等于NULL，表示链表无任何结点。 头结点：为了方便运算，在首结点之前增加一个相同类型的结点，如图C)。 表结点：除了头结点以后的结点。 用C语言描述 1 2 3 4 5 6 7 8 typedef struct node { DataType data; struct node *next; } Node, *LinkList; // Node，*LinkList都是结构体的别名，其中 // Node是指向struct node类型的别名 // *LinkList是指向Node类型的指针的别名 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct node { DataType data; // 数据域 struct node * next; // 指针域 } Node, *LinkList; // Node是链表结点的类型 LinkList head; // 定义一个全局变量，head是链表的名称 运算 以下相关运算的代码已经整理好，放在了ghjayce/code-example - link list中，感兴趣的话可以clone到本地查看运行结果。\n初始化 1 2 3 4 5 6 7 LinkList initLinkList() // 建立一个空的单链表 { LinkList head; // 定义局部变量，头指针 head = malloc(sizeof(Node)); // 动态构建一结点，它是头结点 head-\u0026gt;next = NULL; return head; } 步骤：\n基于LinkList结构，构建一个名为head的单链表。 通过给head分配内存、设置属性，此时head是一个头结点，next指针为NULL，表示链表为空。 返回这个链表的头结点。 求表长 1 2 3 4 5 6 7 8 9 10 11 12 int lengthLinkList(LinkList head) // 求单链表head的长度 { // 声明一个指向Node对象的名为point的指针变量，它指向head的头结点 Node *point = head; int count = 0; while (point-\u0026gt;next != NULL) { point = point-\u0026gt;next count++; } return count; } 步骤：\n指向head表的头结点。 初始化count计数。 从head头结点开始，检查头结点的下一个结点，也就是首结点： 结点不为空，此时point变成首结点，计数+1，依次往后检查下一个结点是否为NULL。 结点为NULL结束循环。 返回表长。 读取元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Node *getLinkList(LinkList head, int no) // 读取序号为第no个结点，读到返回结点 { Node *point; point = head-\u0026gt;next; int position = 1; while (point != NULL \u0026amp;\u0026amp; position \u0026lt; no) { point = point-\u0026gt;next; position++; } if (position == no) { return point; } return NULL; } 步骤：\n声明point指针变量，指向head表的首结点。 初始化position，也就是从第一个结点（位置1）开始查找。 检查point结点不能是空的，并且position要小于查找的no。 符合条件，表示还没找到，此时point变成下一个结点，position+1，重复步骤3。 不符合条件，结束循环，分为两种情况，可能遍历完整个链表都没找到或者提前找到了。 判断position是否等于no序号： 相等，表示已经找到，返回point结点。 不相等，表示没有找到，返回NULL值。 定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int locateLinkList(LinkList head, DataType x) // 在head表中找到第一个符合x结点的序号 { Node *locateNode; locateNode = head-\u0026gt;next; int no = 1; while (locateNode != NULL \u0026amp;\u0026amp; locateNode-\u0026gt;data != x) { locateNode = locateNode-\u0026gt;next; no++; } if (locateNode == x) { return no; } return 0; } 关键点：\n从首结点开始，当前结点不为空并且不等于要查找的值则继续检查下一个结点： 如果提前找到结点locateNode，循环结束。 如果遍历完链表依然没找到，locateNode等于尾结点，循环结束。 比对locateNode和x： 相等，就是找到了，返回locateNode所在的序号。 不相等，也就是没找到，返回0。 插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList insertLinkList(LinkList head, DataType x, int no) { Node *queryNode, *newNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL) { printf(\u0026#34;插入位置有误\u0026#34;); exit(EXIT_FAILURE); } newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = queryNode-\u0026gt;next; queryNode-\u0026gt;next = newNode; return head; } 关键点：\n找到要插入位置的前驱结点query： 生成一个新的结点newNode，按照Node结构分配内存。 newNode的next要指向query的next，数据域赋值为x也别忘了。 query的next指向newNode。 注意如果插入的位置为1，要做处理，避免取一个非法的前驱结点。 要对查找插入位置的结果做处理。 1.2和1.3的步骤不能调换，必须严格执行，不然会丢失query的next结点。 删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList deleteLinkList(LinkList head, int no) { Node *deleteNode, *queryNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL || queryNode-\u0026gt;next == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;删除的位置错误\u0026#34;); exit(EXIT_FAILURE); } deleteNode = queryNode-\u0026gt;next; queryNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); return head; } 关键点：\n和插入有点类似，也得先找到要查删除位置的前驱结点query，当然也要注意非法前驱的处理。 要对查找删除位置的结果做处理。 要删除的结点放到临时变量存起来，目的用于free释放内存空间。 把前驱结点query的next指向删除结点的next即可，如果删除结点是尾结点，那么query的next就是NULL。 创建 为了方便后续算法演示，这里用一个数组来构建单链表，再简化一下DataType的属性：\n1 2 3 4 5 6 int nums[6] = {4, 7, 2, 5, 2, 4}; typedef struct { int age; } DataType; 结合以上已实现的算法initLinkList()和insertLinkList()，实现一个创建链表的算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 LinkList createLinkListByEach(int *arr, int size) { LinkList point = initLinkList(); for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; insertLinkList(point, item, i+1); } return point; } // 调用 // 为了方便展示直接写6，size自动计算：sizeof(nums) / sizeof(nums[0]) createLinkListByEach(nums, 6); 缺点：每次插入结点都要遍历一次链表。\n尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList createLinkListByTailInsert(int *arr, int size) { LinkList head; Node *lastNode, *newNode; head = malloc(sizeof(Node)); lastNode = head; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; lastNode-\u0026gt;next = newNode; lastNode = newNode; } lastNode-\u0026gt;next = NULL; return head; } 优点：每次插入新结点都能从尾结点进行而不需要每次遍历整个链表。\n头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList createLinkListByHeadInsert(int *arr, int size) { LinkList head; Node *newNode; head = malloc(sizeof(Node)); head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; newNode-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = newNode; } return head; } 与尾插法算法一样，只是插入新结点是从头结点进行，最终链表的顺序与尾插法相反。\n删除重复结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 LinkList removeRepeatLinkList(LinkList head) { Node *searchNode; // 要查找的结点 Node *checkNode; // 要检查（比对）的结点 Node *deleteNode; // 要删除的结点 searchNode = head-\u0026gt;next; // 从首结点开始 while (searchNode != NULL) { // 关键，从首结点开始，循环检查当前结点的下一个结点 checkNode = searchNode; while(checkNode-\u0026gt;next != NULL) { if (searchNode-\u0026gt;data.age == checkNode-\u0026gt;next-\u0026gt;data.age) { deleteNode = checkNode-\u0026gt;next; checkNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); } else { checkNode = checkNode-\u0026gt;next; } } searchNode = searchNode-\u0026gt;next; } return head; } 关键点：\n从首结点开始遍历，取它的值与下一个结点的值进行比较，找到相等的值进行删除。 checkNode=searchNode; while(checkNode-\u0026gt;next != NULL)是关键之一。 其他链表 循环链表 带尾结点访问首结点的表示方式：rear-\u0026gt;next-\u0026gt;next，运算与单链表类似，不再赘述。\n双向循环链表 用类C语言来描述：\n1 2 3 4 5 6 7 struct dbnode { DataType data; struct dbnode *prior, *next; } typedef struct dbnode *dbpointer; typedef dbpointer DLinkList; 双向循环链表和单链表的运算差不多，主要提一下删除和插入运算的差异。\n删除算法的关键点：\n1 2 3 removeNode-\u0026gt;prior-\u0026gt;next = removeNode-\u0026gt;next; removeNode-\u0026gt;next-\u0026gt;prior = removeNode-\u0026gt;prior; free(removeNode); 第1行和第2行代码顺序颠倒也可以，不影响最终效果。\n插入算法的关键点：\n1 2 3 4 newNode-\u0026gt;prior = query; newNode-\u0026gt;next = query-\u0026gt;next; query-\u0026gt;next-\u0026gt;prior = newNode; query-\u0026gt;next = newNode; 注意query是指插入位置的前驱结点，以及这些语句的顺序。\n先接好新结点的prior和next指针的指向。 再将插入位置结点的prior指针指向新结点。 最后将query结点的next指针指向新结点。 顺序表和链表的比较 异同 存储方式： 顺序表： 使用连续的内存空间来存储结点。 需要预先分配存储空间，存储结点个数有上限。 链表： 结点由数据元素和指针组成，指针指向下一个结点，存储在内存空间连不连续都可以。 不需要预先分配存储空间，存储结点个数没有上限。 访问效率： 顺序表： 能根据索引快速定位结点，时间复杂度O(1)。 读取结点支持随机访问。 链表： 只能通过遍历链表，从头到尾逐个遍历查找目标结点，时间复杂度O(n)。 读取结点不支持随机访问。 运算（插入和删除）： 顺序表： 插入和删除需要移动后续的结点，以保证结点之间的连续性。 插入和删除操作之前需要查找定位，时间复杂度O(n)。 链表： 插入和删除只需要修改结点之间指针的指向关系，不需要移动结点。 跟顺序表一样需要查找定位，时间复杂度也是O(n)。 优缺点 顺序表： 优点： 随机访问效率高。 缺点： 插入和删除的操作代价高。 需要预先分配一块连续的内存空间。 存储结点个数有上限。 链表： 优点： 插入和删除的操作代价低。 对内存空间控制动态且灵活。 存储结点个数没有上限（取决于可用内存空间）。 缺点： 不支持随机访问。 相对要占用多一些内存空间来存放指针域。 适合场景 根据上面的优缺点可得知：\n顺序表：更适合读多写（插入和删除）少的场景。 链表：更适合写多读少的场景。 综合应用 待补充\u0026hellip;\n","date":"2023-08-29T14:46:12+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter2/","title":"第二章 线性表 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 本书 书名：《数据结构导论》 出版：外语教学与研究出版社 版本：2012年版 全书以类C语言来描述相关内容，例如：存储结构、算法等。 本文涉及知识点 数学知识 乘法分配率 对数 等差数列、高斯求和 概要 数据、数据元素和数据项 基本概念 三者的关系 数据的逻辑结构和存储结构 四种基本的逻辑结构和特点 集合 线性结构 树形结构 图结构 两种基本的存储结构 顺序存储 链式存储 逻辑结构与存储结构的关系 运算与逻辑结构的关系 算法分析 描述方法 评价因素 时间复杂度的分析方法 空间复杂度的分析方法 数据、数据元素和数据项 概念和联系 数据项：在数据表中指的是一个个的字段，又称字段或域，数据的最小标识单位。 数据元素：在数据表中相当于一行记录，又称结点，由若干个数据项组成。 数据：被计算机处理、存储的对象，由若干个数据元素组成。 数据的逻辑结构和存储结构 概念 数据结构：包含数据的逻辑结构、存储结构和基本运算。 逻辑结构：整个数据元素之间的逻辑关系。 逻辑关系：指单个数据元素之间的关联方式或邻接关系，也就是单个数据元素之间的组织形式。 存储结构：也称物理结构，数据的逻辑结构在计算机中的实现称为数据的存储结构。 简单点说：为了保存数据的逻辑结构到计算机中而实现的存储结构。 逻辑结构 四类基本的逻辑结构：\n集合：任意两个结点之间都没有邻接关系，组织形式松散，就像抽奖箱里的乒乓球。 结点之间除了同属一个集合，并没有别的关系。 线性结构：结点之间一个个依次相邻接排列，形成一条“链”，就像一条绳子上的多个绳结。 结点之间是一对一的相互关系。 树形结构：上层结点有多个下层结点，下层结点只有一个上层结点，具有分支、层次特性，就像一颗树。 结点之间是一对多的相互关系。 图结构：最为复杂的结构，任意两个结点都可以相邻接，就像地铁线路图、人与人之间的社交网络。 结点之间是多对多的相互关系。 存储结构 存储结构一般包括两个部分：\n需要存储的数据元素 结点之间的逻辑关系 实现结点之间的逻辑关系的存储结构，一般有四种形式，主要掌握顺序存储和链式存储：\n顺序存储：所有结点存储在一个连续的存储区域里，利用结点在存储器中的相对位置，来表示结点之间的逻辑关系。 链式存储：除了存储结点本身，还需要一个指针，指针指向有逻辑关系的结点，也就是利用指针表示结点之间的逻辑关系。 索引存储 散列存储 如何描述 怎么描述存储结构是哪种类型？哪种实现形式呢？分为两种方式：\n机器级：即存储结构在计算机存储器里的表示形式，以内存地址的方式。 语言级：即用程序设计语言中的类型说明、变量说明，例如，数据类型：数组、结构体和指针等。 运算 概念 运算是指在逻辑结构上施加的操作，也就是对逻辑结构的加工。\n这些运算操作包括：\n建立 查找 读取 插入 删除 等\u0026hellip; 算法分析 评价算法 评价算法好坏的因素分为几个方面：\n正确性：能正确地实现预定的功能，满足具体问题的需要。 易读性：易于阅读、理解和交流，便于调试、修改和扩充。 健壮性：能处理不同的输入环境，即使是非法数据，也不会产生预料不到的运行结果。 时空性：指算法的时间性能（所需计算量）和空间性能（所需存储量）。 时间复杂度 计算量 来算一算函数执行了几次\n例子A：\n1 2 3 4 5 int func1(void) { printf(\u0026#34;hello ghjayce\u0026#34;); return 0; } 共执行了2次，printf1次 + return1次\n例子B：\n1 2 3 4 5 6 7 int func2(int n) { for (int i = 0; i \u0026lt; n; ++i) { printf(\u0026#34;hello ghjayce\u0026#34;); } return 0; } 共执行了3n + 3次\n分析过程：\nint i = 0，由始至终仅会执行1次。 i \u0026lt; n，执行n + 1次。 ++i，执行n次。 printf，执行n次。 return，执行1次。 要估算某段代码的执行次数，可以用T(n)来表示：\nT：某段代码的总执行次数。 n：输入数据的规模大小或者数量。 也就是一个算法的计算量是问题规模n的函数，代入以上例子来表示：\n例子A：T(n) = 2 例子B：T(n) = 3n + 3 转换 得出代码的执行次数估算值后，需要转换成时间复杂度的表示方式，以下是转换规则：\n如果T(n)是常数的话，时间复杂度直接估算为 1。 如果T(n)不是常数的话，例如：常数 × n + 常数 仅保留最高次项，也就是常数 × n 常数化为1，也就是1 × n，这里的系数可以直接省略。 因此时间复杂度估算为：n。 表达方式还不完整，需要加上大O表示法，也称渐进表示法，例如：O(时间复杂度估算值)\n结合以上例子，那么时间复杂度表示为：\n例子A：O(1) 例子B：O(n) 如果代码量比较多或者函数调用比较多的情况下这样估算会相当麻烦，所以下面是简化估算过程：\n例子C：\n1 2 3 4 5 6 7 8 void func3(int n) { for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { printf(\u0026#34;hello ghjayce\u0026#34;); } } } 分析过程：\n里面的for循环的时间复杂度：n + 1 这里for的时间复杂度：n for里面的语句的时间复杂度：1 外面的for循环的时间复杂度：(n + 1) × n，也就是(n × n) + (n × 1)，即n² + n 最终时间复杂度为：O(n²)\n例子D：\n1 2 3 4 5 6 7 8 void func(int n) { for (int i = 0; i \u0026lt; n; ++1) { for (int j = i; j \u0026lt; n; ++j) { printf(\u0026#34;hello ghjayce\u0026#34;); } } } 最终时间复杂度为：O(n²)，待补充\u0026hellip;\n例子E：\n1 2 3 4 5 6 void func(int n) { for (int i = 1; i \u0026lt; n; i *=2) { printf(\u0026#34;hello ghjayce\u0026#34;); } } 最终时间复杂度为：O(logn)，待补充\u0026hellip;\n性能对比 常数阶：O(1) 对数阶：O(log2n)，log的底数可以省略不写，也就是：O(logn)，下面也是一样 线性阶：O(n) 线性对数阶：O(nlogn) 多项式阶：O(nc)，C为大于1的正整数，下面也是一样 平方阶：O(n²) 立方阶：O(n3) K次方阶：O(nk) 指数阶：O(Cn)，常见是O(2n) 以上时间复杂度，复杂程度和耗时从上往下依次增加，即越往下时间复杂度越高，所需耗时越多。\n通常认为，具有指数阶的算法是不可计算的，而阶数低于平方阶的算法是高效率的。\n另外，时间复杂度的性能还会受到输入数据的变化而有所影响，基于相同输入数据量的不同输入数据，分为：\n最坏时间复杂度：算法时间用量的最大值。 平均时间复杂度：算法时间用量的平均值。 空间复杂度 一个算法的空间复杂度定义为该算法所耗费的存储空间，它也是问题规模n的函数，记为： $$S(n)=O(g(n))$$ 其中，g(n)为问题规模n的某个函数。一个算法在执行期间所需的存储空间量分为：\n程序代码所占用的空间，对不同算法来说也不会有数量级的差别。 输入数据所占用的空间，由问题规模决定的，不随算法的不同而改变。 辅助变量所占用的空间，也称附加存储空间，它所占用的空间会受到问题规模和不同的算法所影响。 来个例子实践一下，假设，n=100。\n例子A：\n1 2 3 4 5 6 7 8 9 void f1(int a[], int n) { int i, temp; for (i = 0; i \u0026lt;= n/2; i++) { temp = a[i]; a[i] = a[n-1-i]; a[n-1-i] = temp; } } f1所需要的辅助变量为2个整型变量i和temp，与问题的规模无关，空间复杂度为：O(1)。\n例子B：\n1 2 3 4 5 6 7 8 void f2(int a[], int n) { int i, b[100];//随n的大小 for (i = 0; i \u0026lt;= n-1; i++) b[i] = a[n-1-1]; for (i = 0; i \u0026lt;= n-1; i++) a[i] = b[i]; } f2所需要的辅助变量为1个整型变量i和随n大小的数组b，b与问题的规模有关，空间复杂度为：O(n)。\n如果是递归调用呢？\n待补充\u0026hellip;\n参考 指数和对数 小学生也能看懂的时间复杂度 小学速算技巧15讲：简便计算，认知乘法分配率 ","date":"2023-08-20T16:36:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"/p/book/080901/02142/chapter1/","title":"第一章 概论 - 《数据结构导论》笔记"},{"content":"前言 开头废话有点多，点我进入正题\n为什么想要搭建一个博客？ 说起来有很多方面的因素，最重要的目的是希望能够留下一些技术积累和记录可以给别人看，同时提升一下写作的能力，毕竟与平时记笔记的方式完全不同。\n虽然也没有什么人看🤷\n其实在此之前也有写过博客，比如早期使用heroku + php搭建的个人博客，因为需要不断开发完善功能，加上后来也不免费了，索性不折腾直接上博客网站上写博客，如：CSDN、Segmentfault等。\n但这些平台使用下来以后也发现了一些问题，总的来说就是不适合自己的使用，写文章的过程也不够简洁直接，不够纯粹。\n我理想中的博客是什么？ 专注于markdown的编写 支持全文检索 具有标签功能 能够归档文章 免费 支持永久存储 为什么选择了hugo？ 查阅资料得知，静态站点生成器有三种提的比较多，分别是：\njekyll，基于Ruby语言编写 hexo，基于Node.js编写 hugo，基于Go语言编写 之所以选择hugo，它是当中编译速度最快、文档相对友好、star数量还多，正好无意间找到Hugo Themes的主题，很好的契合了需求，就决定是它了。\n阅读前提 本文默认你已经掌握了以下的几个点：\n了解github pages并且会配置 熟悉使用git 通过该文章可以快速上手使用hugo，所以有一些内容不会详细展开。\n快速入门 安装Hugo 这里我用的是Mac系统，所以采用Homebrew的方式进行安装，其他安装方式自行查阅。\n1 2 brew install hugo hugo version 创建项目 1 2 3 hugo new site your-project-name cd your-project-name git init 由于我已经有git项目ghjayce.github.io，里面没有任何东西，所以这里我使用了hugo new site ghjayce --force，既不影响hugo的生成又不影响git的项目。\n执行完以后，你会得到以下的目录结构：\n1 2 3 4 5 6 7 8 9 ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── layouts ├── static └── themes 安装主题 由于新建的项目没有默认主题，我们从主题库把挑好的主题下载下来。\n1 2 3 4 5 6 git clone git@github.com:CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack cp -r ./themes/hugo-theme-stack/exampleSite/content/* ./content cp ./themes/hugo-theme-stack/exampleSite/config.yaml ./hugo.yaml rm -f ./hugo.toml # 以下是示例主题需要操作的命令，避免没有翻墙的情况下启动不了项目 rm -rf ./content/post/rich-content 站点配置文件为hugo.toml，支持三种后缀的格式：toml、yaml、json，这里我选择用yaml\nHello World 生成一篇文章。\n1 2 # 对应的生成位置：/your-project-name/content/post/first-post.md hugo new post/first-post.md 打开它写点内容。\n1 2 3 4 5 6 7 --- title: \u0026#34;First Post\u0026#34; date: 2023-06-20T17:45:58+08:00 draft: true --- # hello world 启动 1 2 # 执行成功以后，终端会出现server的地址，例如：http://localhost:1313/ hugo server --buildDrafts --buildDrafts的作用是草稿文章（对应文章中的draft: true属性）也进行生成，去除的话会跳过生成草稿。\n构建\u0026amp;发布 1 hugo 你会看到多出一个public目录，就是构建好以后的内容，里面的内容完全是静态的，放到站点下就能够访问。\n但是我们要发布到github page上，根目录只支持/docs，所以我们得把public改成docs，有两种方式：\n构建时加上参数：hugo --destination docs 在配置文件中加入参数：publicDirectory: docs 如果仓库只放public目录下的内容，那么可以忽略这里。\n版本说明 文中相关软件版本说明：\nhugo：v0.113.0 hugo-theme-stack：v3.16.0 参考 Quick Start | Hugo URL management | Hugo ","date":"2023-06-20T23:46:50+08:00","image":"https://ghjayce.github.io/asset/blog/hYbelawEIwhaejxWE2RNMjAyNDAyMjVfMTU1NTA2.png","permalink":"/p/static-site-generator/hugo/quick-start/","title":"hugo快速上手搭建一个静态博客"},{"content":"环境：\nwin7 x64 powershell v2.0（查看版本 $PSVersionTable） 搭建Homestead步骤 使用Virtualbox 1. 安装 Virtual Box Virtual Box 官方下载\n2. 安装 Vagrant Vagrant 官方下载\n使用VMware 待\u0026hellip;\n3. 在Vagrant中安装 运行下面命令\n1 $ vagrant box add laravel/homestead 选择3 virtualbox\n1 2 3 4 5 6 7 8 9 10 ==\u0026gt; box: Loading metadata for box \u0026#39;laravel/homestead\u0026#39; box: URL: https://vagrantcloud.com/laravel/homestead This box can work... 1) hyperv 2) parallels 3) virtualbox 4) vmware_desktop $ Enter your choice: 3 # step 2 下载速度慢，可换其他下载器下载 右键复制链接地址\n下载好后，运行命令进行安装\n1 $ vagrant box add laravel/homestead /path/to/virtualbox.box 4. 安装Homestead 1 2 $ git clone https://github.com/laravel/homestead.git Homestead $ cd Homested 切换到稳定版本，homested 发行版\n1 2 $ git checkout v7.1.2 $ init.bat 5. 初始化Homestead 修改文件homestead.yaml\n1 2 folders: - map: ~/code # 替换为项目路径 6. 修改hosts C:\\Windows\\System32\\drivers\\etc\\hosts\n追加如下内容\n1 192.168.10.10 homestead.test 7. 启动Homestead 1 $ vagrant up 出现如下错误：\n1 2 3 The version of powershell currently installed on this host is less than the required minimum version. Please upgrade the installed version of powershell to the minimum required version and run the command again. 需要更新powershell至5.x https://docs.microsoft.com/en-us/powershell/wmf/5.1/install-configure\n等待初始化完成后，访问 http://homestead.test\n启动后修改homestead.yaml文件需要更新服务\n1 $ vagrant reload --provision 停止服务\n1 $ vagrant halt 参考 查看手册 - Laravel Homestead 5.6 Homestead 2.0 安装笔记 - Summer Composer 安装时要求输入授权用户名密码？ ","date":"2018-10-06T20:40:41+08:00","image":"https://ghjayce.github.io/asset/blog/acN7lrfIQy4GU6zANY9bMjAxODEwMDZfMjA0MDQx.jpeg","permalink":"/p/language/php/laravel/homestead-install/","title":"Homestead环境搭建"},{"content":"Guilloche图形欣赏：\n最终我做的几个图形：\n制作方法 旋转复制法 画布大小建议大一点，这样做出来的图形会清晰很多。\n我的画布大小是 1920*1080 分辨率：72\n制作效果参考上面的第二个图形步骤，其他图形的制作类似。\nStep 1 画一个正圆和一个正五边形\nStep 2 栅格化刚才画的两个图层\nStep 3 按住Shift选择正圆和正五边形图层，接着按Ctrl + Alt + E合并成一个新的图层。隐藏正圆和正五边形图层。\nStep 4 复制多一个图层。按Ctrl + T自由变换，在角度一栏随意填上角度值。\nStep 5 关键操作：按Ctrl + Shift + Alt + T组合键，多按几次形成一个圈为止。就能得到下图。\n最终的图形会有很多个图层，要保留成一个图层可以合并成单独一个，快捷键是：Ctrl + E\n参考 Illustrator绘制Guilloche钱币底纹图形 ","date":"2018-05-31T11:03:31+08:00","image":"https://ghjayce.github.io/asset/blog/4voHlngN1tpz7QP16wP2MjAxODA1MzFfMTEwMzMx.jpeg","permalink":"/p/visuals/graph/guilloche/","title":"3秒钟制作一个复杂的Guilloche图形"},{"content":"安装apache 1 $ yum install httpd -y 启动apache 1 $ systemctl start httpd.service 查看是否开启成功 1 2 3 4 5 6 7 8 [root@centos7-1 ~] $ ps -ef|grep httpd root 1739 1 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND apache 1740 1739 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND apache 1741 1739 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND apache 1742 1739 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND apache 1743 1739 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND apache 1744 1739 0 18:34 ? 00:00:00 /usr/sbin/httpd -DFOREGROUND root 1749 1112 0 18:37 pts/0 00:00:00 grep --color=auto httpd 查看apache端口 1 $ netstat -lntup|grep httpd 修改hosts解析 1 $ vi /etc/hosts 改成如下内容\n1 192.168.56.101 centos7.com www.centos7.com bbs.centos7.com blog.centos7.com 测试访问 1 $ curl www.centos7-1.com 配置apache 备份文件 1 $ cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.back 配置httpd文件 因为在apache2.4中变化挺大，和nginx一样，可以自定义.conf文件。\n在主配置文件中启用虚拟主机\n1 2 3 $ mkdir /etc/httpd/vhost.d/ $ echo \u0026#34;include vhost.d/*.conf\u0026#34; $ tail -1 /etc/httpd/conf/httpd.conf 配置多站点目录 1 $ vi /etc/httpd/vhost.d/name.conf 写入下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin admin@amsilence.com DocumentRoot \u0026#34;/var/html/www\u0026#34; ServerName www.centos7.com ErrorLog \u0026#34;/var/httpd/logs/www-error_log\u0026#34; CustomLog \u0026#34;/var/httpd/logs/www-access_log\u0026#34; common \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory /var/html/www/\u0026gt; Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin admin@amsilence.com DocumentRoot \u0026#34;/var/html/bbs\u0026#34; ServerName bbs.centos7.com ErrorLog \u0026#34;/var/httpd/logs/bbs-error_log\u0026#34; CustomLog \u0026#34;/var/httpd/logs/bbs-access_log\u0026#34; common \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory /var/html/bbs/\u0026gt; Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin admin@amsilence.com DocumentRoot \u0026#34;/var/html/blog\u0026#34; ServerName blog.centos7.com ErrorLog \u0026#34;/var/httpd/logs/blog-error_log\u0026#34; CustomLog \u0026#34;/var/httpd/logs/blog-access_log\u0026#34; common \u0026lt;/VirtualHost\u0026gt; \u0026lt;Directory /var/html/blog/\u0026gt; Require all granted \u0026lt;/Directory\u0026gt; 重启Apache服务 1 $ systemctl restart httpd.service 测试web访问 1 2 3 4 [root@centos7-1 httpd] $ for name in www bbs blog;do curl $name.centos7.com;done; http://www.centos7.com http://bbs.centos7.com http://blog.centos7.com 参考 Apache 2.4.6 多域名多网站配置 原文链接：centos7.2 利用yum安装配置apache2.4多虚拟主机 ","date":"2018-04-30T10:51:03+08:00","image":"https://ghjayce.github.io/asset/blog/qfHDW8fltBrGpL2TeHDSMjAxODA0MzBfMTA1MTAz.jpeg","permalink":"/p/system/linux/env/apache-site-more/","title":"centos7 安装Apache2.4配置多站点目录"},{"content":"文章内容为个人的学习笔记，绝大部分内容摘抄自书本中的知识点，目录也是如此。仅供各位学习参考，另外备注书本是2017年版。\n阅读说明 较早前记的笔记，内容并不全，请选择性浏览\n操作系统简介 操作系统的作用 为用户使用的应用程序的运行提供了环境，并且为应用程序的开发提供了平台，使应用程序的开发变得简单、高效。\n用户与硬件之间的接口 操作系统提供了计算机用户与计算机硬件之间的接口，分别是硬件接口和软件接口。\n软件接口：如C语言的函数 print 硬件接口：如usb接口、串口、并口 资源的管理者 处理机管理 程序的执行必须依靠处理机，任意时刻处理机都只能执行一个程序流； 要使处理机执行多个程序流，就必须由操作系统的处理机调度程序来管理处理机的分配，让多个程序共享处理机； 从宏观角度来看，使得多个程序能“同时”顺利进行。\n内存管理 如何为多个应用程序分配内存，并使应用程序的地址空间互不干扰，并在程序执行完毕后，回收所占用的内存，释放内存空间，并且完成逻辑地址到物理地址的转换，是操作系统内存管理程序的要完成的功能。\n设备管理 设备管理的任务是要接受用户的I/O请求，为用户分配I/O设备，管理I/O缓存和驱动等功能。\n文件管理 计算机把大量需要长时间存储的数据信息以文件的方式存放在外存设备中（如硬盘、USB、光盘、磁带）。 操作系统的文件管理程序，任务是要管理外存设备的空间分配、回收，文件的存取、共享、组织和保护等功能。\n操作系统的发展 1 2 3 4 5 s=\u0026gt;start: 无操作系统 o1=\u0026gt;operation: 单道批处理系统 o2=\u0026gt;operation: 多道批处理系统 s(right)-\u0026gt;o1(right)-\u0026gt;o2 单道批处理系统 特点：\n自动性 自动将作业从外存装入内存运行，当作业运行完毕后，自动撤销已运行完毕的作业，依次从外存装入下一个作业。 顺序性 存放在外存的作业，会按顺序的依次装入内存运行，先进入内存的作业先运行完毕。 单道性 任何时刻内存只能有一道作业，操作系统每次只能装入一个作业到内存运行，直到作业正常或异常结束，才会装入下一个作业到内存。 缺点： 作业独占CPU、内存，CPU资源严重浪费，不能充分利用。\n与无操作系统相比，单道批处理系统减少了长时间等待人工操作的时间\n多道批处理系统 特点：\n调度性 从作业队列中选择要装入到内存运行的单个作业或多个作业 无序性 同时驻留在内存的作业，获得CPU的顺序和执行的进度无法预知，先进入内存的作业，不一定先被调度，也不一定先执行完。 多道性 在内存中可同时驻留多道程序 复杂性 缺点：\n平均周转时间长 周转时长指的是从作业交到系统开始到作业完成为止的时间 缺乏交互能力 在作业运行结束得到输出结果之前，用户无法观察和控制作业的运行。 与单道批处理系统相比，提高了资源的利用率，系统的吞吐量。\n分时系统 分时系统是多道批处理系统的自然延伸。允许多个终端用户同时使用计算机。\n特点：\n多路性 一台主机上同时连接多台联机终端。 独立性 终端用户操作彼此独立，互不干扰。 及时性 用户请求在很短的时间内能得到响应。 交互性 用户可以通过终端与系统进行广泛的人机对话。 优点：为用户提供了人机交互的方便性，使多个用户通过不同的终端共享主机。\n实时系统 实时系统主要用于实时控制和实时信息处理领域。\n特点：\n多路性 独立性 及时性 交互性 可靠性 主流操作系统 主机操作系统 主机操作系统是运行在大型主机上的操作系统，主要提供三种服务：批处理、事务处理和分时处理。\n批处理 批处理系统处理不需要交互式用户干预的周期性作业。 如：保险公司的索赔处理或者连锁商店的销售报告，通常以批处理的方式完成。 事务处理 事务处理系统负责大量的小请求。 如：银行的支票处理或航班预订。业务量小，但是需要很高的处理速度。 分时处理 分时系统允许多个远程用户同时在计算机上工作，执行命令或处理作业。 服务器操作系统 服务器操作系统是运行在网络服务器上的操作系统，可以通过网络同时为众多用户服务。服务器可提供打印服务、文件服务、Web服务。\n典型的服务器操作系统有：Linux、Windows Server 200X、Solaris、FreeBSD\n微机操作系统 也称个人机操作系统，现代微机操作系统都支持多道程序处理，就是通常所说的支持多任务。\n常见的微机操作系统有：Windows系列、Linux的不同发行版、Macintosh、Chrome OS等\n嵌入式操作系统 嵌入式系统的概念出现在20世纪70年代，是宿主于非计算机设备中的计算机系统。\n其特征是：小巧、实时性、可装卸、代码固化、弱交互性、强稳定性、接口统一、低能耗 应用领域：掌上电脑、智能手机、数码相机、自动售货机、自动取款机、工业控制设备、军工装备、游戏机、医疗设备、网络设备等\n现代操作系统的特点特征 小节只需要达到“领会”层面\n现代操作系统都支持多任务，具有并发、共享、虚拟和异步性特征。\n并发 并发指两个或多个事件在同一时间间隔内发生。注意，是同一时间间隔。\n并行指的是多个事件同时发生。\n如：在一台单CPU单核的电脑中，一边听音乐，一边玩扫雷，扫雷程序在工作的同时音乐程序也在工作。但是，在单CPU单核系统中，任意时刻只能有一个程序流在CPU上执行，之所以用户感觉到两个程序似乎在同时工作，互不干扰，是因为操作系统使两个程序在CPU上快速地轮流交替执行，实现了“并发”的功能。\n共享 共享是指系统中的资源可供内存中多个并发执行的进程共同使用。资源共享有两种方式，互斥共享和同时共享。 互斥共享是指任意时刻，一种资源只能被一个进程访问。 当一个进程访问资源时，其他进程必须等待，直到资源被进程访问完毕，释放访问权。 如：打印机不采取互斥访问，可能会有多个进程的输出内容都打印在同一张纸上。\n并发与共享的关系是相互依赖的。 如果系统不支持并发，资源的使用都是独占的，不需要共享资源。 如果不能实现有效的资源共享，并发就不能得到很好的支持\n虚拟 虚拟是指通过某种技术把一个物理实体变成若干逻辑上的对应物。 物理实体是实际存在的，而虚拟仅仅是用户感觉到的。\n如虚拟打印机、虚拟内存和虚拟CPU等。 操作系统通过某种技术把少量的物理资源变成较物理资源多的逻辑资源。\n异步性 进程以不可预知的速度向前推进。内存中的每个程序何时执行，何时暂停，以怎样的速度向前推进，程序需要花费多少时间才能完成，都是不可预知的。 系统中什么时候会出现需要特殊处理的事件？\n如键盘中断，突然打不了字；鼠标中断等也是随机、不可预知的。\n操作系统的功能 分别有存储器管理、进程管理、设备管理、文件管理等功能，以及操作系统提供的用户接口。\n内存管理 内存管理应具有内存分配、内存保护、地址映射、内存扩充功能。\n进程管理 进程的描述 摘取**《现代操作系统》作者Andrew S. Tanenbaum对进程和程序的关系**给出的一段非常生动形象的比喻。\n一位计算机科学家正在为她的女儿烘制生日蛋糕。他有制作蛋糕的食谱，以及做蛋糕的各种原料，如面粉、鸡蛋、糖和香草汁等。做蛋糕的食谱好比是程序，计算机科学家好比是处理器CPU，而做蛋糕的各种原料就是输入数据。进程就是计算机科学家阅读食谱利用原料烘制蛋糕的过程。\n程序的并发执行 为了说明引入进程的原因，首先介绍程序的并发执行及其特点；为了更好的理解程序的并发执行，先介绍程序的顺序执行，并进行特性对比。\n程序的顺序执行 顺序性 封闭性 可再现性 程序的并发执行 间断性 失去封闭性 不可再现性 进程的概念 并发的程序，它们相互共享系统资源。用程序已不能描述程序的并发，所以引入了进程的概念。\n进程的定义 定义1 进程是允许并发执行的程序在某个数据集合上的运行过程。\n定义2 进程是由正文段、用户数据段和进程控制块共同组成的执行环境。\n正文段：存放被执行的机器指令。 用户数据段：存放进程在执行时直接进行操作的用户数据。 进程控制块：存放程序的运行环境。\n进程的特征 并发性 动态性 独立性 异步性 结构特征 进程实体包括用户正文段、用户数据段和进程控制块。 进程与程序的比较 进程与程序的区别 程序\n程序是静态的 永久性（相对进程而言），存储在介质上的二进制代码 存在实体不同，程序是指令的集合 进程\n进程是动态的 暂时性，进程因程序的执行而被创建，由程序的执行结束而被撤销 存在实体不同，进程的实体包含正文段、用户数据段和进程控制块 进程控制块 定义：进程控制块是进程实体的一部分，是操作系统最重要的数据结构，它记录了操作系统所需要的、用于描述进程情况及控制进程运行所需的全部信息。\n进程控制块中的信息 进程标识符信息 处理机状态信息 指令计数器 程序状态字PSW 用户栈指针 进程调度信息 进程控制信息 进程控制块这种数据结构在操作系统中有什么作用？\n以Linux进程控制块结构变量说明：进程控制块中有prio字段，用来存放进程的优先权，在操作系统决定为多个可执行的进程分配资源时，会利用这个字段比较进程的优先权，将资源分配给prio字段值最大或最小的进程。\n进程的状态 进程的3种基本状态 就绪态 进程一旦获得CPU就可以投入运行的状态。在多任务系统中，可以有多个处理就绪状态的进程，这些进程被组织成一个或多个就绪进程队列。\nLinux 2.4把所有就绪进程组织成一个先进先出的就绪队列。 Linux 2.6.11根据进程的优先权不同将就绪队列组织成多个不同的就绪队列；优先权相同的进程放在同一个就绪队列中，每个不同的优先权对应不同的就绪队列。\n执行态 执行态是进程获得CPU正在运行的状态。系统中执行态的进程数量受CPU数量的限制。单CPU系统中，任意时刻只能有一个进程处于执行态。 也就是说，有N个CPU的系统中，任意时刻系统中最多有N个进程处于执行态。\n阻塞态 阻塞态是进程由于等待资源或者事件的发生而暂停执行的状态，系统不会为处于阻塞态的进程分配CPU。在获得其等待的资源或者事件发生之后，就会转变为就绪态。 系统会根据不同阻塞原因的进程分别组织成不同的阻塞队列。 例如：因等待打印机而阻塞的进程排列成一个打印阻塞队列，等待输入数据的进程排列成等待输入数据的队列。\n进程状态的转换 ","date":"2018-03-22T11:22:40+08:00","image":"https://ghjayce.github.io/asset/blog/nae2CLNy3GD4lakpo2aBMjAxODAzMjJfMTEyMjQw.png","permalink":"/p/book/080901/02323/summary/","title":"02323《操作系统概论》笔记"},{"content":"在笔记本上的虚拟机中装了一个Linux系统，有一段时间没用，突然要用到时发现，密码已经不记得了。 还好之前有用过secureCRT软件连接过Linux，那么就能轻松地使用python找回密码啦。\n最终效果 红框所指的位置就是密码了\n准备 下载安装python，并配置系统全局变量。这里我用的是python 2.7\npython依赖包 下载python解密依赖包：https://pypi.python.org/pypi/pycrypto 解压文件，用命令行工具进入解压后的目录，执行下面命令\n1 2 python setup.py build python setup.py install 执行如果出现下图这种情况的\n还有另一种方法可以安装 到这里下载对应自己环境的版本 http://www.voidspace.org.uk/python/modules.shtml#pycrypto\n我下载的版本是PyCrypto 2.6 for Python 2.7 32bit\n下载好了直接运行安装\n开始找回 找到SecureCRT存储密码的位置 用户名\\AppData\\Roaming\\VanDyke\\Config\\Sessions\\\n或者\n软件目录下\\Data\\Settings\\Config\\Sessions\\\n目录中能看你的回话配置文件，我的是10.0.0.100.ini\n复制下面代码，保存文件到上面的这个目录，起名secureDecode.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from Crypto.Cipher import Blowfish import argparse import re def decrypt(password) : c1 = Blowfish.new(\u0026#39;5F B0 45 A2 94 17 D9 16 C6 C6 A2 FF 06 41 82 B7\u0026#39;.replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;).decode(\u0026#39;hex\u0026#39;), Blowfish.MODE_CBC, \u0026#39;\\x00\u0026#39;*8) c2 = Blowfish.new(\u0026#39;24 A6 3D DE 5B D3 B3 82 9C 7E 06 F4 08 16 AA 07\u0026#39;.replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;).decode(\u0026#39;hex\u0026#39;), Blowfish.MODE_CBC, \u0026#39;\\x00\u0026#39;*8) padded = c1.decrypt(c2.decrypt(password.decode(\u0026#39;hex\u0026#39;))[4:-4]) p = \u0026#39;\u0026#39; while padded[:2] != \u0026#39;\\x00\\x00\u0026#39; : p += padded[:2] padded = padded[2:] return p.decode(\u0026#39;UTF-16\u0026#39;) REGEX_HOSTNAME = re.compile(ur\u0026#39;S:\u0026#34;Hostname\u0026#34;=([^\\r\\n]*)\u0026#39;) REGEX_PASWORD = re.compile(ur\u0026#39;S:\u0026#34;Password\u0026#34;=u([0-9a-f]+)\u0026#39;) REGEX_PORT = re.compile(ur\u0026#39;D:\u0026#34;\\[SSH2\\] Port\u0026#34;=([0-9a-f]{8})\u0026#39;) REGEX_USERNAME = re.compile(ur\u0026#39;S:\u0026#34;Username\u0026#34;=([^\\r\\n]*)\u0026#39;) def hostname(x) : m = REGEX_HOSTNAME.search(x) if m : return m.group(1) return \u0026#39;???\u0026#39; def password(x) : m = REGEX_PASWORD.search(x) if m : return decrypt(m.group(1)) return \u0026#39;???\u0026#39; def port(x) : m = REGEX_PORT.search(x) if m : return \u0026#39;-p %d \u0026#39;%(int(m.group(1), 16)) return \u0026#39;\u0026#39; def username(x) : m = REGEX_USERNAME.search(x) if m : return m.group(1) + \u0026#39;@\u0026#39; return \u0026#39;\u0026#39; parser = argparse.ArgumentParser(description=\u0026#39;Tool to decrypt SSHv2 passwords in VanDyke Secure CRT session files\u0026#39;) parser.add_argument(\u0026#39;files\u0026#39;, type=argparse.FileType(\u0026#39;r\u0026#39;), nargs=\u0026#39;+\u0026#39;, help=\u0026#39;session file(s)\u0026#39;) args = parser.parse_args() for f in args.files : c = f.read().replace(\u0026#39;\\x00\u0026#39;, \u0026#39;\u0026#39;) print f.name print \u0026#34;ssh %s%s%s # %s\u0026#34;%(port(c), username(c), hostname(c), password(c)) 接着用命令行工具进入该目录，运行下面命令\n1 python secureDecode.py 10.0.0.100.ini 最后成功找回密码\n参考 找回SecureCRT密码 pycrypto模块安装失败如何解决 ","date":"2018-03-17T12:00:50+08:00","image":"https://ghjayce.github.io/asset/blog/oQBWE3gpg8IKTskSpyzrMjAxODAzMTdfMTIwMDUw.jpeg","permalink":"/p/tool/terminal/securecrt/forgot-password/","title":"使用python找回在SecureCRT中的Linux登入密码"},{"content":"文章为过程记录\n另外，以下命令行相关的全局变量配置，需要自己去设置。例如：ruby、python\n相关链接：Jekyll教程——精心收藏\n参考教程：Julian Thilo写的不错的安装教程 一定要看\n官方教程\n环境 windows7 x64 ruby 2.4.2p198 x64 python 2.7.13rc1 下载安装ruby相关 Ruby是Jekyll编写的编程语言。您需要安装Ruby和相应的DevKit\n虽然我已经有ruby的环境，但是也记录一下\n下载地址\n按需所取，我选的如下\n安装Ruby DevKit 将下载好的ruby devkit选择C:\\RubyDevKit\\解压存档\n运行命令行工具（cmd），依次执行下面的代码\n1 2 3 cd C:\\RubyDevKit # step1 ruby dk.rb init # step2 ruby dk.rb install # step3 安装Ruby Gem Jekyll本身就是Ruby Gem的形式，它是一个易于安装的软件包。\n紧接着执行\n1 gem install jekyll # step4 安装rouge 无论您使用的是Markdown还是HTML，Jekyll都可以让您轻松地将精美的代码块插入到您的网页中。\n语法高亮，快速和无痛\n1 gem install rouge # step5 然后，在你的中_config.yml，将Rouge设置为你的语法高亮部分：\n1 highlighter: rouge 安装python相关 如果你想使用Pygments，这是一个默认的Jekyll依赖，在Windows上的语法突出显示，你需要安装Python，PIP，最后是pygments.rb的Python基础。\n教程文章说要装2.7的版本，3的版本可能无法正常工作。\n安装pip Pip是一个安装和管理Python包的工具，类似于Ruby Gems。\n浏览器打开：https://bootstrap.pypa.io/get-pip.py\n右键保存到C:\\pip\\\n然后打开命令行工具（cmd），并依次执行\n1 2 3 cd C:\\pip # step6 python get-pip.py # step7 python -m pip install Pygments # step8 设置Pygments作为你的语法突出显示\n如果尚未设置，请添加以下内容_config.yml，将Pygments设置为语法突出显示。\n1 highlighter: pygments jekyll watch Jekyll有一个内置的自动更新功能，监视您的源文件夹的变化，然后重新建立您的网站。\n命令行工具（cmd），执行下面步骤\n在Windows上，您需要安装一个额外的工具，或者Gem，以启用此功能。\n1 gem install wdm # step9 创建一个项目，并运行它 打开命令行工具（cmd），执行下面的步骤\n1 2 3 4 5 6 7 gem install jekyll bundler # 先安装这个 step10 # 可以查看jekll版本了 # jekyll -v cd desktop # 一打开应该是自己的用户目录，直接可以cd到桌面 step11 jekyll new my_blog # step12 cd my_blog # step13 jekyll server --watch #step14 在浏览器访问http://localhost:4000/搭建好的环境，并且是实时更新的！\n","date":"2018-01-02T03:39:35+08:00","image":"https://ghjayce.github.io/asset/blog/l2X2IUWhKLBkgz5kr7qOMjAxODAxMDJfMDMzOTM1.jpeg","permalink":"/p/static-site-generator/jekyll/quick-start/","title":"本地快速搭建Jekyll及相关依赖"},{"content":"阅读说明 前言 本文内容是，如何在Linux centos7下快速搭建LNMP环境。虚拟机、实体机环境都可以。 另外，安装教程参考的是，下面这篇文章进行文字排版和内容扩充，感谢hcchanqing作者。 CentOS6.2 yum安装配置LNMP服务器（Nginx+PHP+MySQL）\n特别提醒：本文系统用的Centos7，是7！！参考教程用的是centos6.2\n环境 环境配置\nwindows7 64位 vmware workstation 12 linux CentOS7_x64 准备 Web环境（LNMP）\nLNMP 指 Linux + Nginx + Mysql + PHP LAMP 指 Linux + Apache + Mysql + PHP\nLNMP 也称 LEMP 其中 E 表示 engine x，国外喜欢简称这个 Why? Nginx官方发音\n安装之前先配置防火墙，主要能让windows系统能够访问80和数据库3306端口。\n1 2 3 4 # 注意，下面命令适用于centos7以下，不含centos7 vi /etc/sysconfig/iptables # 编辑防火墙配置文件 -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT # 允许80端口通过防火墙 -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT # 允许3306端口通过防火墙 Centos7的设置请点这里\nLinux安装 安装过程太长就不一一写了，可以参考这个Vmware 装Linux教程\n安装Nginx 使用yum安装Nginx 1 yum install nginx 提示没有软件包，就需要添加nginx到yum源了，可以使用如下命令，再执行上面一句进行安装。\n1 $ rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 启动Nginx服务 1 service nginx start 没开成功，出现了下面的一段文本\n搜了一下，说版本太新，提示命令已经换了。好，那就输入下面的命令\n1 2 3 /bin/systemctl start nginx.service # 更简洁的写法 systemctl start nginx.service 结果什么都没有返回，那怎么验证nginx服务是否有开启？\n1 ps -ef | grep nginx # 有返回的话，能看到软件路径的表示已经开启了 不能正常开启的处理方法 查看状态\n1 $ systemctl status nginx 有可能是开了httpd进程，占用了80端口。（要根据不同的错误信息进行处理）\n查看是谁占用了80端口\n1 $ netstat -lnp|grep 80 可以看到是进程id为1689的httpd占用了80端口，那么杀掉这个进程即可\n1 tcp6 0 0 :::80 :::* LISTEN 1689/httpd 杀掉id为1689的进程（有可能一次杀不完，执行了命令发现还有进程在占用80端口，查看再杀掉即可）\n1 kill -9 1689 设置开机自启 1 chkconfig nginx on 返回了一串提示，猜测应该是版本太新，命令又换了。\n按照提示，输入。systemctl 相关命令\n1 systemctl enable nginx.service OK，还是什么都没有返回，看来linux的尿性应该是成功执行一般不会有东西返回的\n1 systemctl is-enabled nginx.service # 验证是否开启，有开启会显示enabled 测试访问 在浏览器输入linux的ip地址，如果出现下面的内容，表示nginx搭建OK了。\ncentos7设置防火墙端口 然而过程并没有那么顺利，再得到welcome页前，我是打不开页面的 找了下度娘，果不其然，又是和版本有关，centos的防火墙改成了firewall不再叫iptables 原因\n键入下面命令\n1 2 3 4 5 firewall-cmd --zone=public --add-port=80/tcp --permanent # 命令含义： # –zone #作用域 # –add-port=80/tcp #添加端口，格式为：端口/通讯协议 # –permanent #永久生效，没有此参数重启后失效 然后重启防火墙，再访问一下地址就能看到welcome to nginx\n1 2 systemctl stop firewalld.service systemctl start firewalld.service 安装Mysql 接着再按照教程安装mysql，显然只要把其中的旧命令换成新命令就能安装mysql了。 照着这个思路，结果又踩坑了。。。道路真是坎坷😲\n首先跑了下面的命令\n1 yum install mysql mysql-server 第一次安装过程很正常，还看到了complete（可能我看了一个假的complete）。\n然后接下来的启动服务、设置开机自启等操作都是返回not found（差不多这个意思，就是没找到）\n再查看mysql的相关进程却是有的，而且which mysql也有返回目录\n会不会是名字的原因？于是折腾之前操作中mysql服务的名字，比如下面的命令\n1 2 3 4 /bin/systemctl start mysqld.service /bin/systemctl start mysql-server.service /bin/systemctl start mysql.service ... 结果肯定是掉坑里了。正解在这：CentOS7下安装Mysql失败经历\u0026ndash;CentOS7使用yum安装和卸载Mysql过程\n关键的命令Mark一下\n1 2 3 wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm # step 1 rpm -ivh mysql-community-release-el7-5.noarch.rpm # step 2 yum install mysql-server # step 3 启动Mysql服务 1 2 3 4 5 /bin/systemctl start mysqld.service # 简洁的写法 systemctl start mysqld.service # 或者 systemctl start mysqld 设置开机自启 1 2 systemctl enable mysqld.service systemctl is-enabled mysqld.service # 检测是否已经设置开机自启 配置 参考一：Linux centos7环境下MySQL安装教程 参考二：Centos7安装并配置mysql5.6完美教程 我的命令行记录\n1 2 3 4 5 6 7 8 9 10 11 12 mysql -u root -p # 登录账号 mysql\u0026gt;use mysql; # 进入mysql数据库 mysql\u0026gt;update user set password=password(\u0026#39;要设置的密码\u0026#39;) where user=\u0026#39;root\u0026#39; and host=\u0026#39;localhost\u0026#39;; # 设置root的账号密码为root mysql\u0026gt;flush privileges; # 不重启生效 mysql\u0026gt;grant all privileges on *.* to root@\u0026#39;%\u0026#39; identified by \u0026#39;要设置的密码\u0026#39;; # 设置远程连接账号 ############################# # 语法 # grant all privileges on 库名.表名 to \u0026#39;用户名\u0026#39;@\u0026#39;IP地址\u0026#39; identified by \u0026#39;密码\u0026#39; with grant option; ############################# # PS：在mysql命令下，要结束或运行命令一定要让语句结束加上 ； 号 安装PHP 安装之前，我尝试查看php版本，发现是有的，版本为5.4，所以我决定升级PHP的版本\n1 php --version 首先查看php的安装包（我使用的是yum安装方式）\n1 yum list installed | grep php 看到的都是5.4的安装包\n安装前移除当前的安装包，避免之后的安装冲突\n1 yum remove php* 添加第三方yum源 由于默认的YUM源无法升级PHP，所以需要添加第三方的YUM源，此处用到webtatic\n1 2 3 4 5 # CentOS 7.x rpm -Uvh http://mirror.webtatic.com/yum/el7/epel-release.rpm rpm -Uvh http://mirror.webtatic.com/yum/el7/webtatic-release.rpm # CentOS 6.5 rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm 使用yum安装 1 2 3 4 5 6 7 yum install php71w -y # 基础 yum install php71w-fpm -y # nginx连接使用 yum install php71w-mbstring -y # 宽字节 yum install php71w-mysqlnd -y # mysql相关 yum install php71w-pecl-redis -y # redis扩展 yum install php71w-mcrypt -y # 加密使用 yum install php71w-opcache -y # 性能加速 php5.5 以上使用 或者更短的命令\n1 yum install php71w php71w-fpm php71w-mbstring php71w-mysqlnd php71w-pecl-redis php71w-mcrypt php71w-opcache -y 原文链接：yum安装高版本PHP\n执行安装时，发现这个出错 1 2 Could not retrieve mirrorlist https://mirror.webtatic.com/yum/el7/x86_64/mirrorlist error was 12: Timeout on https://mirror.webtatic.com/yum/el7/x86_64/mirrorlist: (28, \u0026#39;Operation timed out after 30000 milliseconds with 0 out of 0 bytes received\u0026#39;) 我的解决方法是改了DNS、网卡设置中的dns为 114.114.114.114 DNS配置文件\n1 2 $ vi /etc/resolv.conf # step1 $ vi /etc/sysconfig/network-scripts/ifcfg-自己的网卡名 # step2 解决方法：无法检索镜像列表\n启动服务 1 systemctl start php-fpm.service 设置开机自启 1 systemctl enable php-fpm.service 服务配置 让Nginx支持PHP 1 2 3 cp /etc/nginx/nginx.conf /etc/nginx/nginx.confbak # 备份原有配置文件 vi /etc/nginx/nginx.conf # 编辑这个文件 user nginx nginx; # 修改nginx运行账号为：nginx组的nginx用户 按Esc输入:wq保存并退出\n紧接着\n1 2 cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.confbak # 备份原有配置文件 vi /etc/nginx/conf.d/default.conf # 编辑 找到location / {增加index.php\n1 index index.php index.html index.htm; 接着，取消FastCGI server部分location的注释\n1 2 3 4 5 6 7 8 9 10 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 location ~ \\.php$ { #root html; # 注意这个路径是不正确的，要替换成nginx实际的站点目录 root /usr/share/nginx/html; # 正确姿势 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; # 要注意fastcgi_param行的参数 改为 $document_root$fastcgi_script_name 或者使用绝对路径 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 如下\n配置PHP 1 vi /etc/php.ini 设置中国时区\n1 date.timezone = PRC 配置php-fpm 1 2 3 4 5 cp /etc/php-fpm.d/www.conf /etc/php-fpm.d/www.confbak # 备份原来的配置文件 vi /etc/php-fpm.d/www.conf # 修改内容如下 user = nginx # 由原来的apache换成nginx group = nginx # 由原来的apache换成nginx 设置目录权限 1 2 chown nginx.nginx /usr/share/nginx/html/ -R # 设置目录所有者 chmod 700 /usr/share/nginx/html/ -R # 设置目录权限 重启服务 1 2 systemctl restart nginx.service # 重启nginx服务 systemctl restart php-fpm.service # 重启php服务 测试 在/usr/share/nginx/html/目录下放置index.php文件\n在浏览器中输入服务器的ip，OK访问没问题😄 :)\n资源 本文使用的系统安装包：Linux_CentOS7_x64\nhttps://pan.baidu.com/s/1cGfee_YyrAqTwGLTc7nOXg 密码：5sph\n文章内容亲测有效，也是安装过程，文章如果有内容不正确或者内容有误的地方请不吝指出 :）\n","date":"2017-12-24T17:33:45+08:00","image":"https://ghjayce.github.io/asset/blog/w6PuBfnL7w3BeiDpzBQvMjAxNzEyMjRfMTczMzQ1.jpeg","permalink":"/p/system/android/env/web-env-build/","title":"虚拟机Linux Centos7搭建web环境（LNMP）"},{"content":"内容大纲 php的报错类型都有哪些 常见的报错原因 报错的特性 本文部分信息源自以下文章，如有内容不正确的地方请指出。\nPHP常见报错解析 PHP错误异常处理详解 错误异常 错误信息的格式： {错误类型}: {错误原因} in {错误文件} on {错误行数}\n错误类型列表 Parse error 栗子：\n1 2 3 \u0026lt;?php qweqwe echo 1; 运行结果：\n1 Parse error: syntax error, unexpected end of file in D:\\XAMPP\\htdocs\\index.php on line 2 要看懂这个错误，首先要明白其中的一些关键词语：\nParse error（解析错误） syntax error（语法错误） unexpected（意外的意思） end of file（文件结尾） 通过挑出的关键词语，再去看栗子中的错误，我想大家就能知道它所要传达的意思。\nParse error，一般伴随着syntax error的错误原因，说明程序不符合PHP的语法，它是级别最高的错误。\n常见语句的末尾没有加;号\n在通过系统语法检测的过程中，如果遇到语法错误，整个脚本将不会执行，直接抛出错误。并且这个错误不能被捕获。\n一般语法错误会带一个解析器的代号，例如：T_STRING、T_VARIABLE，通过它可以更直接的了解到错误的原因。解析器的代号\nFatal error 栗子：\n1 2 3 4 5 6 \u0026lt;?php echo 1; func(); $aa += 1; include \u0026#39;abc.cc\u0026#39;; echo 2; 运行结果：\n1 Fatal error: Call to undefined function func() in D:\\XAMPP\\htdocs\\index.php on line 3 Fatal error（致命错误），级别仅次于Parse error错误，这个错误能够被捕获，但是捕获的函数必须是在错误的前面。\n常见报错原因：\n调用未定义的函数 require一个不存在的文件 死循环导致程序超时等 在通过程序语法检测后，程序执行到发生错误的行时，脚本会终止运行。 也就是说，echo 1;能正常输出，而因为找不到func()这个函数，所有就会从第二行就开始停止运行。\nWarning 栗子：\n1 2 3 4 5 \u0026lt;?php echo 1; $aa += 1; include \u0026#39;abc.cc\u0026#39;; echo 2; 运行结果：\n1 2 3 4 5 6 7 1 Notice: Undefined variable: aa in D:\\XAMPP\\htdocs\\php_share\\exception_handle\\index.php on line 4 Warning: include(abc.cc): failed to open stream: No such file or directory in D:\\XAMPP\\htdocs\\php_share\\exception_handle\\index.php on line 5 Warning: include(): Failed opening \u0026#39;abc.cc\u0026#39; for inclusion (include_path=\u0026#39;D:\\XAMPP\\php\\PEAR\u0026#39;) in D:\\XAMPP\\htdocs\\php_share\\exception_handle\\index.php on line 5 2 常见发生警告原因：\ninclude一个不存在的文件 调用函数没传参数，而参数没有默认值的情况下 Warning（警告），程序不会因为脚本发生警告而终止运行，虽然可以用@符号屏蔽警告信息，但是不推荐这么做。警告能够被捕获\n1 2 \u0026lt;?php @include \u0026#39;abc.cc\u0026#39;; // 屏蔽错误，不推荐 Notice 栗子：\n1 2 3 4 \u0026lt;?php echo 1; $a += 1; echo 2; 运行结果：\n1 2 3 1 Notice: Undefined variable: aa in D:\\XAMPP\\htdocs\\php_share\\exception_handle\\index.php on line 3 2 常见发生通知原因：\n变量或者数组下标未定义的情况 Notice（通知），级别最低。和警告一样（可以加@抑制符，不推荐），程序不会因为脚本发生通知而终止运行，能够被捕获。\n捕获错误，自定义报错信息 相关函数 PHP官方手册 错误处理 函数\nset_error_handler 一般用于捕获：\nE_NOTICE E_USER_ERROR E_USER_WARNING E_USER_NOTICE 不能捕获：\nE_ERROR E_PARSE E_CORE_ERROR E_CORE_WARNING E_COMPILE_ERROR E_COMPILE_WARNING ","date":"2017-11-16T16:38:34+08:00","image":"https://ghjayce.github.io/asset/blog/mwZTYxkP4GSsgLbC5aXaMjAxNzExMTZfMTYzODM0.jpeg","permalink":"/p/language/php/exception/error-capture/","title":"PHP报错解析和如何捕获错误信息"},{"content":"keydown event对象 按键 对象 数据类型 ctrl ctrlKey boolean alt altKey boolean shirt shirtKey boolean keyCode 速记 按键 对象 描述 A - Z 65 ~ 90 字母 0 - 9 48 ~ 57 字母上数字键 0 - 9 96 ~ 105 小键盘数字键 F1 - F12 112 ~ 123 功能键 字母按键 按键 键码 按键 键码 按键 键码 A 65 B 66 C 67 D 68 E 69 F 70 G 71 H 72 I 73 J 74 K 75 L 76 M 77 N 78 O 79 P 80 Q 81 R 82 S 83 T 84 U 65 V 86 W 87 X 88 Y 89 Z 90 字母上面一排数字键 按键 键码 按键 键码 按键 键码 0 48 1 49 2 50 3 51 4 52 5 53 6 54 7 55 8 56 9 57 控制键 按键 键码 按键 键码 按键 键码 tab 9 enter 13 shift 16 control 17 alt 18 pause break 19 caps lock 20 spacebar 32 page up 33 page down 34 end 35 home 36 left arrow 37 up arrow 38 right arrow 39 down arrow 40 insert 45 delete 46 windows 91 menu 93 num lock 144 scroll lock 145 esc 27 小键盘按键 按键 键码 按键 键码 按键 键码 / 111 * 106 - 109 + 107 delete 110 0 96 1 97 2 98 3 99 4 100 5 101 6 102 7 103 8 104 9 105 符号 按键 键码 按键 键码 按键 键码 ;（分号） 186 = 187 , 188 -（减号） 189 . 190 /（斜杠） 191 `（反单引号） 192 [ 219 \\（反斜杠） 220 ] 221 '（单引号） 222 功能键 按键 键码 按键 键码 按键 键码 F1 112 F2 113 F3 114 F4 115 F5 116 F6 117 F7 118 F8 119 F9 120 F10 121 F11 122 F12 123 ","date":"2017-11-08T09:05:13+08:00","image":"https://ghjayce.github.io/asset/blog/hhu3ZhdElGKvdDDmPImUMjAxNzExMDhfMDkwNTEz.jpeg","permalink":"/p/language/javascript/key-code/","title":"JS 键盘按键keyCode对应表"},{"content":"准备工作 Yosemite10.10.3懒人版 链接: https://pan.baidu.com/s/1i5aOBOT 密码: hukg\n安装环境：\nwindows10 64位 变色龙 2.3 配置图如下：\n开启ahci模式 否则无法进入安装界面。或者打免ahci的补丁。\n由于我装好的win系统用的是ide，开启ahci模式，我的win系统就不能正常进入。需要设置注册表，方法如下\nWin7下开启ACHI 单击“开始”按钮，在搜索框中键入“regedit”，按下回车键，打开“注册表编辑器”窗口。Windows7虽然在“开始”菜单默认不显示“运行”命令，但实际上可用搜索框代替这一功能（或者直接按下Windows键+R键再输入）。\n在“注册表编辑器”窗口左侧标题栏定位至HKEY_LOCAL_MACHINE\\SYSTEM\\ CurrentControlSet\\services\\msahci分支，然后在右侧窗口，双击“Start”。\n在打开的“编辑DWORD值”对话框，将“数值数据”框中的值由3改为数字0，单击“确定”按钮。\nwin 10 开启achi方式 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\storahci下面的StartOverride里面的0键值改为0，默认是3\n进入安装界面，-v -f跑啰嗦模式，很顺利地进入安装界面\n安装完成后进入Mac系统盘，继续跑啰嗦模式。\n问题集合 遇到第一个问题\n解决：删除 S/L/E 文件夹下面的\nAppleIntelCPUPowerManagement.kext AppleIntelCPUPowerManagementClient.kext 第二个问题：\n解决方法：\n威锋五国帖 Q：23 远景五国贴 Q：10 尝试方案：\n-v -f -x进入啰嗦模式。-x意思是不加载任何驱动 不再出现第二个问题，但是跑啰嗦代码非常非常非常的慢。并且出现新的问题 失败 中间各种爬帖，各种碰壁，各种尝试\u0026hellip;.\n最终还是让我进了苹果系统！哈哈，这种成就感真的是难以描述，很奇妙。\n下面是我爬帖按照帖子中的内容去做的尝试，其中这些文件的牵连，应该是影响到进入系统的关键，也许起作用的并不是全部，但也值得一试。\nSNB HD 3000集显，/Extra/目录下加入MacBookPro8.1 的smbios.plist 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;SMfamily\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MacBook Pro\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SMproductname\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MacBookPro8,1\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SMboardproduct\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Mac-94245B3640C91C81\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SMserial\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;C02F93FQDH2G\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SMbiosversion\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MultiBeast.tonymacx86.com\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 删除文件 删了全部/System/Library/Extensions/AppleIntel****.**** 显卡驱动(记得备份) 删了全部/System/Library/Extensions/ATI****.**** 显卡驱动(记得备份) 删了全部/System/Library/Extensions/Geforce****.**** 显卡驱动(记得备份) 删了全部/System/Library/Extensions/NVDA****.**** 显卡驱动(记得备份) 补充文件\norg.chameleon.Boot.plist 1 2 3 4 \u0026lt;key\u0026gt;Kernel Flags\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;-v -f cpus=1\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;GraphicsEnabler\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;No\u0026lt;/string\u0026gt; S/L/E 目录下加入 FakeSMC.kext NullCPUPowerManagement.kext 7系主板已经修改好的HD3000驱动 所有文件 链接: https://pan.baidu.com/s/1kVj7Wiz 密码: nxk9\n爬帖链接集合 也是ntfs volume name问题，有图 被整了一天了~NTFS volume name ***，version 3.1 问题 ☪☪☪新手必看，初级知识普及贴，及常见五国错误解决办法 黑苹果常见五国问题解决 Missing Bluetooth Controller Transport! 求助，安装完系统后卡在missing bluetooth controller transport 安装时卡在Resetting IOCatalogue处 ","date":"2017-11-04T21:03:00+08:00","image":"https://ghjayce.github.io/asset/blog/dPMjucATggvoLXmJZXz5MjAxNzExMDRfMjEwMzAw.jpeg","permalink":"/p/system/hackintosh/asus/x45vd/","title":"华硕x45vd安装黑苹果Yosemite 10.10.3记录"},{"content":"方法一 把以下代码，复制到SublimeText3的文件目录，然后重命名为：安装右键菜单.inf，然后右击安装就可以了。\nPS：重命名文件之前，需要先在工具\u0026ndash;文件夹选项，查看中，把隐藏已知文件类型的扩展名前边的复选框不勾选。\n1 2 3 4 5 6 7 8 9 10 11 12 [Version] Signature=\u0026#34;$Windows NT$\u0026#34; [DefaultInstall] AddReg=SublimeText3 [SublimeText3] hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\u0026#34;,,,\u0026#34;用 SublimeText3 打开\u0026#34; hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\\\\command\u0026#34;,,,\u0026#34;\u0026#34;\u0026#34;%1%\\sublime_text.exe\u0026#34;\u0026#34; \u0026#34;\u0026#34;%%1\u0026#34;\u0026#34; %%*\u0026#34; hkcr,\u0026#34;Directory\\shell\\SublimeText3\u0026#34;,,,\u0026#34;用 SublimeText3 打开\u0026#34; hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\u0026#34;,\u0026#34;Icon\u0026#34;,0x20000,\u0026#34;%1%\\sublime_text.exe, 0\u0026#34; hkcr,\u0026#34;Directory\\shell\\SublimeText3\\command\u0026#34;,,,\u0026#34;\u0026#34;\u0026#34;%1%\\sublime_text.exe\u0026#34;\u0026#34; \u0026#34;\u0026#34;%%1\u0026#34;\u0026#34;\u0026#34; 方法二 把以下代码，复制到SublimeText3的安装目录，然后重命名为：sublime right menu.reg，然后双击就可以了。\n注意：\n需要把下边的Sublime的安装目录，替换成你的实际的Sublime安装目录。 文件编码必须是ANSI，代码中的中文才会正常显示。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3] @=\u0026#34;用 SublimeText3 打开\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe,0\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3\\command] @=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe %1\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3] @=\u0026#34;用 SublimeText3 打开\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe,0\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3\\command] @=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe %1\u0026#34; 最后，附一个删除右键菜单的脚本吧。 把以下代码，复制到SublimeText3的文件目录，然后重命名为：remove right menu.reg，然后双击就可以了。\n1 2 3 Windows Registry Editor Version 5.00 [-HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3] [-HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3] 一个小工具 生成windows右键菜单的注册表文件，通过填写几个选项就能得到一个注册表文件。（太方便了😆）\nGHJayce/RightClickMenu 在线体验 ","date":"2016-12-26T10:34:34+08:00","image":"https://ghjayce.github.io/asset/blog/WKRr6SlzDfcw9eTWRv1EMjAxNjEyMjZfMTAzNDM0.jpeg","permalink":"/p/system/windows/regedit/right-click-menu/sublime-text/","title":"将Sublime Text 添加到右键菜单的方法"},{"content":"打开注册表regedit\n要在背景上设置右键菜单的 依次进入\nHKEY_CLASSES_ROOT Directory Background shell 要在选中文件时设置右键菜单的 依次进入\nHKEY_CLASSES_ROOT Directory shell 注册文件示例 下面内容按照实际进行替换。\n背景的右键菜单示例 保存下面代码为example.reg文件，打开运行即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Windows Registry Editor Version 5.00 ; 这里是右键菜单注册项 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmder] ; @ 是右键菜单的名称 @=\u0026#34;open Cmder\u0026#34; ; Extended 是要按shift+鼠标右键才会显示，不需要的话去除下面一行代码即可 \u0026#34;Extended\u0026#34;=\u0026#34;\u0026#34; ; Icon 表示右键菜单时显示的图标 \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\cmder\\\\icons\\\\cmder.ico\u0026#34; ; 这里是右键菜单注册项的重要子项 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmder\\command] ; 下面表示右键菜单软件的目录 @=\u0026#34;C:\\\\cmder\\\\Cmder.exe\u0026#34; 选中文件右键菜单示例 使用方法：保存下面代码为name.reg文件，打开运行即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3] ; 右键菜单名称 @=\u0026#34;用 SublimeText3 打开\u0026#34; ; 显示的图标 后面 的， 逗号应该是用使用软件的图标 \u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe,0\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\SublimeText3\\command] ; 软件的路径 @=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe %1\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3] ; 右键菜单名称 @=\u0026#34;用 SublimeText3 打开\u0026#34; ; 图标的路径 \u0026#34;Icon\u0026#34;=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe,0\u0026#34; ; 软件的路径 [HKEY_CLASSES_ROOT\\Directory\\shell\\SublimeText3\\command] @=\u0026#34;D:\\\\Program Files\\\\Sublime Text 3\\\\sublime_text.exe %1\u0026#34; 另外一种方法 使用方法：放到和软件同目录，保存下面代码为name.inf，右键安装即可。【推荐】\n和上面方法的区别就是，文件放置的目录不一样，这种方法要放到和软件同目录下，上面的方法则是任意目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [Version] Signature=\u0026#34;$Windows NT$\u0026#34; [DefaultInstall] ; 注册表名称 AddReg=SublimeText3 [SublimeText3] ; 菜单显示的名称 hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\u0026#34;,,,\u0026#34;用 SublimeText3 打开\u0026#34; ; 软件路径 hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\\\\command\u0026#34;,,,\u0026#34;\u0026#34;\u0026#34;%1%\\sublime_text.exe\u0026#34;\u0026#34; \u0026#34;\u0026#34;%%1\u0026#34;\u0026#34; %%*\u0026#34; ; 显示的名称 hkcr,\u0026#34;Directory\\shell\\SublimeText3\u0026#34;,,,\u0026#34;用 SublimeText3 打开\u0026#34; ; 软件的图标 hkcr,\u0026#34;*\\\\shell\\\\SublimeText3\u0026#34;,\u0026#34;Icon\u0026#34;,0x20000,\u0026#34;%1%\\sublime_text.exe, 0\u0026#34; ; 软件的路径 hkcr,\u0026#34;Directory\\shell\\SublimeText3\\command\u0026#34;,,,\u0026#34;\u0026#34;\u0026#34;%1%\\sublime_text.exe\u0026#34;\u0026#34; \u0026#34;\u0026#34;%%1\u0026#34;\u0026#34;\u0026#34; 一个小工具 生成windows右键菜单的注册表文件，通过填写几个选项就能得到一个注册表文件。（太方便了😆）\nGHJayce/RightClickMenu 在线体验 ","date":"2016-12-25T10:34:34+08:00","image":"https://ghjayce.github.io/asset/blog/jhPbumQV8Q1Tn3JTsxQaMjAxNjEyMjVfMTAzNDM0.jpeg","permalink":"/p/system/windows/regedit/right-click-menu/custom/","title":"windows自定义程序到右键菜单"}]