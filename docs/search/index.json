[{"content":"阅读说明 环境说明 php v8.2.8 hyperf/constants v3.1.0 前言 Hyperf 枚举类文档中，主要分为了两个部分：\n枚举，主要是通过错误码获取到错误内容的作用。 异常，则是对抛异常的使用带来了便利，仅传入错误码，就能从枚举类中获得错误内容。 本文主要分析枚举类获取错误内容的源码实现过程。\n代码示例 hyperf/constants的使用如下。\n枚举类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php declare(strict_types=1); namespace App\\Constants; use Hyperf\\Constants\\AbstractConstants; use Hyperf\\Constants\\Annotation\\Constants; #[Constants] class ErrorCode extends AbstractConstants { /** * @Message(\u0026#34;Server Error！\u0026#34;) */ const SERVER_ERROR = 500; /** * @Message(\u0026#34;系统参数错误\u0026#34;) */ const SYSTEM_INVALID = 700; } 错误内容通过注释的方式定义，与错误码紧挨着，这样的实现有两个好处：\n阅读方便，文件简洁。 书写便捷，省工作量。 为什么？看看传统的实现方式你就知道了。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php class ErrorCode { const SERVER_ERROR = 500; const PARAMS_INVALID = 1000; public static $messages = [ self::SERVER_ERROR =\u0026gt; \u0026#39;Server Error\u0026#39;, self::PARAMS_INVALID =\u0026gt; \u0026#39;参数非法\u0026#39; ]; } $message = ErrorCode::messages[ErrorCode::SERVER_ERROR] ?? \u0026#39;未知错误\u0026#39;; 当错误码定义足够多的情况下，就会显得臃肿和繁琐。\n（如果你选择把错误码拆到多个文件，每个文件内容不超过一个屏幕画面的话，当我没说😂）\n异常类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php declare(strict_types=1); namespace App\\Exception; use App\\Constants\\ErrorCode; use Hyperf\\Server\\Exception\\ServerException; use Throwable; class BusinessException extends ServerException { public function __construct(int $code = 0, string $message = null, Throwable $previous = null) { if (is_null($message)) { $message = ErrorCode::getMessage($code); } parent::__construct($message, $code, $previous); } } 抛异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php declare(strict_types=1); namespace App\\Controller; use App\\Constants\\ErrorCode; use App\\Exception\\BusinessException; class IndexController extends AbstractController { public function index() { throw new BusinessException(ErrorCode::SERVER_ERROR); } } 分析 根据使用方式，先来猜测一下。\n如果要获取类文件中的注释，那必定会用到反射类：ReflectionClass或者是ReflectionClassConstant，然后再通过正则取出想要的内容。\n疑问 KQ1：怎么获取到注释里的错误内容的？ KQ2：在什么时候进行获取的？ Q3：难道每次获取错误内容都要反射一次？那会对性能有影响啊？ Q4：都PHP8了为什么不用注解的写法？例如：#[Message(\u0026quot;Server Error！\u0026quot;)] 废话不多说，马上开始逐个分析问题。\n获取错误内容 先从获取错误内容的代码入手：\n1 ErrorCode::getMessage($code); 再看下枚举类，是继承了Hyperf\\Constants\\AbstractConstants的抽象类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; /** * @method static string getMessage(int|string $code, array $translate = null) */ abstract class AbstractConstants { use ConstantsTrait; } 用了一个Hyperf\\Constants\\ConstantsTrait的trait，继续点进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; use Hyperf\\Constants\\Exception\\ConstantsException; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\NotFoundExceptionInterface; /** * @method static string getMessage(int|string $code, array $translate = null) */ trait ConstantsTrait { use GetterTrait; /** * @throws ConstantsException * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public static function __callStatic(string $name, array $arguments): string|array { return static::getValue($name, $arguments); } } 是一个__callStatic魔术方法，再点进Hyperf\\Constants\\GetterTrait这个 trait。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;?php declare(strict_types=1); /** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://hyperf.wiki * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */ namespace Hyperf\\Constants; use Hyperf\\Constants\\Exception\\ConstantsException; use Hyperf\\Context\\ApplicationContext; use Hyperf\\Contract\\TranslatorInterface; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\NotFoundExceptionInterface; use function array_shift; use function is_array; use function sprintf; use function strtolower; use function substr; trait GetterTrait { /** * @throws ConstantsException * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public static function getValue(string $name, array $arguments): string|array { if (! str_starts_with($name, \u0026#39;get\u0026#39;)) { throw new ConstantsException(\u0026#34;The function {$name} is not defined!\u0026#34;); } if (empty($arguments)) { throw new ConstantsException(\u0026#39;The Code is required\u0026#39;); } $code = array_shift($arguments); $name = strtolower(substr($name, 3)); $message = ConstantsCollector::getValue(static::class, $code, $name); $result = self::translate($message, $arguments); // If the result of translate doesn\u0026#39;t exist, the result is equal with message, so we will skip it. if ($result \u0026amp;\u0026amp; $result !== $message) { return $result; } if (! empty($arguments)) { return sprintf($message, ...(array) $arguments[0]); } return $message; } /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ protected static function translate(string $key, array $arguments): array|string|null { if (! ApplicationContext::hasContainer() || ! ApplicationContext::getContainer()-\u0026gt;has(TranslatorInterface::class)) { return null; } $replace = array_shift($arguments) ?? []; if (! is_array($replace)) { return null; } $translator = ApplicationContext::getContainer()-\u0026gt;get(TranslatorInterface::class); return $translator-\u0026gt;trans($key, $replace); } } 到这里可以得知：ErrorCode::getMessage($code); 的调用，最终是Hyperf\\Constants\\GetterTrait::getValue() 在处理。\n第一感觉有点绕啊，跳来跳去最后才见到了庐山真面目。\n为什么要这样设计呢？那么多层trait，不如直接写一个getMessage方法方便？挖坑#1002。\n但是这样实现有一个好处，比如可以通过ErrorCode::getTest($code);获取到自定义注释的错误内容，这是文档中没有介绍到的，挖到一点宝藏用法，但是毕竟属于没公布的内容，在业务中使用还得谨慎一些。\n1 2 3 4 5 /** * @Message(\u0026#34;Server Error！\u0026#34;) * @Test(\u0026#34;服务错误\u0026#34;) */ const SERVER_ERROR = 500; 回到主线任务，从实现中可以看出，错误内容的获取关键代码是：\n1 $message = ConstantsCollector::getValue(static::class, $code, $name); 它是一个自定义的收集器，在Hyperf\\Constants\\ConfigProvider中可以看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; class ConfigProvider { public function __invoke(): array { return [ \u0026#39;annotations\u0026#39; =\u0026gt; [ \u0026#39;scan\u0026#39; =\u0026gt; [ \u0026#39;collectors\u0026#39; =\u0026gt; [ ConstantsCollector::class, ], ], ], ]; } } 进去Hyperf\\Constants\\ConstantsCollector：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants; use Hyperf\\Di\\MetadataCollector; class ConstantsCollector extends MetadataCollector { protected static array $container = []; public static function getValue($className, $code, $key): string { return static::$container[$className][$code][$key] ?? \u0026#39;\u0026#39;; } } 错误内容是从一个数组类型的静态变量（这里称为容器）中获取的，并且容器中存储不止一个枚举类的数据。\nswoole静态变量的生命周期是多久？和传统PHP有什么区别？挖坑#1000。\n把容器的数据结构打印出来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 var_dump(ConstantsCollector::list()); [ \u0026#39;App\\Constants\\ErrorCode\u0026#39; =\u0026gt; [ 500 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;Server Error！\u0026#39;, \u0026#39;test\u0026#39; =\u0026gt; \u0026#39;服务错误\u0026#39;, ], 700 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;系统参数错误\u0026#39;, ], ], ]; 也就是ErrorCode::getMessage($code);获取错误内容实际是从Hyperf\\Constants\\ConstantsCollector::$container静态变量里取出来的。\nKQ2和Q3的问题回答了一半，那容器里的数据是怎么来的？也就是调用收集器的地方。\nhyperf注解和收集器的工作原理是怎样的？挖坑#1001。\n获取时机 在对hyperf的配置加载、注解和收集器的机制了解完以后（挖坑#1003），我们知道，hyperf会在启动的时候对annotations.scan.paths配置的目录进行扫描，配置结构如下。\n1 2 3 4 5 6 7 \u0026#39;scan\u0026#39; =\u0026gt; [ \u0026#39;paths\u0026#39; =\u0026gt; [ BASE_PATH . \u0026#39;/app\u0026#39;, BASE_PATH . \u0026#39;/src\u0026#39;, ], ... ] 然后会把所有后缀是.php的类文件，进行ReflectionClass反射处理。\n并通过getAttributes()逐个检查类文件中的class、method和properties是否存在注解，存在就会通过newInstance()实例化这个注解类，然后执行注解类中的collectClass() / collectProperty() / collectMethod()方法，最后会将所有collector给序列化serialize然后存放到./runtime/container/scan.cache中以便下次启动时加速。\n回到主线任务，也就是说，在启动的时候会扫描到枚举类文件，发现使用到了#[Constants]注解，对应Hyperf\\Constants\\Annotation\\Constants会被实例化，看下这个文件的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php declare(strict_types=1); namespace Hyperf\\Constants\\Annotation; use Attribute; use Hyperf\\Constants\\AnnotationReader; use Hyperf\\Constants\\ConstantsCollector; use Hyperf\\Di\\Annotation\\AbstractAnnotation; use ReflectionClass; #[Attribute(Attribute::TARGET_CLASS)] class Constants extends AbstractAnnotation { public function collectClass(string $className): void { $reader = new AnnotationReader(); $ref = new ReflectionClass($className); $classConstants = $ref-\u0026gt;getReflectionConstants(); $data = $reader-\u0026gt;getAnnotations($classConstants); ConstantsCollector::set($className, $data); } } collectClass()就会被执行，来分析一下这段代码。\n这里的$className正是App\\Constants\\ErrorCode枚举类，可以看到用了ReflectionClass反射该文件来获取所有的常量。\n这里为什么不用Hyperf\\Di\\ReflectionManager::reflectClass复用的方式来获取反射呢？毕竟composer都已经依赖hyperf/di包了🤔。\n哈哈，找到了一个优化点，想提交PR的心正在蠢蠢欲动🤣。\n进去Hyperf\\Constants\\AnnotationReader::getAnnotations()方法得到了证实，代码太多我就不放出来，它是通过getDocComment()和正则拿到了注释中的错误内容。\n$data结构参考如下：\n1 2 3 4 5 6 7 500 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;Server Error！\u0026#39;, \u0026#39;test\u0026#39; =\u0026gt; \u0026#39;服务错误\u0026#39;, ], 700 =\u0026gt; [ \u0026#39;message\u0026#39; =\u0026gt; \u0026#39;系统参数错误\u0026#39;, ], 最后将数据存到了Hyperf\\Constants\\ConstantsCollector::container静态变量中，梳理完毕。\n整个过程简单点说就是，在hyperf启动时，枚举类文件会被扫描，由注解类将收集到的数据存放到收集器中，扫描逻辑将所有收集器的数据缓存到本地文件中，下次再启动时就不需要重复扫描，直接使用本地缓存文件。\n至此，KQ1、KQ2、Q3都得到了回答。\n等等，是不是还有Q4没有回答？\n嘿嘿，偷个懒，留个课后作业给你思考一下。\n总结 枚举类中的错误内容是通过ReflectionClass反射，对每个常量getReflectionConstants()的注释内容getDocComment()用正则的方式取出来。 获取错误内容并不是在ErrorCode::getMessage($code)调用的时候进行反射实时去取，而是会在hyperf启动的时候，由Hyperf\\Constants\\Annotation\\Constants注解将文件中所有常量的错误内容收集起来后，以文件类名为key，存放到Hyperf\\Constants\\ConstantsCollector::container静态变量中，并且最后会将收集到的数据缓存到./runtime/container/scan.cache中，这样下次就不需要再重复这个过程。 ","date":"2024-02-26T10:01:00+08:00","image":"https://ghjayce.github.io/asset/blog/FhYnPBeIezDAGMZ0BQgUMjAyNDAzMDFfMTU0NzE4.jpeg","permalink":"https://ghbjayce.github.io/p/language/php/hyperf/hyperf-constants/","title":"hyperf constants源码分析"},{"content":"阅读说明 为了方便文章描述，文中词汇的含义、未提及的场景如下：\n内链图片：和站点同一个域名下的图片。 外链图片：和站点非同一个域名下的图片，通常以http开头的链接。 内联图片：文字和图片处于同一行。 图像组件：将图片处理成在页面中可以进行交互的组件。 图片交互效果：经过图像组件处理以后，在页面进行交互的效果。 文中的相对目录路径，如没有特殊说明，均以一个hugo项目为准，可以参考我的项目结构。 文字非常多，图片很少，大部分是干货和细节，请耐心阅读。\n太多字啦，让我直接看你的解决方案，它最好是改动小且不影响现有的功能。\n背景 在此之前使用了一段时间CaiJimmy/hugo-theme-stack的主题，发现它只支持内链图片生成图像组件，并不支持外链图片，意味着外链图片没有办法在页面内点击图片进行一些交互。\n比如我想放大某张外链图片，我得对着图片右键，然后在新的页面中打开，用浏览器的方式对这张图片进行放大，非常的不方便。\n虽然瑕不遮瑜，但在外链需求特别多，又不想使用内链方式（不想放在项目中增加项目的大小）的情况下还是会很抓狂，所以在早些时候，尝试寻找了一些解决办法，于是找到了这个讨论：引用于 cdn 的图片 没法生成图册吗？Discussion #659 · GitHub。\n看来不止我一个人有着同样的需求。\n不巧的是，作者没有直接给出具体的解决办法，只是提供了解决思路，对hugo模板语法、工作机制不熟的我看的是一头雾水，提问的老哥看起来好像是解决了问题，怎么不分享一下啊，好东西不能藏着啊喂。\n于是打算白嫖的发问一下，白嫖失败。\n那么就跟着作者的提示，着手捣鼓一下：\nlayouts/_default/_markup/render-image.html模板文件，hugo markdown渲染的钩子之一。 resource.GetRemote相关语法文档。 初步解决方案 就如我在讨论中提到的，我在layouts/_default/_markup/render-image.html钩子模板做了以下的修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{- $Permalink := .Destination | relURL | safeURL -}} {{- $image := \u0026#34;\u0026#34; -}} {{- if hasPrefix $Permalink \u0026#34;http\u0026#34; -}} {{- $image = resources.GetRemote $Permalink -}} {{- else -}} {{- $image = .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; (.Destination | safeURL)) -}} {{- end -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} ... 使用一段时间之后发现了以下的问题：\nQ1：外链的图片在启动服务(hugo server)的时候会将资源下载到resources/_gen/images目录下，然后观察渲染以后的img，链接的正是该目录下的图片，外链了个寂寞，还是会增加项目的大小 :(。 Q2：如果遇到图片下载超时，会出现服务启动不了的问题。 Q3：如果外链图片比较多，可能会导致启动服务缓慢。 这些问题的描述会有不恰当的地方，下面会有说明。\n因为影响还是比较大，还不如不改呢，所以我去除了这些改动，暂时放下了这个糟心的问题。\n再次捣鼓 正好最近有空，于是打算对hugo-theme-stack图库的实现研究一番，好好解决这个糟心的问题。\n并将研究过程、当中发现到的一些细节记录下来，写下这篇文章。\n研究 环境说明 hugo v0.113.0 hugo-theme-stack v3.21.0 图像库组件PhotoSwipe v4.1.3 分析 从头开始，要解决图像库支持外链图片，那么就要知道：\nhugo是怎么解析markdown中的image语法的？ 用的是哪个图像组件？怎么做到图片处理成组件的？在什么时候做了介入处理？ 在上文中我们知道，CaiJimmy/hugo-theme-stack主题中的layouts/_default/_markup/render-image.html对markdown渲染的img标签做了介入处理。\n为了确定使用的是哪个图像组件，看它渲染以后的img标签是怎样的，那就要做一个内链图片来观察下。\n梳理过程 img 处理成图像组件 通过Writing | Stack和Page bundles | Hugo得知内链图片和文章要放在同级目录。\n目录结构如下：\n1 2 3 4 5 6 7 8 content/ ├── posts │ ├── my-post │ │ ├── content1.md │ │ ├── image1.jpg │ │ ├── image2.jpg │ │ └── index.md | └── _index.md index.md内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- title: Test description: something date: 2023-12-07 slug: test image: image2.jpg --- ![img1](image1.jpg) ![img2](image2.jpg) External images: ![img3](https://cn.bing.com/th?id=OHR.CheetahDay_EN-CN5641048727_1920x1080.webp\u0026amp;qlt=50) ![img4](https://cn.bing.com/th?id=OHR.ManateeMama_EN-US7376333243_UHD.jpg\u0026amp;pid=hp\u0026amp;w=1920\u0026amp;h=1080\u0026amp;rs=1\u0026amp;c=4) 你会发现content1.md在页面上看不到生成的这篇文章。\n当你将my-post里面的index.md改成content2.md的时候，content1.md和content2.md生成的文章都能够在页面中看到了，为什么？ 而如果在my-post里新建一个_index.md，content1.md和index.md生成的文章也可以在页面中看到了，为什么？ 然后1和2中content2.md和index.md中的内链图片都失效了，为什么？ 这不是本文的重点，避免在这上面浪费时间，挖个坑，后续会写一篇文章专门介绍它。\n打开浏览器，我们看到内链图片和外链图片分别解析如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;div class=\u0026#34;gallery\u0026#34;\u0026gt; \u0026lt;figure class=\u0026#34;gallery-image\u0026#34; style=\u0026#34;flex-grow: 66; flex-basis: 160px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://xxxx/p/test/image1.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/p/test/image1.jpg\u0026#34; width=\u0026#34;667\u0026#34; height=\u0026#34;1000\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img1\u0026#34; class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;66\u0026#34; data-flex-basis=\u0026#34;160px\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;figcaption\u0026gt; img1 \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;figure class=\u0026#34;gallery-image\u0026#34; style=\u0026#34;flex-grow: 149; flex-basis: 359px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://xxxx/p/test/image2.jpg\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/p/test/image2.jpg\u0026#34; width=\u0026#34;1000\u0026#34; height=\u0026#34;667\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img2\u0026#34; class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;149\u0026#34; data-flex-basis=\u0026#34;359px\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;figcaption\u0026gt; img2 \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;img src=\u0026#34;https://cn.bing.com/th?id=OHR.CheetahDay_EN-CN5641048727_1920x1080.webp\u0026amp;amp;qlt=50\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img3\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://cn.bing.com/th?id=OHR.ManateeMama_EN-US7376333243_UHD.jpg\u0026amp;amp;pid=hp\u0026amp;amp;w=1920\u0026amp;amp;h=1080\u0026amp;amp;rs=1\u0026amp;amp;c=4\u0026#34; loading=\u0026#34;lazy\u0026#34; alt=\u0026#34;img4\u0026#34;\u0026gt; 通过在项目中搜索gallery-image，找到了themes/hugo-theme-stack/assets/ts/gallery.ts，一个TypeScript文件，从里面的代码看出使用的是PhotoSwipe图像组件。\n接着就是createGallery函数，看了下里面的代码的作用，猜测90%的可能性就是这里将img图片处理成图像组件的，也就是上面的HTML结构。\n处理时机 继续，是constructor(...)里面调用了这个函数，PHPer表示很熟悉，是一个构造函数。\n继续往上找，是themes/hugo-theme-stack/assets/ts/main.ts的init()方法中调用了上面的构造函数，在底部看到了window.addEventListener('load')调用了init()，这就是将图片处理成图像组件的时机。\n紧接着找到了themes/hugo-theme-stack/layouts/partials/footer/components/script.html，这里引入了main.ts，结合了页面渲染以后的结构进行比对，实锤了。\npartials是hugo的模板结构目录，相关文档。\n至此，猜测得到了证实，从markdown到img再到PhotoSwipe图像组件的实现过程，梳理完毕。\n解决 分析 render-image.html 模板语法、变量和函数代表的含义？ 做了哪些事情？ 源文件 以下是v3.21.0，layouts/_default/_markup/render-image.html的源码内容，贴上来方便查看。\n源文件仓库在这。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 {{- $image := .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; (.Destination | safeURL)) -}} {{- $Permalink := .Destination | relURL | safeURL -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} {{/* SVG and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryImage := false -}} {{- if $image -}} {{- $notSVG := ne (path.Ext .Destination) \u0026#34;.svg\u0026#34; -}} {{- $Permalink = $image.RelPermalink -}} {{- if $notSVG -}} {{- $Width = $image.Width -}} {{- $Height = $image.Height -}} {{- $galleryImage = true -}} {{- if (default true .Page.Site.Params.imageProcessing.content.enabled) -}} {{- $small := $image.Resize `480x` -}} {{- $big := $image.Resize `1024x` -}} {{- $Srcset = printf `%s 480w, %s 1024w` $small.RelPermalink $big.RelPermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $Permalink }}\u0026#34; {{ with $Width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryImage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.Width 100) $image.Height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.Width 240) $image.Height }}px\u0026#34; {{ end }} \u0026gt; 语法 {{- -}}和{{ }}的写法有什么不同？ 以if为例 {{- if ... -}}：在该语法中，横杠 - 的作用是去除 if 语句前后的空白字符（包括换行符、空格等），以保持输出结果更加紧凑。 {{ if ... }}：在标准的 if 语句语法中，并没有 - 符号。这意味着在渲染过程中，会保留 if 语句前后的空白字符。 .Page.Resources.GetMatch有什么用？ .Page.Resources 是返回页面资源集合。 resource.GetMatch 简单点说就是寻找某个匹配规则的资源文件。 .Destination 获取[](xxx)中的xxx链接。 | 管道操作符。 safeURL 将字符串处理成安全的URL字符串。 relURL 返回相对URL，例如http://xxx.com/p/test/image1.jpg得到/p/test/image1.jpg。 .PlainText 获取[](xxx \u0026quot;text\u0026quot;)中的text。 safeHTML 将字符串处理成安全的HTML字符串。 ne 比较两个值是否相等。 path.Ext 获取后缀，例如/p/test/image1.jpg得到image1.jpg。 .Page.Site.Params.imageProcessing.content.enabled获取hugo.xxx中的配置项，.Page.Site.Params。 default 第二个参数未设置时，使用第一个参数。 with 表达式为true时进入代码块，可以使用.代替表达式。 div 将一个数字除以一个或多个数字。 mul 将多个数字进行相乘返回积。 作用 结合以上，render-image.html主要做了以下几件事：\nE1：从页面资源集合中找到名称一致的图片。 E2：如果hugo.yaml文件中imageProcessing.content.enabled的配置开启了，Resize会对这张图片进行裁剪，裁出480宽、1024宽的两张图片并放到了resources/_gen/images/post/your_post_slug_name/目录下。 E3：$galleryImage是能否生成图像库组件的关键，它为img添加了关键的属性。 这里需要解释和纠正一下初步解决方案中，我对Q1的描述：\nE2回答了为什么resources/_gen/images/目录下会有图片的原因。 hugo server启动的时候因为resources.GetRemote的关系，它会去访问这张图片，而且在首次访问成功后会对这个图片进行缓存（但至于缓存在哪里，我也想知道，如果你知道的话请告诉我），因为在首次之后再执行hugo server会非常快，得到证实。 很抱歉我在早期的解决反馈中做了一些过于草率的结论。 解决方案 在原基础上支持 效果 先来看效果，经过我几天简单测试和使用下来，在文章内使用内链图片和外链图片，均能够生成图像库组件的交互效果。\n我的改动 我在源文件的基础上，增加了resources.GetRemote获取外链图片的部分，并且在hugo.yaml中增加了一个params.render.image.extranelLink.enabled开关进行控制，是否启用外链图片的逻辑。\n1、layouts/_default/_markup/render-image.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 {{- $Permalink := .Destination | safeURL -}} {{- $image := \u0026#34;\u0026#34; -}} {{- if and (hasPrefix $Permalink \u0026#34;http\u0026#34;) (default false .Page.Site.Params.render.image.extranelLink.enabled) -}} {{- with resources.GetRemote $Permalink -}} {{- with .Err -}} {{- $warnMsg := printf \u0026#34;%s\u0026#34; $Permalink -}} {{- warnf \u0026#34;%s.\\nPlease check the link: %s\\n\u0026#34; . $warnMsg -}} {{- else -}} {{- $image = . -}} {{- end -}} {{- else -}} {{- warnf \u0026#34;Unable to get remote resource %q\u0026#34; $Permalink -}} {{- end -}} {{- else -}} {{- $image = .Page.Resources.GetMatch (printf \u0026#34;%s\u0026#34; $Permalink) -}} {{- if $image -}} {{- $Permalink = $image.RelPermalink -}} {{- end -}} {{- end -}} {{- $alt := .PlainText | safeHTML -}} {{- $Width := 0 -}} {{- $Height := 0 -}} {{- $Srcset := \u0026#34;\u0026#34; -}} {{/* SVG and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryImage := false -}} {{- if $image -}} {{- $notSVG := ne (path.Ext .Destination) \u0026#34;.svg\u0026#34; -}} {{- if $notSVG -}} {{- $Width = $image.Width -}} {{- $Height = $image.Height -}} {{- $galleryImage = true -}} {{- if (default true .Page.Site.Params.imageProcessing.content.enabled) -}} {{- $small := $image.Resize `480x` -}} {{- $big := $image.Resize `1024x` -}} {{- $Srcset = printf `%s 480w, %s 1024w` $small.RelPermalink $big.RelPermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $Permalink }}\u0026#34; {{ with $Width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $Srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryImage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.Width 100) $image.Height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.Width 240) $image.Height }}px\u0026#34; {{ end }} \u0026gt; 2、hugo.yaml 以下只显示改动的地方\n1 2 3 4 5 6 7 8 params: imageProcessing: content: enabled: false render: image: extranelLink: enabled: true 发现的问题 1、问题NQ1：\n如果你发现图片并没有生成组件，可以检查下markdown语法里图片是不是完全独占一行的，如果不是，把它改成独占一行再去页面查看，出来了对不对。\n这是因为themes/hugo-theme-stack/assets/ts/gallery.ts中createGallery函数里有这么一段代码：\n1 2 let isNewLineImage = paragraph.classList.contains(\u0026#39;no-text\u0026#39;); if (!isNewLineImage) continue; 结合注释和它解析之后的HTML结构得知，它不支持内链图片生成图像组件（无论是内链图片还是外链图片），因为这会影响到内联图片的效果。\n这个问题在我改动之前就已经存在了，毕竟解析之后的结构和内联图片效果肯定是冲突的，很遗憾内联图片不支持图像组件的交互效果。\n2、问题NQ2：\n如果外链图片比较多的情况下，hugo server启动的时候确实会有时间性能的损耗，毕竟它要对每一张图片都进行访问。\n如果你的外链图片访问足够快的话，不存在任何问题。\n如果你像我一样外链图片访问可能会存在缓慢的情况下，那么在启动的时候可能会遇到超时的问题，导致启动失败，错误内容如下：\n1 ERROR 2023/12/05 21:17:31 render of \u0026#34;page\u0026#34; failed: \u0026#34;/project/themes/hugo-theme-stack/layouts/_default/baseof.html:4:12\u0026#34;: execute of template failed: template: _default/single.html:4:12: executing \u0026#34;_default/single.html\u0026#34; at \u0026lt;partial \u0026#34;head/head.html\u0026#34; .\u0026gt;: error calling partial: partial \u0026#34;head/head.html\u0026#34; timed out after 30s. This is most likely due to infinite recursion. If this is just a slow template, you can try to increase the \u0026#39;timeout\u0026#39; config setting. 有三种解决办法：\n解决掉外链图片访问慢的问题。 在平常写文章的时候，把params.render.image.extranelLink.enabled关闭，没错外链图片没有交互效果了，但你只是想写文章而已，写完以后可以再打开。 不需要解决，大可以挑一个网络顺畅的时刻去做这件事，之后再启动时它会使用缓存，启动会很快，也就首次成功启动会受影响而已。 总结一下：\nNQ1：内联图片不支持图片交互效果，这在我改动之前就已经存在的问题。 NQ2：hugo server首次启动时会有影响，但外链图片访问足够快的情况下，不成问题，唯一需要处理的是外链图片超时的问题，解决方案如下： 解决掉图片访问缓慢的问题。 平时写文章不用时可以关闭，需要用时再打开。 挑网络顺畅的时候完成首次启动，之后的启动都会走缓存，启动会非常快。 更换组件 这个我就不展开了，因为解决方案一已经能够满足我的需求了，除非你想内联图片也需要图片交互效果，并且能够彻底解决掉启动缓慢的问题。\n留到下次有这个需求时我再回来填坑。\n届时我将会采用fengyuanchen/viewerjs的组件。\n致谢 能看完这篇文章很不容易，为你的耐心鼓掌。\n","date":"2023-12-05T11:45:25+08:00","image":"https://ghjayce.github.io/asset/blog/z4EOqI2zCdlD5ce5EawUMjAyNDAyMjVfMTU1MjIy.png","permalink":"https://ghbjayce.github.io/p/static-site-generator/hugo/hugo-theme-stack-gallery-study/","title":"Hugo Theme Stack图库是怎么工作的？怎样才能支持外链图片？"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 下面是我从历年试题和书本中整理出来的重点。Enjoy it!\n如果这篇文章对你有帮助，也请你将这篇文章分享给有需要的人。\n第一章 概论 数据结构是计算机组织数据和存储数据的方式。 数据结构是指一组相互之间存在一种或多种特定关系的数据的组织方式和它们在计算机内的存储方式，以及定义在该组数据上的一组操作。 1976年瑞士计算机科学家尼克劳斯·维尔特（Niklaus Wirth）曾提出一个著名的公式：算法 + 数据结构 = 程序。 数据由若干个数据元素组成，数据元素由若干个数据项组成。 逻辑结构、存储结构、运算\n数据的逻辑结构是指数据元素之间的逻辑关系。逻辑关系是指数据元素之间的关联方式或邻接关系。 四类基本的逻辑结构：集合、线性结构、树形结构、图结构。 集合结点之间没有邻接关系；线性结构结点之间一对一的关系；树形结构结点之间一对多的关系；图结构结点之间多对多的关系。 与数据元素本身的形式、内容、相对位置、个数无关的是数据的逻辑结构。 数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。 存储结构一般有四种形式：顺序存储、链式存储、索引存储、散列存储。 运算是指在某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象。 运算的实现是指该运算的算法；算法指的是求解给定问题所需的处理步骤及其执行顺序。 时间复杂度、空间复杂度\n算法时间复杂度指的是算法在给定输入下的计算量。 算法的空间复杂度指的是算法中除了输入数据占用的存储空间之外所需的附加存储空间的大小，即所需的存储量。 在估算算法空间复杂度时，一般只需要分析辅助变量所占用的空间。 常数阶 $O(1)$，对数阶 $O(log_{2}n)$，线性阶 $O(n)$，线性对数阶 $O(nlog_{2}n)$，多项式阶有：平方阶 $O(n^2)$、立方阶 $O(n^3)$、K次方阶 $O(n^k)$，指数阶 $O(2^n)$。 第二章 线性表 顺序表\n顺序表插入新元素，需要移动元素的个数为 $n-i+1$（i为下标从1开始就需要+1，否则不需要）。 顺序表删除元素，需要移动元素的个数为 $n-i$（i为下标，从1开始）。 顺序表插入算法的平均移动次数约为 $\\frac{n}{2}$，算法时间复杂度为 $O(n)$。 顺序表删除算法的平均移动次数约为 $\\frac{n-1}{2}$（下标从0开始），算法时间复杂度为 $O(n)$。 单链表和双向循环链表插入操作顺序不可以颠倒。 双向循环链表删除操作顺序可以颠倒。 用顺序存储实现的线性表称为顺序表，一般使用数组来表示。 链表\n在单链表中，指针p所指的结点为最后一个结点的条件是p-\u0026gt;next == NULL。 第三章 栈、队列和数组 栈和队列可看作是特殊的线性表，运算受限的线性表。 函数的嵌套调用和程序递归的处理都是用栈来实现的。操作系统中进程调度、网络管理中的打印服务等都是用队列来实现的。 术语： 进栈：指插入运算。出栈：指删除运算。栈顶：允许进栈和出栈的一端。栈底：栈顶的另一端。 空栈：不含任何数据元素的栈。栈顶元素：处于栈顶位置的数据元素。 上溢：栈的容量已经满了，此时再进行进栈就会发生上溢。下溢：空栈做出栈就会产生下溢，因为栈中没有任何数据元素。 栈、双栈的运算\n顺序栈使用数组实现，栈顶top默认为下标0，判断栈空的核心stack-\u0026gt;top == 0，判断栈满的核心stack-\u0026gt;top == maxSize -1，进栈操作的核心stack-\u0026gt;top++; stack-\u0026gt;data[stack-\u0026gt;top] = x;，出栈操作的核心stack-\u0026gt;top--;。 双栈判断上溢的条件为：$top+1=top2$。 队列的基本概念\n栈是后进先出（Last In First Out），队列是先进先出（First In First out）。 入队列：在队列尾部进行插入运算；出队列：在队列首部进行删除运算。 链队列是一个带有头结点的单链表组成，队列首部的指针指向头结点，头指针指向首结点，队列尾部的指针指向尾结点，队列空的时候，队列首部和尾部的指针均指向头结点。 队列、循环队列的运算\n顺序队列入队列操作的核心SQ.rear = SQ.rear + 1; SQ.data[SQ.rear] = x;，出队列操作的核心SQ.front = SQ.front + 1。 循环队列解决了假溢出问题，队首和队尾都指向下标0的位置，少使用一个元素空间以解决无法区分空和满的情况。 循环队列入队列操作的核心CQ.rear = (CQ.rear + 1) % maxSize; CQ.data[CQ.rear] = x;，出队列操作的核心CQ.front = (CQ.front + 1) % maxSize;，队列满的条件(CQ.rear + 1) % maxSize == CQ.front;，队列空的条件CQ.rear == CQ.front;。 数组、矩阵\n计算数组元素的存储地址公式 $(n * i + j) \\times k$，其中m是行数量，n是列数量，i是在m行的下标，j是在n列的下标，k是每个元素占用的存储大小。 可将 $n^2$ 个元素压缩存储到含有 $\\frac{n(n + 1)}{2}$ 个元素的一维数组中。 假设m行n列的矩阵有t个非零元素，当$t\u0026laquo;m*n$时，则称矩阵为稀疏矩阵；三元组表示法：((i, j, v), (i, j, v), ...)，其中i是行，j是列，v是非零元素的值。 第四章 树和二叉树 术语： 结点的度：某一个结点有多少个直接孩子。树的度：结点的度的最大值，也就是所有结点里直接孩子最多的那个。 结点的层次：把一棵树比作一个层级金字塔，从根结点为1，每下一层+1，数到结点所在的层级。树的高度/深度：结点的层次的最大值，也就是树一共有多少层。 二叉树的基本概念\n一棵树的结点个数最少为0；二叉树第 i（i≥1）层上至多有 $2^{i-1}$ 个结点；深度为 k（k≥1）的二叉树至多有 $2^{k}-1$ 个结点。 对任何一棵二叉树，若度数为0的结点个数为$n_0$，度数为2的结点个数为$n_2$，则 $n_0=n_2+1$。 含有n个结点的完全二叉树的深度为 $⌊log_2n⌋+1$。 对于完全二叉树，根结点为1对结点进行编号，$i\u0026gt;1$ 时（i是指被编号的那个结点），结点双亲的编号为 $⌊\\frac{i}{2}⌋$。 二叉树不是完全二叉树，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 二叉树的先序遍历次序为根左右，中序遍历次序为左根右，后序遍历次序为左右根，层次遍历次序为每层从左往右。 存储结构\n具有n个结点的二叉树（链表结构）中，有 $2n$ 个指针域，其中只有 $n-1$ 个用来指向结点的左、右孩子，其余的 $n + 1$ 个指针域为NULL。 树的存储结构分别有：孩子链表表示法、孩子兄弟链表表示法、双亲表示法。孩子兄弟链表的结构形式与二叉链表完全相同。 树和二叉树\n树转换成二叉树： 加线，所有兄弟结点之间加一条线，彼此连接起来。 抹线，除了结点的第一个左孩子，其他孩子与结点的连线全部抹掉。 旋转，以根节点为轴心，对树进行顺时针的适当旋转。 森林转换成二叉树： 将森林中的每棵树转换成二叉树。 加线，转换以后的二叉树，从第二棵二叉树开始，将其根节点作为前一棵二叉树根结点的右子树，以此类推。 二叉树转换成森林： 抹线，断开根结点与右孩子的连线，此时得到两棵二叉树。 抹线再加线，二叉树根节点的左子树的右子树们均断开连接，改成均与根节点之间连接，如果根节点有右子树，重复步骤1的操作。 剩下的二叉树重复按以上步骤进行处理。 判断树和哈夫曼树\n一棵判定树描述了一种分类方法；用于描述分类过程的二叉树称为判定树。 有n个叶子结点的哈夫曼树，其结点的总数为 $2n-1$。 第五章 图 术语： 顶点：即图中的圆圈。边：即图中圆圈之间的连线，也称为顶点的偶对。权：即连线旁边的数值，也称为边的权。 带权图：每条边都带有权的图。有向图：顶点的偶对是有序的。无向图：顶点的偶对是无序的。 弧：有向图的边又称为弧。弧头：表示弧的终点，即弧有箭头的一端。弧尾：表示弧的始点/起点。 有向完全图：任何两个顶点之间都有弧的有向图。无向完全图：任何两个顶点之间都有边的无向图。 顶点的度：与该顶点相关联的边的数目。 入度：把以顶点v为终点的弧的数目称为v的入度，记为ID(v)。 出度：把以顶点v为始点的弧的数目称为v的出度，记为OD(v)。 路径：从一个顶点x到另一个顶点y之间的路线。路径长度：路径上边/弧的数目。 简单路径：序列中顶点不重复出现的路径。回路：第一个顶点和最后一个顶点相同的路径，也称为环。简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。 连通：顶点x到顶点y有路径，则称顶点x和顶点y是连通的。 连通图：图中任意两个顶点都是连通的。连通分量：无向图中的极大（最大）连通子图。 强连通相关术语含义与连通一样，只是强连通用于描述有向图，不做赘述。 有序偶对用尖括号\u0026lt;\u0026gt;括起来，无序偶对用圆括号()括起来。 无向图中一个顶点的度是指图中与该顶点相邻接的顶点数。 一个具有n个顶点的有向完全图的弧的数量为：$P_{n}^{2}=n(n-1)$；一个具有n个顶点的无向完全图的边的数量为：$C_{n}^{2}=\\frac{n(n-1)}{2}$。 存储结构\n邻接表是顺序存储与链式存储相结合的存储方法。 无向图的邻接矩阵是一个对称矩阵，有向图的邻接矩阵是一个稀疏矩阵。 在含n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为$n^{2}-2e$；而有向图的邻接矩阵中，零元素个数为$n^{2}-e$。 遍历\n图的遍历方法有两种：深度优先搜索DFS、广度优先搜索BFS。 图的遍历操作类似于树的遍历操作；深度搜索的顶点的访问序列不是唯一的。 深度优先搜索类似于树的先序遍历；广度优先搜索类似于树的层次遍历。 以邻接表为存储结构，深度优先搜索算法的时间复杂度是$O(n+e)$，其中n为图的顶点数，e为图的边数。 以邻接矩阵作为存储结构，深度优先搜索算法的时间复杂度是$O(n^2)$，其中n为图的顶点数。 应用\n一个图的最小生成树是图所有生成树中权总和最小的生成树；最小生成树有两种算法：普里姆Prim算法、克鲁斯卡尔Kruskal算法。 克鲁斯卡尔Kruskal方法的思想，初始时将每个顶点看成一个单独的连通分量，找所有连通分量之间的权值最小的一条边，将该边添加到两个连通分量中，并合并成一个新的单独的连通分量，重复这个过程，直到所有顶点最终形成一个连通分量。 最短路径算法可以采用迪杰斯特拉Dijkstra算法，思想是按照最短路径长度递增的方法产生从一点到其他顶点的最短路径。 完成拓扑排序的前提条件是AOV网中不允许出现回路。 以邻接表作为存储结构，拓扑排序算法的时间复杂度为$O(n+e)$，n是图的顶点个数，e是图的弧的数目。 第六章 查找 对于一种数据结构，查找表的逻辑结构是集合。 顺序表为(b1, b2, b3)，查找b1，b2，b3的概率分别为0.2、0.2、0.6，则顺序查找法的平均查找长度为$(0.2\\times3)+(0.2\\times2)+(0.6\\times1)=1.6$。 顺序表\n向一个长度为n的顺序表中第i($1{\\leq}i{\\leq}n$)个元素之前插入一个元素时，需向后移动$n-i+1$个元素。 从一个长度为n的顺序表中删除第i个元素($1{\\leq}i{\\leq}n$)时，需向前移动$n-i$个元素。 在长度为n的带有岗哨的顺序表中，进行顺序查找，查找不成功时，与关键字比较次数为$n+1$。 采用顺序查找方法查找长度为n的顺序表时，平均查找长度为$\\frac{(n+1)}{2}$。 二叉排序树\n中序遍历一棵二叉排序树可得到一个键值的升序序列。 二叉排序树的平均查找长度介于 $O(n)$ 和 $O(log_2n)$ 之间。 散列表、散列法、解决冲突方法\n散列法：数字分析法、除留取余法、平方取中法、基数转换法。 除留取余法$H(key)=key{\\quad}mod{\\quad}p(p{\\leq}n)$，p通常选小于散列表长度n的素数，如果p是偶数，得到的散列值总是偶数，如果是奇数则总是奇数。 解决冲突方法：线性探测法、二次探测法、链地址法、多重散列法、公共溢出区法。 非同义词之间对同一个散列地址的争夺现象称为堆积。 线性探测法容易产生堆积。二次探测法缺点不容易探测到整个散列表的所有空间。 链地址法实际上也可能存在堆积，退化成链表（书上未提及，仅个人观点）。 多重散列法优点不容易产生堆积，缺点计算量大。 公共溢出区法，在发生冲突的情况下，将同义词存入溢出表，基本表就不可能发生堆积（书上原话）。 要完全避免散列所产生的“堆积”现象，通常采用链地址法解决冲突（书中课后题的答案，按书中教的来）。 用线性探测法解决冲突，可能要探测多个散列地址，这些位置上的键值不一定都是同义词。 第七章 排序 稳定性是排序方法本身的特性，与数据无关。 当待排序序列已基本有序时，插入排序和交换排序比较有效（性能高）。当待排记录数量较大时，选择排序比较有效（性能高）。 插入排序\n插入排序方法有直接插入排序、折半插入排序、表插入排序、希尔排序。 直接插入排序类似图书馆整理图书的过程，时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是稳定的，不适宜n较大的序列。 交换排序\n交换排序方法有冒泡排序、快速排序。 冒泡排序时间复杂度为$O(n^2)$，空间复杂度$O(1)$，是稳定的。 快速排序实质上是对冒泡排序的一种改进。快速排序时间复杂度为$O(nlog_2n)$，最坏情况下时间复杂度近似$O(n^2)$，空间复杂度取决于实现的算法，是不稳定的，对数量n较小算法效果不明显，数量较大效果明显。 选择排序\n选择排序方法有直接选择排序、堆排序。 直接选择排序时间复杂度为$O(n^2)$，空间复杂度$O(1)$，是不稳定的，不适宜n较大的序列。 堆排序平均和最坏情况下时间复杂度都是$O(nlog_2n)$，空间复杂度为$O(1)$，是不稳定的，不适宜待排序记录较少时使用，记录数很多效果明显。 归并排序\n归并排序方法有有序序列的合并、二路归并排序。 有序序列的合并算法时间复杂度为$O(n-h+1)$。 二路归并排序时间复杂度为$O(nlog_2n)$，空间复杂度$O(n)$，是稳定的。 ","date":"2023-10-22T09:27:30+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/exam-focus/","title":"《数据结构导论》考试重点"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 阅读说明 以下排序方法均以按递增（即升序）排列的方式对序列进行排序。\n概述 排序就是将一组对象按照规定的次序重新排列的过程，是数据处理中一种很重要也很常用的运算。\n排序是为检索服务的，例如图书馆书的摆放是按照索引号排序以后的结果，再例如电话号码簿、字典等。\n而排序又分为两大类：\n内部排序（Internal Sorting）：待排序的记录全部存放在计算机内存中进行的排序过程。 外部排序（External Sorting）：待排序的记录数量很大，内存不能存储全部记录，需要对外存进行访问的排序过程。 排序的方法有很多，例如插入排序、交换排序、选择排序和归并排序等等。\n而排序方法一般会关注以下指标：\n稳定性：对于相当的元素，排序前和排序后的相对位置（位置关系）是否有发生变化，如果没有，则说明排序的方法是稳定的，否则是不稳定的。 例如一个序列中有两个66，分别用R0和R1表示，排序前R0在R1的前面，而稳定是指排序以后R0仍然在R1的前面。 稳定性是排序方法本身的特性，与数据无关，也就是说，一种排序方法如果是稳定的，则排序处理对数据序列中的所有数据都是稳定的，相反如果有一组数据出现不稳定，该方法就是不稳定的。 时间复杂度和空间复杂度。 插入排序 常用的插入排序有：\n直接插入排序，文中只介绍了这一种。 折半插入排序。 表插入排序。 希尔排序。 直接插入排序 Straight Insertion Sorting是一种简单的排序方法，它的思想是将未排序区的元素逐个有序地插入到已排序区的合适位置，并始终保持已排序区的有序性。\n直接插入排序类似图书馆中整理图书的过程。\n步骤如下：\n将待排序的序列分成已排序区和未排序区。 从未排序区中取出第一个元素，在已排序区中，从后往前比较，小的话就往前面的位置放，直到找到插入位置并进行插入操作，此时已排序区依然是有序的。 重复步骤2，直到所有元素都被插入到已排序区中。 例如有一个待排序的序列：(45, 38, 66, 90, 88, 10, 25, 45)，序列中有两个45以说明算法的稳定性。\n排序过程如下：\n已排序区为空，未排序区为如上序列。 未排序区中取出第一个元素45，直接放进已排序区中。 取出第二个元素38，在已排序区中从后往前对元素进行比较，即45和38比，大了，让38排在前面。 此时已排序区序列：(38, 45)。 取出第三个元素66，比45大，排在45的后面，90同理，不做赘述。 此时已排序区序列：(38, 45, 66, 90)。 取出第五个元素88，90和88比，大了，再往前找一个元素进行比较，即66和88比，小了，说明再往前的元素都是比66还要小，无需再往前找了，就排在90的前面。 此时已排序区序列：(38, 45, 66, 88, 90)。 后面的元素同理，不再赘述。 给出具体的算法，说明：\n序列R的0的位置不使用，用于岗哨的作用。 n为表长。 1 2 3 4 5 6 7 8 9 10 11 12 13 void StraightInsertSort(List R, int n) { int i, j; for (i = 2; i \u0026lt;= n; i++) { R[0] = R[i]; j = i-1; while (R[0].key \u0026lt; R[j].key) { R[j+1] = R[j]; j--; } R[j+1] = R[0]; } } 该算法，R[0]的位置起到了两个作用：\n保存了R[i]位置的值，拿上面例子的步骤6为例，把已排序区中大于88的元素全部往后一个位置覆盖，当和66比较的时候结束了while循环，这个时候就从岗哨的位置即R[0]里取出88，避免了覆盖导致的丢失，最终放到了R[j+1]的位置，已排序区保持有序。 在while循环条件中起到了监视数组下标变量j是否越界，实现了自动控制while循环的结束，而不必特意去检查越界的情况。 一个字，妙 啊。\n总结规律：\n直接插入排序算法简单，易于理解，容易实现。 来看下指标： 45的相对位置没有变化，具有稳定性。 时间复杂度为O(n²)。 只需要一个记录的辅助空间，并不随循环的变化而导致空间的增加，空间复杂度为O(1)。 若待排序记录的数量很大时，一般不选用直接插入排序。 交换排序 交换排序的基本思想：比较两个记录键值的大小，如果结果是逆序，则交换这两个记录。\n递增排序，记录值小的放到前面，大的放到后面。 递减排序，大的放到前面，小的放到后面。 冒泡排序 冒泡排序Bubble Sorting是一种交换排序方法，其处理过程是：\n将第一个记录键值和第二个记录键值比较。 若为逆序，即第一个记录比第二个记录大，则交换这两个记录。 不为逆序，不操作。 然后继续比较第二个和第三个记录键值，依次类推，直至比较完最后一个记录键值。 以上过程称为第一趟起泡，作用是将记录键值最大的记录移到第n个位置上，即第n个位置已经是排序好的区域了。 第二趟起泡将从步骤1重新开始，直到未排序区域的最后一个记录键值结束。 重复以上过程，直到未排序区域仅剩下一个时，整个排序过程终止。 举个例子，现有一组待排序序列：(45，38，66，90，88，10，25，45)，排序过程如下：\n第一趟排序结果：38，45，66，88，10，25，45，90。 45和38比较，45大，交换两者位置。 交换后序列：38，45，66，90，88，10，25，45。 45和66比，无逆序，不操作。 66和90比，不操作。 90和88比，90大，交换位置。 交换后序列：38，45，66，88，90，10，25，45。 90和10比，90大，交换位置。 交换后序列：38，45，66，88，10，90，25，45。 后者同理，不再赘述。 第二趟排序结果：38，45，66，10，25，45，88，90。 第三趟排序结果：38，45，10，25，45，66，88，90。 第四趟排序结果：38，10，25，45，45，66，88，90。 第五趟排序结果：10，25，38，45，45，66，88，90。 第六趟排序结果：10，25，38，45，45，66，88，90。 第七趟排序结果：10，25，38，45，45，66，88，90。 算法如下：\n1 2 3 4 5 6 7 8 9 10 11 void bubbleSort(int arr[], int n) { for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = 0; j \u0026lt; n - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } 总结：\n冒泡排序时间复杂度为$O(n^2)$。 冒泡排序是稳定的排序方法。 快速排序 快速排序Quick Sorting是交换排序的一种，实际上是对冒泡排序的一种改进。思想是：\n选择排序 直接选择排序 堆排序 归并排序 二路归并排序 ","date":"2023-10-20T09:27:30+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter7/","title":"第七章 排序 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 分析查找运算的时间性能可以将“查找成功时的平均查找长度”作为评价查找算法时间性能的度量。\n静态查找表 书中主要讨论查找操作在不同存储结构下的实现。\n顺序表上的查找 静态查找表最简单的实现方法是以顺序表作为存储结构。\n用C语言表示如下：\n1 2 3 4 5 6 7 8 9 10 const int maxSize = 20; typedef struct { int key; } tableEle; typedef struct { tableEle data[maxSize+1]; int lastEleIndex; // 最后一个数据元素的下标 } sequenceTable; data[0]用于设置“岗哨”，不存储数据元素，以便简化查找运算的实现。\n在以上存储结构上实现顺序查找Sequential Search操作的步骤如下：\n从表的最后一个数据元素位置开始，从后往前依次将各个位置的数据元素和给定值比较。 如果相等，则查找成功，返回该下标位置作为结果。 如果查找到第一个元素，仍然与给定值不等，则查找不成功。 算法如下\n1 2 3 4 5 6 7 8 9 10 // 返回0表示查找失败。 int searchSequenceTable(sequenceTable table, int key) { table.data[0].key = key; i = table.lastEleIndex; while (table.data[i].key != key) { i--; } return i; } 该算法巧妙利用data[0]存储待查找的key，从而免去了每次查找都要检测表是否查找完毕，保证了while循环一定会终止，起到了岗哨的作用，这一改进对一次查找所花费的平均时间减少一半。\n因此对于分析查找运算的时间性能，通常用“数据元素的值与给定值的比较次数”作为衡量查找算法的好坏依据，其中的比较次数称为查找长度。\n例如：\n若待查找值在顺序表的第n个位置上，则查找长度为1。 而待查找值在顺序表的第1个位置上，查找长度为n。 那么可以将查找成功时的平均查找长度记为ASL，作为评价查找算法时间性能的度量。\n公式为：\n$ASL=\\displaystyle \\sum^{n}_{i=1}P_iC_i$\n$P_i$：查找第i个元素的概率，即给定值与顺序表中第i个元素值相等的概率，且$\\displaystyle \\sum^{n}_{i=1}P_i=1$。 $C_i$：表示在找到第i个元素时，顺序表中值与给定值已进行比较的个数。 假设顺序表为(b1, b2, b3)，查找b1，b2，b3的概率分别为0.2、0.2、0.6，则顺序查找法的平均查找长度为：\n$(0.2\\times3)+(0.2\\times2)+(0.6\\times1)=1.6$，即平均需要1.6次与给定值的比较才能找到待查找元素。\n由于多种因素的影响，$P_i$的值是难以确定的，通常假设$P_i$概率相等，即对所有i，有$P_i=\\frac{1}{n}$，并在此假设下确定查找算法的平均查找长度，因此得到顺序查找算法的平均查找长度为： $$ASL=\\displaystyle \\sum^{n}_{i=1}\\frac{1}{n}\\times(n-i+1)=\\frac{n+1}{2}$$\n有序表上的查找 二分查找 有序表：顺序表中的数据元素按照值的大小顺序排列。\n思想：在有序表中，用给定值和表中间位置的值进行比较，确定值所在的区间，然后逐步缩小查找区间，重复这个过程直到找到或者确认找不到为止，简单点说就是每找一次，区间缩小为原来的二分之一，因此得名二分查找。\n例如《幸运52》节目中的“看商品猜价格（13:40）”环节里，可以很好地应用二分查找的思想猜价格。\n例如有一个有序表：(10, 13, 17, 20, 30, 55, 68, 89, 95)，需要找17的值，以下是过程：\n确定搜索区间，low为1，即10的位置，high为9，即95的位置，区间就是[1, 9]。 取区间的中间位置，$(1+9)\\div2=5$，也就是30，发现大了，往左重新确定搜索区间。 接下来要搜索的区间是[1, 4]。 取中间位置，$(1+4)\\div2=2.5$，向下取整，为2，也就是13，发现小了，往右重新确定搜索区间。 接下来要搜索的区间是[3, 4]。 取中间位置，$(3+4)\\div2=3.5$，为3，也就是17，成功找到。 总结规律：\n二分查找的查找长度不超过⌊log2n⌋-1。 二分查找的平均查找长度为：$ASL_b = \\frac{n+1}{n}log_2(n + 1) - 1$。 当n较大时可得：$ASL_b \\approx log_2(n + 1) - 1$。 因此二分查找算法的时间复杂度为O(logn)。 散列表 用散列技术实现动态查找表，通过使数据元素的键值和存储位置之间建立某种联系，以减少比较次数。\n本文中键值是指一个东西，键值和值是两个东西。例如拿数组来说，键值是指下标，值就是下标指向的值。\n散列函数：数据元素的键值和存储位置之间建立的对应关系，也称为哈希（hash）函数。 散列值：经过散列函数处理以后的值，也称哈希值、哈希码。 散列：指用键值通过散列函数来获取存储位置的映射过程。 散列地址：指其中的存储位置。 散列表（Hash Table）：通过散列进行存储的方式，即这种存储结构。 冲突：也称哈希冲突，设有散列函数H，键值key有k1、k2，k1≠k2，冲突是指$H(k1)=H(k2)$。 即不同的键值散列到了同一个存储位置上。 这种情况在实际应用中经常出现，只能尽可能减少而不能完全避免。 因此使用散列技术时需要考虑两个问题：\n如何构造均匀的散列函数？ 用什么方法有效地解决冲突？ 散列法 数字分析法 数字分析法（Digit Analysis Method），大概说一下它的思想：\n将键值经过转换成数字。 例：abc转换成了301482。 再将数字进行分析，取出这些数字或者这些数字中的一部分。 例：将这些数字拆成单独的一个个数字，3，0，1，4，8，2。 将这些数字通过某种方式组织成一个值，这个值就是散列值。 例：把这些数字加起来，得到18。 除留余数法 是一种简单有效且最常用的方法。\n它的基本思想是：\n将键值转换成非负整数。 将该整数除以n（一般是散列表的长度），并取余数，这个余数就是散列值。 例如：整数37，n是10，37除以10，得到商3和余数7。 这个过程在C语言中可以用%进行运算。 在书中的表示是：$H(key) = key {\\quad} mod {\\quad} p(p{\\leq}n)$\nmod是指取余运算。 p是指除数（正整数）。 该方法对p的选取比较关键，通常选n为小于散列表长度的素数。\n素数是指除了1和自身，再没有其他正整数能够整除它。\n例如2、3、5、7、11都是素数。 如果p选的不合适的情况下，容易发生冲突，会遇到以下的问题：\n遇到奇数键值，散列值总是得到奇数。 遇到偶数键值，散列值总是得到偶数。 平方取中法 平方取中法（Square-Then-Choose Method）是一种简单的伪随机数生成算法。\n它的基本思想是：\n先将某个种子值进行平方运算。 再从中间选取若干位作为新的种子值。 重复以上过程直到得到想要的随机数。 而用在散列函数中，因为计算简单，也是一种较为常用的方法。\n一般步骤如下：\n将键值转换为一个初始种子值x0，x0是数字。 对x0进行平方运算，得到x1。 从x1的中间取出若干位作为值，这个值就是散列值。 基数转换法 \u0026hellip;\n散列冲突解决 冲突解决的核心思想：给冲突的键值找一个空闲的散列地址，如果仍然冲突，重复这个过程，直到不发生冲突为止。\n那么接下来就是介绍都有哪种方式去找一个空闲的散列地址。\n线性探测法 设H(key)=d，d是散列值，散列表容量为m，那么线性探测法找一个空闲的散列地址遵循以下的规律：\nd+1。 d+2。 d+3。 \u0026hellip;。 m-1。 0。 1。 2。 \u0026hellip;。 d-1。 举个例子，有长度13（即m=13）的散列表，存储地址的下标有0-12，采用除留余数法进行散列，表中已有16、30、54的元素，分别位于下标为3、4、2的存储空间。\n此时插入一个键值为29的元素，散列函数求出散列地址为3，即下标为3，而下标为3已经被占用了，采用线性探测法进行冲突解决，过程如下：\n进行第一次找空闲空间，d+1，即3+1，找到了下标为4的空间，发现仍然被占用。 继续第二次找空间空间，d+2，即3+2，找到了下标为5的空间，是空闲的，那就将29放到这个空间里。 线性探测法：当键值冲突时，将得到的散列值按照顺序依次往后寻找空闲的空间，直到散列值下标的前一个空间为止。\n可以看出寻找空闲散列地址的计算过程（书上称为生成后继散列地址）还是很简单的。\n但是，存在一个问题：以键值16和29为例，它们并不相同（书上称为不是同义词）却发生了冲突。\n这种非同义词之间对同一个散列地址的争夺现象称为堆积。\n因为某个键值冲突而被安排到一个空闲空间，而本该被分配到这个空闲空间的键值出现时，又因为被占用，而需要重新寻找空闲空间。\n这个方法实际上非常容易出现堆积现象，意味着插入时间复杂度非常高，特别是在散列表快满了的时候。\n二次探测法 思想：生成的后续散列地址不是连续的，而是跳跃式的，目的是减少堆积问题。\n二次探测法找一个空闲的散列地址遵循以下的计算方式： $$d_0 = H(key)$$ $$d_i = (d_0 \\pm i){\\quad}mod{\\quad}m$$ 其中i的规律是：\n$i = 1^2$ $i = -1^2$ $i = 2^2$ $i = -2^2$ $i = 3^2$ $i = -3^2$ \u0026hellip; $i = {\\pm}k^2(k \\leq\\frac{m}{2})$ 举个例子，有长度11（即m=11）的散列表，存储地址的下标有0-10，采用除留余数法进行散列，序列为：（20，38，16，27，5，23，56，29），建立出对应的散列表以及计算出等概率的情况下查找成功的平均查找长度。\n以下是过程：\n20取余，得到下标9。 查找长度为1，经过1次散列函数才找到。 38取余，得到下标5。 16取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间空闲可用（以下可用时不再赘述）。 查找长度为2，经过2次散列函数才找到（以下同理不再赘述）。 27取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间被（16）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标4。 5取余，得到下标5，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标6，空间被（16）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标4，空间被（27）占用。 第三次空闲空间：$(5 + 2^2){\\quad}\\%{\\quad}11$，得到下标9，空间被（20）占用。 第四次空闲空间：$(5 - 2^2){\\quad}\\%{\\quad}11$，得到下标1。 23取余，得到下标1，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标2。 56取余，得到下标1，发生冲突。 寻找第一次空闲空间：$(5 + 1^2){\\quad}\\%{\\quad}11$，得到下标2，空间被（23）占用。 第二次空闲空间：$(5 - 1^2){\\quad}\\%{\\quad}11$，得到下标0。 29取余，得到下标7。 得出序列：\n下标 0 1 2 3 4 5 6 7 8 9 10 序列 56 5 23 27 38 16 29 20 查找长度 1 1 2 3 5 2 3 1 等概率情况下查找成功的平均查找长度为：$ASL=\\frac{1+1+2+3+5+2+3+1}{11}=\\frac{18}{11}$。\n链地址法 多重散列法 ","date":"2023-10-19T12:23:25+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter6/","title":"第六章 查找 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 为了方便文章表述，以下内容有一些调整：\n书中顶点v0、v1、v2，在文中以v0、v1、v2的方式进行描述（文字以及配图）。 概要 概念 应用背景 假如有这样一个问题，在N个城市间建立通信网络，使得其中任意两个城市之间有直接或间接的通信线路，假设已知每两个城市之间通信线路的造价，要求找出一个总造价最低的通讯网络。\n当N很大时，这个问题十分复杂，就需要用到计算机来求解，而使用到的数据结构就是图结构。\n这里有几个需要解决的问题：\n如何描述该问题的数据？ 如何在计算机中存储数据？ 解决问题的算法是什么？ $$图1$$\n顶点：即上图的圆圈。 如图1a)，v0、v1、v2等。 在上面的例子圆圈代表一个城市。 边：即上图圆圈之间的连线，也称为顶点的偶对。 如图1a)，v0和v1之间的连线。 权：即连线旁边的数值，也称为边的权。 如图1a)，v0和v1的权为50。 在实际应用中，权可以表示一个顶点到另一个顶点的距离、代价或耗费等。 带权图：每条边都带有权的图。 如图1a)。 $$图2$$\n图Graph由两个集合V和E组成，记为$G=(V, E)$，其中：\nV是顶点的有穷非空集合，一般表示为：V = {v0, v1, v2}。 E是边的集合，一般表示为：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v2\u0026gt;}。 有向图：顶点的偶对是有序的。 有序偶对用尖括号括起来，例：\u0026lt;v0, v1\u0026gt;，含义是从顶点v0到顶点v1有一条边。 如图2a)是一个有向图，可以看到边是带有箭头的，即有方向的。 无向图：顶点的偶对是无序的。 无序偶对用圆括号括起来，例：(v0, v1)，含义与有向图一样。 如图2b)是一个无向图。 弧：有向图的边又称为弧（无向图可没有这种说法，大概用于区分的作用）。 弧头：表示弧的终点，即弧有箭头的一端。 例：\u0026lt;v0, v1\u0026gt;，图2a)的v0和v1的弧，v1就是弧头的一端。 弧尾：表示弧的始点/起点。 例：\u0026lt;v0, v1\u0026gt;，图2a)的v0和v1的弧，v0就是弧尾的一端。 无向图中(v0, v1)和(v1, v0)是同一条边，但对于有向图来说，\u0026lt;v0, v1\u0026gt;和\u0026lt;v1, v0\u0026gt;可是两条不同的弧。\n有向完全图：任何两个顶点之间都有弧的有向图。 一个具有n个顶点的有向完全图的弧的数量为：$n(n-1)$。 为什么？怎么得出来的公式？ 将所有顶点连接起来只需要顶点数量-1条边就足够了，例如2个顶点只需1条线，3个顶点只需2条线，因此得出n-1。 而作为有向完全图来说，两个顶点都有弧则需要两条边才行，例如2个顶点需要2条线，3个顶点需要6条线，就是在上面的基准下再加多一条线，因此得出n(n - 1)。 无向完全图：任何两个顶点之间都有边的无向图。 一个具有n个顶点的无向完全图的边的数量为：$\\frac{n(n-1)}{2}$。 怎么得出来的公式？根据定义得知，无向图顶点之间的边是同一条边，即2个顶点只需要1条线，因此拿有向完全图的公式除2就能够得出无向完全图的边的数目了。 顶点的度：与该顶点相关联的边共有多少，记为D(v)。 D全称：degree。 v表示顶点。 顶点度 = 入度 + 出度之和，即D(v) = ID(v) + OD(v)。 以图2a)，v2为例： ID(v2) = 1。 OD(v2) = 2。 D(v2) = 3。 以图2b)为例： D(v1) = 2。 D(v2) = 3。 入度：仅有向图，以顶点为终点的弧共有多少，记为ID。 I全称：input。 出度：仅有向图，以顶点为始点的弧共有多少，记为OD。 O全称：output。 子图：$G=(V, E)$是一个图，若E'是E的子集，V'是V的子集，并且E'中的边仅与V'中的顶点相关联，则图$G\u0026rsquo;=(V\u0026rsquo;, E\u0026rsquo;)$称为图G的子图。 路径：从一个顶点x到另一个顶点y之间的路线，这个路径也称为顶点的序列。 例图2b)，无向图的顶点v0到v3的路径共有2条： 顶点序列v0，v1，v2，v3，路径长度为3。 顶点序列v0，v2，v3，路径长度为2。 路径长度：路径上边/弧的数目。 简单路径：序列中顶点不重复出现的路径。 例图2b)，顶点序列v0，v1，v2，v3就是一条简单路径。 回路：第一个顶点和最后一个顶点相同的路径，也称为环。 例图2b)，以下路径都是回路： v0→v1→v2→v0→v2→v0 v0→v1→v2→v0 简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。 例图2b)，以下是简单回路： v0→v1→v2→v0 连通：顶点x到顶点y有路径，则称顶点x和顶点y是连通的。 连通图：图中任意两个顶点都是连通的。 例图2b)是一个连通图。 v0和v3没有直接的边但也能通过v0-\u0026gt;v2-\u0026gt;v3进行连通，因此符合连通图的定义。 例图2f)是非连通图，因为存在多个不连通顶点，例如v0和v3是不连通的。 连通分量：无向图中的极大（最大）连通子图。 简单点说，以图2f)为例，把一个图中的所有顶点看成一个整体的图，而单独取v0、v1、v2三个顶点构成的子图来说，就像图2g)，它就是一个连通图，也是一个连通分量，它是一个整体图中的一个连通分量，包括v3和v4构成的子图也是一样是一个连通分量。 连通相关的术语是针对无向图的，而强连通相关术语就是用来描述有向图的。\n强连通：与连通的含义一样，区别是无向图的连通本身就是双向的，如果是有向图，则要求顶点和顶点之间是双向相连才称为强连通。 强连通图：与连通的含义一样，任意两个顶点都是强连通的。 强连通分量：与连通分量的含义一样，不做赘述（估计是用来区分有向和无向的专业术语）。 如果极大（最大）连通子图是用来讨论分量的，那么极小（最小）连通子图就是用来讨论生成树的。\n生成树：一个连通图例图2b)，含有全部顶点的一个极小连通子图就是生成树，就像例图2g)所示。 观察规律得知： 如果连通图G的顶点数量为n，G的生成树的边数则为n-1。 如果G的一个子图G\u0026rsquo;的边数大于n-1，则G\u0026rsquo;子图中一定有环。 相反，如果边数小于n-1，则G\u0026rsquo;一定不连通。 特征 在图Graph结构中，任意两个结点之间都可能有关系，结点之间的邻接关系可以是任意的，即多对多的关系。\n存储结构 图的存储结构有很多种：\n邻接矩阵。 邻接表。 十字链表。 邻接多重表。 等等等等\u0026hellip;。 文中主要介绍邻接矩阵和邻接表。\n邻接矩阵 使用二维数组很容易就能够实现。\n以\u0026lt;vi, vj\u0026gt;或者(vi, vj)为例，定义如下：\n用0表示vi和vj之间，即偶对并没有关联。 用1表示vi和vj之间，即偶对存在关联。 以图2为例，有向图G1和无向图G2的邻接矩阵，M1和M2分别如下：\n无向图的邻接矩阵是一个对称矩阵，有向图的邻接矩阵是一个稀疏矩阵。\n配图5，p134，待补充\u0026hellip; $$图5$$ 如图5，反映出了顶点之间的邻接关系，即逻辑关系，其中：\n矩阵M1的有向图为例： \u0026lt;v0, v1\u0026gt;第0行第1列为1，表示顶点v0和v1之间存在关联。 顶点的集合是：V = {v0, v1, v2, v3}，即顶点共有4个。 弧的集合是：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v0\u0026gt;, \u0026lt;v1, v2\u0026gt;, \u0026lt;v2, v0\u0026gt;, \u0026lt;v2, v3\u0026gt;}，弧共有5条。 矩阵M2的无向图为例： \u0026lt;v0, v1\u0026gt;第0行第1列和\u0026lt;v1, v0\u0026gt;第1例第0行都是1，表示顶点v0和v1之间存在关联，注意是双向的。 这两个偶对实际上是指同一条边，要和有向图区分开来。 顶点的集合是：V = {v0, v1, v2, v3}，即顶点共有4个。 边的集合是：E = {\u0026lt;v0, v1\u0026gt;, \u0026lt;v1, v2\u0026gt;, \u0026lt;v0, v2\u0026gt;, \u0026lt;v2, v3\u0026gt;}，边共有4条。 仅邻接关系还不够，用C语言完整的表示是：\n1 2 3 4 5 6 7 8 9 10 11 const int num = 20; // 一般为x*y数量的积 typedef struct vertexType { char val; } typedef struct graph { vertexType vexs[num]; // 顶点信息 int matrix[num][num]; // 邻接矩阵 int vertexNum, sideNum; // 顶点数，边数 } graph; 若是带权的邻接矩阵，则是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const int num = 20; // 用于标识矩阵下没有数值的情况，值的大小按实际情况定义，只要能与权值区分开即可 const int maxNum = 32767; typedef struct vertexType { char val; } typedef struct weightType { int weight; } weightType; typedef struct graph { vertexType vertexs[num]; weightType matrix[num][num]; int vertexNum, sideNum; } graph; 邻接表 邻接表是顺序存储与链式存储相结合的存储方法。\n图的应用 最小生成树 Prim 遍历 图的遍历是指从图中的某个顶点出发，系统地访问图中的每个顶点，每个顶点仅访问一次。\n图的遍历操作类似于树的遍历操作，遍历的方式有两种，且都适用于有向图和无向图：\n深度优先搜索遍历，类似于树的先序遍历。 广度优先搜索遍历，类似于树的层次遍历。 由于图的顶点可能会与多个顶点相关联，在遍历过程中可能会多次访问到某个顶点，为了避免重复访问的问题，要记下每个已访问的顶点。可以用到数组，当顶点被访问后，对应下标的位置标记成1。\n参考 【精选】【数据结构】连通图、连通分量与强连通图、强连通分量—区别在于强，强强在哪里？ ","date":"2023-10-16T10:31:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter5/","title":"第五章 图 - 《数据结构导论》笔记"},{"content":"前言 比如现在来看一组幂运算（也叫求幂）：\n22，2的2次方，也就是2×2，结果是4。 23，就是2×2×2，结果是8，其中2是底数，3是指数。 那假如只给出结果16，底数是2，2x = 16，求x也就是指数是多少？要怎么做？\n猜得没错，这里就需要用到对数去解决。\n概念 对数是求幂的逆运算，正如除法是乘法的逆运算，定义为$N = a^x (a \u0026gt; 0, a \\neq 1)$，即a的x次方等于N。\n记作 $x = log_aN$ ，也就是 $a^x = N$ 等同于$x = log_aN$\n其中：\na叫做底数。 N叫做真数。 x叫做以a为底N的对数。 以上面的例子为例，用对数的表示就是：$x = log_216$\n当底数a=10的时候，叫做常用对数，可以缩写为：$lgN$ 当底数a=无理数e的时候，叫做自然对数，缩写为：$lnN$ 性质 零和负数无对数。 1的对数为0，$0 = log_a1$，也就是$a^0 = 1$ 底数和真数相同时，对数是1，$1 = log_aa$，也就是$a^1 = a$ 练习 1、将下面指数式写成对数式：\n$5^4=625$ 答：$4 = log_5625$ $2^{-6} = \\frac{1}{64}$ 答：$-6 = log2\\frac{1}{64}$ 2、将下面对数式写成指数式：\n$log_\\frac{1}{2}16 = -4$ 答：$\\frac{1}{2}^{-4} = 16$ $log_2128 = 7$ 答：$2^7 = 128$ 运算 $$a^x = M, \\quad a^y = N$$ $$a^x \\times a^y = a^{x+y}$$ $$M \\times N = a^{x+y}$$ $$log_a(M \\times N) = x + y$$\n运算法则 以下将介绍求出对数的方法都有哪些。\n1、$log_aN = \\frac{log_mN}{log_ma}$（a＞0，且a≠1，m＞0，且m≠1，N＞0）\n又称换底公式，用m替换a，m可以是任意一个数。\n以 $log_216$ 为例，将2替换成10，就是 $\\frac{log_{10}16}{log_{10}2}$ ，用计算器算一算：\n$log_{10}16$的精确结果是：1.204119982655948。 $log_{10}2$的精确结果是：0.3010299956639812。 相除以后的精确结果是：4.000000000000077，计算器取了近似值，所以答案是4，先取近似值再相除或者用精确结果相除再取近似值都可以，取决于计算时的选择。 2、$log_a(MN) = log_aM + log_aN$（a＞0，且a≠1，M、N＞0）\n对数的乘法法则。\n3、$log_a\\frac{M}{N} = log_aM - log_aN$（a＞0，且a≠1，M、N＞0）\n对数的除法法则。\n4、$a^{log_aM} = M$（a＞0，且a≠1，M＞0）\n5、$log_{a^{m}}b^{n} = \\frac{n}{m}log_ab$（a、b＞0，且a、b≠1）\n疑问 1、为什么定义中$a \u0026gt; 0, a\\neq1$？ 因为这些取值都是没有意义的，所以要限制，比如：\n当a=0时，无论指数是多少，最终结果都是0。 当a=1时，无论指数是多少，最终结果都是1。 当a＜0时，即负数时，求幂的结果可能会有两种情况，要么是正数要么是负数，带来的多义性无法保证对数运算结果的唯一性，比如： 指数为奇数时，求幂的结果是负数。 指数为偶数时，求幂的结果是正数。 应用 1、一棵完全二叉树中有65个结点，请算出完全二叉树的深度。\n根据二叉树的性质4我们知道计算深度对应的公式是：$⌊log_2n⌋+1$。\n将数据代入公式可以得到$⌊log_265⌋+1$，使用换底公式，把底数2换成10，就是$\\frac{log_{10}65}{log_{10}2}$。\n我们用计算器算一下，精确结果是：6.022367813028454，向下取整就是6，代入公式。\n最终答案是：$⌊log_{2}65⌋+1=6+1=7$。\n如果在不能使用计算器的情况下，当然还有一种笨方法，把$log_{2}65$写成指数式，即$2^x=65$。\n把不同的数字代入x，用穷举法来找一找哪个数字最接近65：\n来大一点的数字，直接上5，即$2^5$，答案是32，还差的远，继续往上递增。 上6，即$2^6$，答案是64，非常接近了。 再往上递增看看，$2^7$，结果是128，超过65了。 那么估算答案可能是6和7之间的小数：6.xxx，因为有向下取整函数，无论有多少个小数，最终答案都是6。\n所以实际上我们并不需要精确的结果，同样也能够解决问题。\n参考 对数_百度百科 03.什么是对数__哔哩哔哩_bilibili 指数函数、对数函数、幂函数 -快速入门到完美精通_哔哩哔哩_bilibili （高一）对数（一）（对数的基本性质和性质）_哔哩哔哩_bilibili ","date":"2023-09-28T14:47:45+08:00","permalink":"https://ghbjayce.github.io/p/subject/math/sequence/logarithm/","title":"什么是对数？"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 涉及知识点 数学知识 对数 概要 树 概念 结构 森林 相关术语和计算 基本运算的功能描述 二叉树 概念 左、右子树 基本运算 性质特征 满二叉树 完全二叉树 存储结构 顺序存储 链式存储 用C语言描述 遍历算法 递归实现 先序遍历 中序遍历 后序遍历 层次遍历 非递归实现 树和森林 树的存储结构 孩子链表表示法 孩子兄弟链表表示法 双亲表示法 树、森林和二叉树的关系与转换 树转二叉树 森林转二叉树 二叉树转森林 遍历 判定树和哈夫曼树 概念 判定树 哈夫曼树 哈夫曼编码 分类和判定树的关系 哈夫曼树构造过程 哈夫曼算法 树 概念 树Tree是一种树形结构，它是由n(n≥0)个结点组成的有限集合。\n特征：树形结构结点之间具有一对多的关系，一个结点可以有一个或多个直接后继。\n双亲：指父结点，parent node翻译过来的意思。 例，如图a)： A没有双亲。 B、C、D的双亲是A。 E、F的双亲是B。 直接孩子：指结点的孩子，孩子的孩子不算，只是为了方便区分，一般简称孩子。 例，如图a)： A的孩子有B、C、D。 B的孩子有E、F。 祖先：沿着某个结点向上追溯，直到根结点结束，路径上的所有结点都是祖先。 例，如图a)： A没有祖先。 B的祖先是A。 H的祖先分别是G、D、A。 子孙：除了根结点以外的其他结点。 例，如图a)： B的子孙分别是E、F。 D的子孙分别是G、H、I、J。 兄弟结点：某个结点的直接孩子们，它们之间是兄弟关系，拥有同一个父结点。 例，如图a)： B、C、D它们之间是兄弟。 E、F是兄弟。 叶子：没有孩子的结点，也称叶子结点、终端结点。 例，如图a)：E、F、C、H、I、J都是叶子。 子树：某个结点的所有子孙（后代结点）所构成的树结构。 例，如图a)： D、G、H、I、J所构成的树结构是根结点A的子树。 C不算子树，因为它没有子孙。 B、E、F这棵树是根结点A的子树。 结点的度：某一个结点有多少个直接孩子。 例，如图a)： A结点的度为3。 B结点的度为2。 D结点的度为1。 树的度：结点的度的最大值，也就是所有结点里直接孩子最多的那个。 例，如图a)：树的度为3。 结点的层次：把一棵树比作一个层级金字塔，从根结点为1，每下一层+1，数到结点所在的层级。 例，如图a)： B的层次是2。 E的层次是3。 H的层次是4。 树的高度/深度：结点的层次的最大值，也就是树一共有多少层。 例，如图a)：树高为4。 有序树：结点的孩子之间的按照一定的顺序排序，典型的例子是二叉树。 无序树：结点的孩子之间的顺序可以任意排列，典型的例子是普通树，也称自由树。 一棵树需要满足的条件：\n当n=0时，称为空树。 当n\u0026gt;0时： 仅有一个称为根的结点，简称根结点。 根结点有它的直接孩子，构成父子关系，直接孩子也有自己的孩子，构成根结点的子树。 孩子之间没有关联，互不相交，把孩子作为一个单独的根结点时，以上条件同样适用。 上图b)、c)不是一棵树，存在两个根节点，d)也都不是一棵树，因为孩子之间相交了。\n以上第2个条件是我个人方便理解的总结，贴上书上原话：有且仅有一个称为根的结点，除根节点外，其余结点分为m(m≥0)个互不相交的非空集合T1，T2，\u0026hellip;，Tm，这些集合中的每一个都是一棵树，称为根的子树。\n森林Forest是m(m≥0)棵互不相交的树的集合，简单点说就是有多棵树，且它们之间互不相交，例如图b)、c)。\n基本运算的功能描述 求根Root(T)：求树T的根节点。 求双亲Parent(T, X)：求结点X在树T上的双亲节点，若X是根结点或不在T上，则返回特殊标志。 求孩子Child(T, X, i)：求结点X的第i个孩子结点，若X不在T上或X上没有i孩子，则返回特殊标志。 建树Create(X, T1, \u0026hellip;, Tk)，k\u0026gt;1：建立一棵以X为根，以T1，\u0026hellip;，Tk为第1，\u0026hellip;，k棵子树的树。 剪枝Delete(T, X, i)：删除树T上结点X的第i棵子树，若T无第i棵子树，则为空操作。 遍历TraverseTree(T)：遍历树，即访问树中每个结点，且每个结点仅被访问一次。 二叉树 概念 二叉树Binary Tree是n(n≥0)个元素的有限集合，即在树的基础上，一棵二叉树需要满足其中一个条件：\n空树，什么结点都没有。 只有一个根结点，即左右子树均为空。 右子树为空。 左子树为空。 由一个根结点和两棵互不相交的左子树和右子树组成，子树之间是有次序关系的，且均是一棵二叉树。 $$图4.2$$\n性质特征 二叉树的5个性质特征：\n性质1：二叉树第i（i≥1）层上至多有2i-1个结点，也就是： 第一层最多有1个结点。 第二层最多有2个结点。 第三层最多有4个结点。 第四层最多有8个结点，以此类推。 性质2：深度为k（k≥1）的二叉树至多有2k-1个结点，也就是例如二叉树高为3，那么最多有4个结点。 符合该性质的称为满二叉树。 性质3：对任何一棵二叉树，若度数为0的结点个数为$n_0$，度数为2的结点个数为$n_2$，则 $n_0=n_2+1$。 例如上图c)，度数为0的结点个数是3（D、G、F），度数为2的结点个数是2（A、B）。 完全二叉树：如果对满二叉树按从上到下，从左到右的顺序编号，并在树的最后一层删去部分结点（最后一层至少还剩一个结点），删完以后整棵树的结点还是顺序的排列，这就是棵完全二叉树，其性质有：\n性质4：含有n个结点的完全二叉树的深度为$⌊log_2n⌋+1$。 其中⌊x⌋表示不大于x的最大整数，即向下取整函数，指⌊$log_2n$⌋，$log_2n$是对数，什么是对数？ 例如上图b)，共有10个结点，即⌊log210⌋+1，对数结果是3.32..向下取整后是3，最终深度是4。 性质5：按上面完全二叉树的定义对结点进行顺序编号，对任意一编号为i(1 ≤ i ≤ n)的结点x，性质有： 若i = 1，结点x是根。 若i \u0026gt; 1，结点x的双亲的编号为：⌊i / 2⌋。 若2 * i ＞ n，结点x无左和右孩子；若有左孩子，其编号为2 * i。 若2 * i + 1 ＞ n，结点x无右孩子，若有右孩子，其编号为2 * i + 1。 书上原话：二叉树不是完全二叉树，满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。\n基本运算的功能描述 初始化Initiate(BT)：建立一棵空二叉树，BT=∅。 求双亲Parent(BT, X)：找出结点X的双亲结点，若X是根结点或X不在BT上，返回NULL。 求左孩子Lchild(BT, X)：求X结点的左孩子，若X是叶子结点或X不在BT上，返回NULL。 求右孩子Rchild(BT, X)：与求左孩子逻辑一样，区别是求X结点的右孩子。 建二叉树Create(BT)：建立一棵二叉树BT。 先序遍历PreOrder(BT)：按先序对二叉树BT进行遍历，每个结点仅被访问一次。BT为空不操作。 中序遍历InOrder(BT)：与先序遍历逻辑一样，区别是以中序进行。 后序遍历PostOrder(BT)：与先序遍历逻辑一样，区别是以后序进行。 层次遍历LevelOrder(BT)：按层从上往下，每层从左往右对二叉树进行遍历，每个结点仅被访问一次。BT为空不操作。 存储结构 二叉树通常有两种存储结构：顺序存储和链式存储结构。\n顺序存储 二叉树的顺序存储可以用一维数组来实现，按照性质5的特性，对结点进行从上到下从左到右的顺序进行编号，从根结点1开始，将结点顺序地存进数组的对应下标位置，下标0不使用。\n顺序存储分为两种情况：\n如果二叉树是完全二叉树，如下图a)、b)的方式进行存储。 如果二叉树非完全二叉树： 首先必须用某种方法将其转换成完全二叉树。 对不存在的结点的位置可增设虚拟结点（阴影表示）的方式，如下图e)。 对应虚拟结点下标的位置使用特殊记号∧表示。 非完全二叉树的顺序存储虽然可以用转换完全二叉树，以完全二叉树的顺序存储进行处理，这样只要是一棵二叉树（不管是哪种类型）都能够用同一种运算方式进行处理，但这种方法最大的缺点是造成了空间的浪费。\n链式存储 二叉树最常用的是链式存储结构，其中又分为二叉链表和三叉链表。\n其中：\nlchild表示指向左孩子的指针，即左指针。 没有左孩子时左指针域的值为NULL。 rchild表示指向右孩子的指针，即右指针。 没有右孩子时右指针域的值为NULL。 每个二叉链表必须有一个指向根结点的指针，即根指针，例如上图 c) 中的root，与链表头指针类似。 访问二叉链表只能从根指针开始。 若二叉树为空，则root = NULL。 三叉链表在每个结点增加了一个指针域parent，用于指向该结点的双亲。 因此总结出规律，在具有 n 个结点的二叉树中，有2n个指针域： 其中只有n - 1个用来指向结点的左、右孩子。 其余的n + 1个指针域为NULL。 用C语言描述 二叉树 1 2 3 4 5 typedef struct binaryTreeNode { dataType data; struct binaryTreeNode *lchild, *rchild; } *binaryTree; 三叉树 1 2 3 4 5 6 typedef struct TBNode { dataType data; struct TBNode *lchild, *parent, *rchild; } *ThreeBinaryTree; ThreeBinaryTree root; 遍历 二叉树的遍历是指按某种次序访问二叉树上的所有结点，且每个结点仅访问一次。\n一棵二叉树由三部分组成：根、根的左子树、根的右子树。\n因此遍历二叉树总共有三个步骤：\n访问根结点。 遍历根的左子树。 遍历根的右子树。 遍历共有三种次序，不同的次序只是三个步骤的顺序不同：\n下面会以图4.2中的c)二叉树为例，分别说明对应次序的序列。\n先序遍历。 步骤顺序，简记为：根左右。 访问根结点。 先序遍历根的左子树。 先序遍历根的右子树。 先序遍历结点的序列为：ABDEGCF，以下是遍历过程： 访问A。 先序遍历A的左子树（BDEG）。 访问B。 先序遍历B的左子树（D）。 访问D。 先序遍历D的左子树（空）。 先序遍历D的右子树（空）。 先序遍历B的右子树（EG）。 访问E。 先序遍历E的左子树（G）。 访问G。 先序遍历G的左子树（空）。 先序遍历G的右子树（空）。 先序遍历E的右子树（空）。 先序遍历A的右子树（CF）。 访问C。 先序遍历C的左子树（空）。 先序遍历C的右子树（F）。 访问F。 先序遍历F的左子树（空）。 先序遍历F的右子树（空）。 中序遍历。 步骤顺序，简记为：左根右。 中序遍历根的左子树。 访问根结点。 中序遍历根的右子树。 结点的序列为：DBGEACF。 后序遍历。 步骤顺序，简记为：左右根。 后序遍历根的左子树。 后序遍历根的右子树。 访问根结点。 结点的序列为：DGEBFCA。 递归实现 先序、中序和后序都是基于递归的实现，下面给出各次序具体的算法。\n假设visit(bt)函数是访问指针bt所指结点。\n先序遍历 1 2 3 4 5 6 7 8 void preorder(binaryTree bt) { if (bt != NULL) { visit(bt); preorder(bt-\u0026gt;lchild); preorder(bt-\u0026gt;rchild); } } 中序遍历 1 2 3 4 5 6 7 8 void inorder(binaryTree bt) { if (bt != NULL) { inorder(bt-\u0026gt;lchild); visit(bt); inorder(bt-\u0026gt;rchild); } } 后序遍历 1 2 3 4 5 6 7 8 void postorder(binaryTree bt) { if (bt != NULL) { postorder(bt); postorder(bt); visit(bt); } } 层次遍历 不是重点，待补充\u0026hellip;\n非递归实现 不是重点，待补充\u0026hellip;\n应用 1、根据先序遍历和中序遍历次序创建一棵二叉树。\n先序遍历次序：ABDEGCF。 中序遍历次序：DBGEACF。 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 binaryTree createByPreInOrder(char preArr[], char inArr[], int preArrMinIndex, int preArrMaxIndex, int inArrMinIndex, int inArrMaxIndex) { if (inArrMaxIndex \u0026lt; 0) { return NULL; } int k; // 如下申请内存的方式出自书上，是高度概括的，会存在内存越界导致结果出现一些不可预料的问题。 // binaryTree bt = malloc(sizeof(binaryTree)); // 以下是正确的申请方式，两者之间在64位机器上相差16字节，前者8字节，后者24字节 binaryTree bt = malloc(sizeof(struct binaryTreeNode)); bt-\u0026gt;data.val = preArr[preArrMinIndex]; k = inArrMinIndex; while ((k \u0026lt;= inArrMaxIndex) \u0026amp;\u0026amp; (inArr[k] != preArr[preArrMinIndex])) { k++; } if (k \u0026gt; inArrMaxIndex) { return NULL; } bt-\u0026gt;lchild = createByPreInOrder(preArr, inArr, preArrMinIndex + 1, preArrMinIndex + k - inArrMinIndex, inArrMinIndex, k - 1); bt-\u0026gt;rchild = createByPreInOrder(preArr, inArr, preArrMinIndex + k - inArrMinIndex + 1, preArrMaxIndex, k + 1, inArrMaxIndex); return bt; } 实现思路：\n以递归的方式，逐个将先序遍历次序的结点在中序遍历次序范围中查找，简称在中序遍历中找根结点。 找到根节点以后，在中序遍历次序中分出该根节点的左子树（根结点的左边）和右子树（根结点的右边）的范围。 以A根结点为例，在中序遍历次序中： A的左子树即DBGE。 A的右子树即CF。 在左子树和右子树的范围中，再重复步骤1，在范围中寻找先序遍历次序的下一个结点，从而得到完整的左右子树。 2、根据中序遍历和后序遍历次序创建一棵二叉树。\n中序遍历次序：BACDEFGH。 后序遍历次序：BCAEDGHF。 思路：与先序遍历和中序遍历一样，都是从中序遍历中找到左右子树。\n步骤：\n由后序遍历次序确定F是根结点，那么在中序遍历次序中，F的左子树是BACDE，右子树是GH。 即得出后序遍历次序中，BCAED是F的左子树，GH是F的右子树。 那么从后序遍历次序的左子树范围中确定左子树的根结点是D，重复步骤1。 在中序遍历次序中： D的左子树是：BAC。 D的右子树是：E。 在后序遍历次序中即： D的左子树是：BCA。 D的右子树是：E。 继续下一个根节点A，A的左孩子是B，右孩子树C。 回到F的右子树：GH，H是根结点，H的左孩子是G。 算法：\n待补充\u0026hellip;\n树和森林 树的存储结构 $$图4.5$$\n孩子链表表示法 用C语言表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const int MAX_NODE_NUM = 20; typedef struct dataType { char val; } dataType; typedef struct node { int index; struct node *next; } *childLink; typedef struct childLinkArr { dataType data; childLink firstChild; } childLinkArr; int main() { childLinkArr link[MAX_NODE_NUM]; return 0; } 结合C语言定义和上图b)所示，其中：\nchildLinkArr是一个数组，数组元素个数与上图a)树T的结点的数量相同，结点存放的顺序按树T从上到下从左到右依次排列。 数组元素由数据域 + 首个孩子指针域组成。 数据域：用于存放结点值。 首个孩子指针域：指向从左到右的第一个孩子。 首个孩子指针域可以看作是头结点，其所指向的孩子链表（childLink）是一个单链表，分别是结点的第一个孩子、第二个孩子、第三个孩子以此类推。 孩子链表也由数据域 + 指针域组成。 数据域：存放孩子在数组childLinkArr中的下标位置。 指针域：指向下一个孩子，也是当前孩子的兄弟结点。 为了便于找到双亲，对childLinkArr结构体改进一下：\n增加一个双亲域parentIndex，存储结点双亲在数组childLinkArr中的下标位置，如上图c)。\n用C语言表示：\n1 2 3 4 5 6 typedef struct childLinkArr { dataType data; childLink firstChild; int parentIndex; } childLinkArr; 孩子兄弟链表表示法 如上图d)、e)所示，孩子兄弟链表的结构表示形式和二叉链表完全相同，只是结点含义不同：\n二叉链表，当前结点分为左孩子指针和右孩子指针。 孩子兄弟链表，当前结点分为首个左孩子指针（简称孩子指针）和兄弟结点指针，剩下的孩子通过遍历孩子指针的兄弟结点指针找到。 用C语言表示：\n1 2 3 4 5 typedef struct brotherNode { dataType data; struct brotherNode *son, *brother; } *treeLink; 双亲表示法 如上图f)所示，是当中存储结构最简单的一种，同样也是采取数组的方式，由数据域+双亲域组成：\n数据域：将树T所有的结点按从上到下从左到右的顺序，结点从下标0开始，一一存进数组。 双亲域：存储双亲结点在数组中的下标位置，没有双亲存储-1。 用C语言表示：\n1 2 3 4 5 6 7 const int size = 10; typedef struct { dataType data; int parentIndex; } Node; Node treeParentArr[size]; 疑问：\n只靠双亲怎么知道有哪些孩子？以及孩子的顺序？ 答： 双亲parentIndex是同一个值的，就表示这些都是孩子。 因为存储已经按从左到右顺序存储，把同一个双亲的所有结点找出来，数组下标的顺序就是孩子直接的顺序，即保证了孩子之间的逻辑结构。 树、森林和二叉树之间的转换 树转换成二叉树 转换方法：\n加线，所有兄弟结点之间加一条线，彼此连接起来。 抹线，除了结点的第一个左孩子，其他孩子与结点的连线全部抹掉。 旋转，以根节点为轴心，对树进行顺时针的适当旋转。 森林转换成二叉树 转换方法：\n将森林中的每棵树转换成二叉树。 加线，转换以后的二叉树，从第二棵二叉树开始，将其根节点作为前一棵二叉树根结点的右子树，以此类推。 二叉树转换成森林 转换方法：\n抹线，断开根结点与右孩子的连线，此时得到两棵二叉树。 抹线再加线，二叉树根节点的左子树的右子树们均断开连接，改成均与根节点之间连接，如果根节点有右子树，重复步骤1的操作。 剩下的二叉树重复按以上步骤进行处理。 树和森林的遍历 树 以图4.5的a)树为例。\n先序遍历 访问根结点 从左往右依次遍历孩子，以孩子为根节点，重复步骤1和步骤2。 先序遍历次序为：HABEGFDC。\n后序遍历 后序遍历根的孩子子树。 访问根结点。 后序遍历次序：BGFDEACH。\n层次遍历 访问根结点。 逐层往下遍历，每层从左到右依次访问结点。 层次遍历次序：HACBEGFD。\n森林 森林有两种遍历方法：\n先序遍历 从左到右访问第一棵树的根结点。 先序遍历根结点的子树。 先序遍历森林中的其他树，重复以上步骤。 中序遍历 从左到右中序遍历第一棵树根结点的第一个孩子的子树。 访问第一棵树的根节点。 中序遍历剩下的孩子的子树。 中序遍历森林中的其他树，重复以上步骤。 判定树和哈夫曼树 分类和判定树 树有广泛的应用，其中一种重要的应用是描述分类的过程。\n分类是一种常用的运算，将输入数据按照标准划分成不同的种类，例如：\n类别 A B C D 年龄值 age age \u0026lt; 18 18 ≤ age ＜ 45 45 ≤ age ＜ 60 age ≥ 60 百分比 0.2 0.3 0.25 0.25 插图..\n用于描述分类过程的二叉树称为判定树，其中上图a)的分类算法为：\n1 2 3 4 5 6 7 8 9 10 11 12 char classify(int age) { if (age \u0026lt; 18) { return \u0026#39;A\u0026#39;; } else if (age \u0026lt; 45) { return \u0026#39;B\u0026#39;; } else if (age \u0026lt; 60) { return \u0026#39;C\u0026#39;; } else { return \u0026#39;D\u0026#39;; } } 假设人口有N=10000人，C类别人口占25%，根据a)的判断树，区分1个人是否属于C类别需要进行3次比较，那么10000个人就需要$10000 \\times 0.25 \\times 3$，即7500次。\n所有类别总共需要的比较次数就是：23000次。\n1 2 3 4 SUM = (N × 0.2 × 1) + (N × 0.3 × 2) + (N × 0.25 × 3) + (N × 0.25 × 3) = N × (0.2 + 0.6 + 0.75 + 0.75) = 10000 × 2.3 = 23000 平均比较次数是：$SUM \\div N$ 即$23000 \\div 10000 = 2.3$次。\n而如果是b)的判断树，区分1人属于C类别则只需要2次比较，10000个人则需要5000次。\n所有类别总共需要比较20000次。\n1 2 3 4 SUM = (N × 0.2 × 2) + (N × 0.3 × 2) + (N × 0.25 × 2) + (N × 0.25 × 2) = N × (0.4 + 0.6 + 0.5 + 0.5) = 10000 × 2 = 20000 平均比较次数是2次，相较a)，总共减少了3000次比较，平均比较次数减少了0.3次。\n这说明，按不同判定树进行分类的计算量是不同的，有时可以相差很大，怎样才能构造出像b)一样，平均比较次数最少的判定树呢？\n没错，可以用到哈夫曼树和哈夫曼算法。\n哈夫曼树和哈夫曼算法 以上面的例子为例，给定一组权值为{p1, \u0026hellip;, pk}的序列，如何构造出一棵有k个叶子结点分别以权为值的判定树，并且平均比较次数是最小的？\n步骤如下：\n根据一组权值为{p1, \u0026hellip;, pk}的序列，构造森林F={T1, \u0026hellip;, Tk}，其中Ti是一棵只有根结点，权为pi的二叉树。 如图a)。 从F中选取两个权最小的两棵二叉树，组成一棵新的二叉树，左右孩子分别是两个权最小的二叉树 如图b)。 从F中删掉步骤2已经合并的两棵二叉树，并将新的二叉树加入F，如图c)。 此时再看是否还有多个二叉树。 如果是，继续重复步骤2。 直到只剩下一棵二叉树，这棵二叉树就是哈夫曼树，如图d)。 从中得出规律：\n需要经过$n-1$次合并，最终得出一棵哈夫曼树，其中n是指权值的数目，以上面的例子，权值数目为4。 最终得到的哈夫曼树共有$2n-1$个结点，其中： 哈夫曼树没有度数为 1 的分支结点。 用C语言实现，即哈夫曼算法，采用顺序存储，大小是2n-1的数组，数组中的元素有四个域，分别是：\n权值。 双亲下标值。 左孩下标值。 右孩下标值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;float.h\u0026gt; const int n = 10; typedef struct { float weigh; int parent, lchild, rchild; } node; typedef node huffmanTree[2*n-1]; void huffman(int size, float weigh[], huffmanTree tree) { int index, j, x, y; float m, n; // 初始化 for (index = 0; index \u0026lt; 2 * k - 1; index++) { tree[index].parent = -1; tree[index].lchild = -1; tree[index].rchild = -1; if (index \u0026lt; size) { tree[index].weigh = weigh[index]; } else { tree[index].weigh = 0; } } for (index = 0; index \u0026lt; size - 1; index++) { x = 0; y = 0; m = FLT_MAX; n = FLT_MAX; for (j = 0; j \u0026lt; size + index; j++) { if ((tree[j].weigh \u0026lt; m) \u0026amp;\u0026amp; (tree[j].parent == -1)) { n = m; y = x; m = tree[j].weigh; x = j; } else if ((tree[j].weigh \u0026lt; n) \u0026amp;\u0026amp; (tree[j].parent == -1)) { n = tree[j].weigh; y = j; } } tree[x].parent = size + index; tree[y].parent = size + index; tree[size + index].weigh = m + n; tree[size + index].lchild = x; tree[size + index].rchild = y; } } 哈夫曼编码 在通信领域中，通常希望字符在传输过程中总的编码长度越短越好，即对字符的存储进行压缩，能否找到最短的编码方案呢？\n没错，还是哈夫曼树，不过要加点编码。\n思路：\n通过对字符出现次数进行统计，字符是值，权是出现次数或者叫出现频率。 让出现频率较多的字符采用较短的编码。 出现频率较少的字符采用较长的编码。 哈夫曼二叉树的每个结点的左分支标记为0，右分支为1（如下图f)），这样，从根结点到每个叶子结点的路径，把路径所在的分支标记全部加起来就是对应字符的编码，这些编码就称为哈夫曼编码。\n例如：某个通信系统需要传输一个字符串”aaa bb cccc dd e“，它们出现的频率分别是：\n字符 a \u0026rsquo;\u0026rsquo; (空) b c d e 频率 3 4 2 4 2 1 频率序列从小到大排列后是：\n字符 e b d a \u0026rsquo;\u0026rsquo; (空) c 频率 1 2 2 3 4 4 经过哈夫曼树编码后，如上图f)，字符对应的编码分别是：\n字符 a \u0026rsquo;\u0026rsquo; (空) b c d e 编码 00 01 110 10 1111 1110 即字符串”aaa bb cccc dd e“对应的编码序列为”0000000111011001101010100111111111011110“。\n为了方便大家查看比对，用|对每个字符编码进行分开：\n1 00|00|00|01|110|110|01|10|10|10|10|01|1111|1111|01|1110 哈夫曼编码序列在还原成字符串的过程是，以上面的序列为例：\n拿接下来的第一个编码，即0，在哈夫曼树中寻找。 未找到，则把第一个编码和下一个编码加在一起，即00（a），继续在哈夫曼树中寻找。 没找到则一直重复步骤2。 找到了，即拿到了编码对应的字符串。 重置这个过程，继续走步骤1，直至结束。 参考 4.树与二叉树的转换 树与二叉树的转换 数据结构——哈夫曼树（Huffman Tree） 详细图解哈夫曼Huffman编码树 ","date":"2023-09-26T09:47:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter4/","title":"第四章 树和二叉树 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 本文涉及到的代码描述均为C语言。 概要 栈 概念 特征 用C语言描述 顺序栈 链栈 基本运算 初始化 栈空 栈满 进栈 出栈 取栈顶元素 应用 解决简单问题 队列 概念 特征 用C语言描述 顺序队列 循环队列 基本运算 初始化 队列空 队列满 入队列 出队列 取队列首元素 应用 解决简单问题 数组 一维和二维数组 逻辑结构 存储结构 存储位置计算 矩阵的压缩存储 特殊矩阵 对称矩阵 三角矩阵 上三角矩阵 下三角矩阵 稀疏矩阵 三元组表示法 简单的综合运用 栈 概念 栈Stack可以看作是特殊的线性表，特殊性在于基本运算是线性表运算的子集，是一种运算受限的线性表。而受限是指插入和删除运算限定在表的某一端进行。\n进栈：指插入运算。 出栈：指删除运算。 栈顶：允许进栈和出栈的一端。 栈底：栈顶的另一端。 空栈：不含任何数据元素的栈。 栈顶元素：处于栈顶位置的数据元素。 上溢：栈的容量已经满了，此时再进行进栈就会发生上溢。 下溢：空栈做出栈就会产生下溢，因为栈中没有任何数据元素。 栈是计算机科学中广泛使用的数据结构之一，例如：函数的嵌套调用和程序递归的处理都是用栈来实现的。\n特征 栈的修改原则是后进先出（Last In First Out），好比桌面上叠放着待清洗的碗碟，收拾以后的碗碟被放在栈顶，而在栈顶的碗碟会优先得到清洗。因此又称为后进先出线性表，简称后进先出表。\n生活中的例子 具有栈特征的生活场景：\n购物篮：顾客往购物篮放商品会放在栈顶，结账时从栈顶取出商品。 购物推车：顾客的购物车在结账完以后会被回收，叠放在栈顶，下一个顾客需要时会从栈顶取出。 射击：先装的子弹最后才被打出来，特殊子弹夹除外，例如左轮。 添饭：新加的米饭放在栈顶，栈顶的米饭先吃。 水杯加水：这个例子可能不太严谨，因为水流动的特性也有可能喝到非栈顶的水。 实现 栈的实现有两种方式：\n顺序栈：用一组连续的存储单元存放数据元素，通常用一个一维数组和一个记录栈顶位置的变量来实现顺序存储。 链栈：用带头结点的单链表实现，命名LS（linkStack），LS指向头结点，LS-\u0026gt;next指向栈顶结点，也是首结点，尾结点是栈底结点，通过各结点的指针连接组成栈。 栈的基本运算的功能描述：\n初始化InitStack(S)：构造一个空栈S。 判断栈空EmptyStack(S)：若为空栈返回1，否则返回0。 进栈Push(S, x)：将元素x插入栈S中，x成为栈顶元素。 出栈Pop(S)：删除栈顶元素。 取栈顶GetTop(S)：返回栈顶元素。 顺序栈 定义 顺序栈相关代码放在了ghjayce/code-example - sequence stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 const int maxSize=10; // 顺序栈的容量 typedef struct sequenceStack { dataType data[maxSize]; // 存储栈中数据元素的数组 int top; // 指向栈顶位置 } seqStack; 初始化 1 2 3 4 5 6 seqStack init() { seqStack stack; stack.top = 0; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(seqStack *stack) { if (stack-\u0026gt;top == 0) { return 1; } return 0; } 栈满 1 2 3 4 5 6 7 int isFull(seqStack *stack) { if (stack-\u0026gt;top == maxSize-1) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 8 9 10 int push(seqStack *stack, dataType x) { if (isFull(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈已满\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top++; stack-\u0026gt;data[stack-\u0026gt;top] = x; return 1; } 出栈 1 2 3 4 5 6 7 8 9 int pop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top--; return 1; } 取栈顶元素 1 2 3 4 5 6 7 8 dataType getTop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } return stack-\u0026gt;data[stack-\u0026gt;top]; } 双栈 为了节省空间，可以让两个数据元素类型一致的栈共享同一个一维数组空间，这种做法使一维数组空间构成了双栈。\n两个栈的栈底分别设在数组的两端，栈顶分别用top1、top2表示，两个栈分别做进栈运算时，彼此会迎面增长，那么判断为上溢的条件为：$top+1=top2$。\n上溢条件为什么是top+1？\n假设数组长度为40，0-19是第一个栈的空间范围，20-39是第二个栈的空间范围，而19+1则会超出第一个栈的空间范围，出现上溢。\n双栈示意图，待补充..\n用C语言表示双栈的数据结构：\n1 2 3 4 5 6 const int maxSize = 40; typedef struct doubleStack { dataType data[maxSize]; int top1, top2; } doubleStack; 双栈运算，待补充..\n链栈 定义 链栈相关代码放在了ghjayce/code-example - link stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 typedef struct { int id; } dataType; typedef struct node { dataType data; struct node *next; } linkStack; 初始化 1 2 3 4 5 6 linkStack *init() { linkStack *stack = (linkStack *)malloc(sizeof(linkStack)); stack-\u0026gt;next = NULL; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(linkStack *stack) { if (stack-\u0026gt;next == NULL) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 void push(linkStack *stack, dataType x) { linkStack *newNode = (linkStack *)malloc(sizeof(linkStack)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = stack-\u0026gt;next; stack-\u0026gt;next = newNode; } 出栈 1 2 3 4 5 6 7 8 9 10 int pop(linkStack *stack) { if (!isEmpty(stack)) { linkStack *removeNode = stack-\u0026gt;next; stack-\u0026gt;next = removeNode-\u0026gt;next; free(removeNode); return 1; } return 0; } 取栈顶元素 1 2 3 4 5 6 7 dataType *getTop(linkStack *stack) { if (isEmpty(stack)) { return NULL; } return \u0026amp;(stack-\u0026gt;next-\u0026gt;data); } 应用 1、将链栈中的结点进行逆置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 linkStack *reverse(linkStack *stack) { linkStack *newStack = init(); linkStack *stackNode = stack-\u0026gt;next; while (stackNode != NULL) { push(newStack, stackNode-\u0026gt;data); stackNode = stackNode-\u0026gt;next; } stackNode = stack-\u0026gt;next; while (!isEmpty(newStack)) { dataType *data = getTop(newStack); if (data != NULL) { stackNode-\u0026gt;data = *data; pop(newStack); } stackNode = stackNode-\u0026gt;next; } return stack; } 思路：\n遍历（逐个访问链表元素）要逆置的链栈（称为A链栈）的结点，将结点通过进栈的方式放到新的链栈（称为B链栈）中，此时B链表中结点的顺序已经与A链栈相反。 对B链栈进行逐一出栈，将出栈的结点按A链表的顺序对结点进行覆盖，完成逆置。 2、递归和栈，用递归实现阶乘函数\n待补充\u0026hellip;\n练习 1、设栈S的初始状态为空，若元素a、b、c、d、e、f依次进栈，得到的出栈序列是b、d、c、f、e、a，则栈S的容量至少是多少？\n答：至少3。\na进，b进，容量2。 b出，容量1。 c进，d进，容量3。 d出，c出，容量1。 e进，f进，容量3。 f出，e出，a出，容量0。 2、设一个链栈的输入序列为A、B、C，试写出所得到的所有可能得输出序列。\n答：共有5种可能的输出序列。\n输出ABC，A进，A出，B进，B出，C进，C出。 输出ACB，A进，A出，B进，C进，C出，B出。 输出BAC，A进，B进，B出，A出，C进，C出。 输出BCA，A进，B进，B出，C进，C出，A出。 输出CBA，A进，B进，C进，C出，B出，A出。 3、有一个整数序列，其输入顺序为20，30，90，-10，45，78，试利用栈将其输出序列改变为30，-10，45，90，78，20，试给出该整数序列进栈和出栈的操作步骤，用push(x)表示x进栈，pop(x)表示x出栈。\n答：\npush(20)，20 push(30)，20、30 pop(30)，20 push(90)，20、90 push(-10)，20、90、-10 pop(-10)，20、90 push(45)，20、90、45 pop(45)，20、90 pop(90)，20 push(78)，20、78 pop(78)，20 pop(20) 队列 概念 队列Queue，和栈一样可以看作是特殊的运动受限的线性表，受限在于插入和删除分别在两端进行。\n入队列：在队列尾部进行插入运算。 出队列：在队列首部进行删除运算。 队列首元素：队列首部第一个数据元素。 队列尾元素：队列尾部最后一个数据元素。 队列也是计算机科学中广泛使用的数据结构之一，例如：操作系统中进程调度、网络管理中的打印服务等都是用队列来实现的。\n特征 队列的修改原则是先进先出（First In First out），就像排队一样，但不允许插队，新加入的成员只能排在队列尾部，先加入的成员先离开队伍。\n生活中的例子 排队做核酸。 银行办业务。 排队上车/登机等。 实现 队列也有两种存储实现方式：\n顺序队列：由一个一维数组以及两个分别指向队列首部元素和队列尾部元素的指针。 链队列：由一个带头结点的单链表实现，头指针front指向链表的头结点，头结点的next指向队列首结点，尾指针rear指向队列的尾结点。 队列的基本运算的功能描述：\n队列初始化InitQueue(Q)：设置一个空队列Q。 判断队列为空EmptyQueue(Q)：若队列Q为空，返回1，否则返回0。 入队列EnQueue(Q, x)：将数据元素x从队尾一段插入队列。 出队列OutQueue(Q)：删除队列首元素。 取队列首元素GetHead(Q)：返回队列首元素的值。 顺序队列 定义 1 2 3 4 5 6 7 const int maxSize = 20; typedef struct sequenceQueue { dataType data[maxSize]; int front, rear; } seqQueue; seqQueue SQ; front表示队列首部，rear表示队列尾部，默认值均为0，也就是指向数组的0下标，该位置不存放数据元素。\n那么入队列的操作核心关键是：\n1 2 SQ.rear = SQ.rear+1; SQ.data[SQ.rear] = x; 出队列的操作：\n1 SQ.front = SQ.front+1; 这里出队列并不会去删除队列首元素，而是移动指向队列首部的指针。\n但是会存在一个问题，举一个例子：\na)为空队列，SQ.rear指向0的下标，SQ.front指向0的下标。 b)为20入队后，SQ.rear指向下标1，SQ.front为0。 c)为入队列30、40、50后的队列，SQ.rear为4，SQ.front为0。 d)为出队列20、30、40、50后的队列，SQ.rear为4，SQ.front为4。 e)为入队列60后，SQ.rear为5，SQ.front为4。 如果在e)的状态下，要做入队列的操作，SQ.rear将会超出数组下标的范围，也就是新元素没有办法入队列，但是1-4的位置明明是空的，数组的实际空间并没有被占满，这就是假溢出现象。\n另外还有一个问题是，队列空和队列满没有办法区分，就如a)和d)的情况。\n循环队列 为了解决顺序队列的假溢出问题，于是就有了循环队列，它将顺序队列数组的首尾进行相接，形成了一个环状，思路就是当入队列操作SQ.rear即将要超出数组下标范围的时候，将SQ.rear=0进行重置，也就是SQ.data[0]作为新的队列尾，这样新的元素就能够利用上空闲的空间，达到循环使用。\n至于没有办法区分队列空和队列满的解决方法有两种：\n为队列另设一个标志，也就是多加一个变量用作区分。 队列少用一个元素空间，当只剩最后一个空间时就认为队列满，也就是CQ.rear差一步就要追上CQ.front，如图b)，书中采用了该解决方法。 循环队列的环状让我想起了MySQL redo log的checkpoint和write pos。\n定义 循环队列相关代码放在了ghjayce/code-example - cycle queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 typedef struct cycleQueue { dataType data[maxSize]; int front, rear; } cycleQueue CQ; 按以上的解决思路，以下是几个操作的关键核心：\n入队列的操作：\n1 2 CQ.rear = (CQ.rear + 1) % maxSize; CQ.data[CQ.rear] = x; 出队列的操作：\n1 CQ.front = (CQ.front + 1) % maxSize; 队列满的条件：\n1 (CQ.rear + 1) % maxSize == CQ.front; 队列空的条件：\n1 CQ.rear == CQ.front; 初始化 1 2 3 4 5 void init(cycleQueue CQ) { CQ.front = 0; CQ.rear = 0; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(cycleQueue CQ) { if (CQ.front == CQ.rear) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 9 10 int push(cycleQueue CQ, dataType x) { if ((CQ.rear + 1) % maxSize == CQ.front) { printf(\u0026#34;\\s\\n\u0026#34;, \u0026#34;队列满\u0026#34;); exit(EXIT_FAILURE); } CQ.rear = CQ.rear + 1; CQ.data[CQ.rear] = x; return 1; } 出队列 1 2 3 4 5 6 7 8 int pop(cycleQueue CQ) { if (isEmpty(CQ)) { return 0; } CQ.front = (CQ.front + 1) % maxSize; return 1; } 取队列首元素 1 2 3 4 5 6 7 8 dataType getHead(cycleQueue *CQ) { dataType data; if (isEmpty(CQ)) { return data; } return CQ-\u0026gt;data[(CQ-\u0026gt;front + 1) % maxSize]; } 为什么是CQ-\u0026gt;front + 1？\n上面有提到过，别忘了数组的第0个位置是不使用的，而front默认所指向的位置是0，即front所指向的空间是不存储元素的或者即使有也是已被出队列的元素。\n链队列 再重复一遍，链队列是一个带有头结点的单链表组成，队列首部的指针指向头结点，头指针指向首结点，队列尾部的指针指向尾结点，队列空的时候，队列首部和尾部的指针均指向头结点。\n链接的实现需要动态申请内存空间，所以不会出现队列满的情况。\n定义 链队列相关代码放在了ghjayce/code-example - link queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int id; } dataType; typedef struct linkQueueNode { dataType data; struct linkQueueNode *next; } linkQueueNode; typedef struct linkQueue { linkQueueNode *front, *rear; } linkQueue; 初始化 1 2 3 4 5 6 7 8 9 10 linkQueue *init() { linkQueue *LQ = (linkQueue *)malloc(sizeof(linkQueue)); // 生成队列的头结点 linkQueueNode *node = (linkQueueNode *)malloc(sizeof(linkQueueNode)); LQ-\u0026gt;front = node; LQ-\u0026gt;rear = node; (LQ-\u0026gt;front)-\u0026gt;next = NULL; reutrn LQ; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(linkQueue LQ) { if (LQ.rear == LQ.front) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 void push(linkQueue *LQ, dataType x) { linkQueueNode *newNode = (linkQueueNode *)malloc(sizeof(linkQueueNode)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = NULL; (LQ-\u0026gt;rear)-\u0026gt;next = newNode; LQ-\u0026gt;rear = newNode; } 出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 void pop(linkQueue *LQ) { if (isEmpty(LQ)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;队列空\u0026#34;); exit(EXIT_FAILURE); } linkQueueNode *deleteNode = LQ-\u0026gt;front-\u0026gt;next; LQ-\u0026gt;front-\u0026gt;next = deleteNode-\u0026gt;next; if (deleteNode-\u0026gt;next == NULL) { LQ-\u0026gt;rear = LQ-\u0026gt;front; } free(deleteNode); } 取队列首元素\n1 2 3 4 5 6 7 8 dataType *getHead(linkQueue *LQ) { if (isEmpty(LQ)) { return NULL; } linkQueueNode *node = LQ-\u0026gt;front-\u0026gt;next; return \u0026amp;(node-\u0026gt;data); } 应用 待补充\u0026hellip;\n数组 概念 数组array可以看成是线性表的一种推广，由一组相同类型的数据元素组成，并存储在一组连续的存储单元中。\n一维数组：又称向量。 二维数组：一维数组中的数据元素是一维数组，一般写成a[m][n]，可看作由m行n列组成的线性表。 三维数组：一维数组中的数据元素是二维数组。 n维数组：一维数组中数据元素为n-1维数组。 运算 通常只有两种基本运算：\n读：返回指定下标的数据元素。 写：修改指定下标的数据元素。 存储结构 一维数组数据元素的内存地址是连续的，而二维数组的数据元素有两种存储方法：\n以列序为主序的存储。 以行序为主序的存储，C语言编译数组采用的正是该方法。 存储结构演示和数组的逻辑结构插图.png（待补充\u0026hellip;）\n计算存储位置 有一个二维数组a[m][n]，每个数据元素占用k个存储单元大小，以行为主序，数组元素a[i][j]的存储位置是多少？要怎么计算？\nm：行数量。 n：列数量。 i：在m行的下标。 j：在n列的下标。 下标是从0开始，那么数据元素a[i][j]：\n该下标之前总共有：n * i + j + 1个数据元素，其中： 每行有n（列的数量）个元素。 在第i行，有i行元素，在第j列，有j+1个元素。 第一个元素a[0][0]与a[i][j]相差n * i + j + 1 - 1个位置。 a[i][j]的存储位置计算公式为： $$loc[i, j] = loc[0, 0] + (n * i + j) * k$$ 实战一下，例如：\n有一个二维数组a[10][20]，每个数据元素占用2个存储大小，数组的起始内存地址为2000，求：\na[5][10]的存储位置是多少？ 整理数据： m：10。 n：20。 i：5。 j：10。 k：2。 将数据套入公式：2000 + (20 * 5 + 10) * 2，存储位置最终为：2220。 a[8][19]呢？交给你来试试。 矩阵的压缩存储 待补充\u0026hellip;\n特殊矩阵 对称矩阵 如果一个n阶的方阵满足以下条件，则是一个对称矩阵：\n$a_{ij} = a_{ji}$ $0 \\leq i, j \\leq n - 1$ 三角矩阵 稀疏矩阵 应用 1、对一个$N{\\times}N$阶的矩阵A进行逆置，请设计出算法。\n1 2 3 4 5 6 7 8 9 10 11 void MM(int A[n][n]) { int i, j, temp; for (i = 0; i \u0026lt; n; i++) { for (j = 0; j \u0026lt; i; j++) { temp = A[i][j]; A[i][j] = A[j][i]; A[j][i] = temp; } } } 综合运用 待补充\u0026hellip;\n","date":"2023-09-18T12:24:10+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter3/","title":"第三章 栈、队列和数组 - 《数据结构导论》笔记"},{"content":"概念 数列：按特定规律排列的一组数字的集合。 等差数列：指从第二项起，每一项与它的前一项的差都是同一个常数，这个常数称为公差。 例如：\n1、4、7、10、13、16、19 这是一组等差数列，每个数字之间相差3，其中：\n公差为：3。 首项（数列的第一个数字）是：1。 末项（数列的最后一个数字）是：19。 项数（数列的总数）：7。 数列的项（简称项）：数列中的一个个数字。 辨认 以下数列是否是等差数列？\n2、6、10、14、18、22，是 1、2、1、2、3、4、5、6，不是 1、2、4、8、16、32、64，不是 9、8、7、6、5、4、3、2，是 计算 求项的数 2、5、8、11、14、\u0026hellip;、?，求？第21项的数字是多少？\n如果项是最后一个也称为求末项\n分析：\n公差是3，找一下规律：\n5，序号2，和2之间差1个3。 8，序号3，和2之间差2个3（2+2个3）。 11，序号4，和2之间差3个3（2+3个3）。 14，序号5，和2之间差4个3（2+4个3）。 \u0026hellip; 根据规律问题变成了：序号21，2到底要加几个3？\n答案是：2 + (序号 - 1)个3，也就是2+20个3，所以第21项的数字是：62。\n因此得出公式：$$第n项的数 = 首项 + (n的序号 - 1) \\times 公差$$ 如果求第1个项的数字，也就是求首项，那么公式是： $$首项 = 末项 - (项数 - 1) ×公差$$\n求项的序号 5、8、11、14、17、20、\u0026hellip;、65是其中的第几项？\n如果项是最后一个也称为求项数\n直接套公式：$$某项的序号 = (某项的数 - 首项) \\div 公差 + 1$$ 公差是3，也就是：(65 - 5) / 3 + 1，65项的序号是：21。\n求和 2、4、6、8、10、12、14，这个数列各项加起来的和是多少？\n分析：\n倒序相加求和\n正序 S = 2 + 4 + 6 + 8 + 10 + 12 + 14 倒序 S = 14 + 12 + 10 + 8 + 6 + 4 + 2 2+14、4+12、6+10，正序和倒序的值加在一起都是相等的，于是可以写成：\n2S = (2 + 14) × 7 S = (2 + 14) × 7 ÷ 2 最终各项加起来的和是：56。\n得出公式，这个公式也称为高斯求和： $$和 = (首项 + 末项) \\times 项数 \\div 2$$\n参考 小学数学—计算之等差数列_哔哩哔哩_bilibili 小学奥数——高斯求和公式，简单问题的再思考 ","date":"2023-09-07T19:05:42+08:00","permalink":"https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/","title":"什么是等差数列？"},{"content":"前言 一开始打算在手机上安装git，想到的是安装app，于是各种找，找到了有如：\nagit MGit \u0026hellip; 但是试过这些app以后发现要么BUG很多，要么根本不能正常使用，而且项目也很久没有更新了，只能另外再找别的app。\n机缘巧合下，让我找到了口袋git（com.aor.pocketgit）的app，正常使用了一段时间，最近再用的时候，频繁出现了Failed to fetch my_project.，没有办法fetch项目，也就没法继续使用了。\n开始我以为是账号密码的认证方式出了问题，于是我尝试换另一种认证方式——私钥，但是它的私钥是.ppk的格式，和ssh生成的密钥不太一样，一轮搜索以后：\n说是需要用到PuTTy的PuTTY Key Generator来对ssh的密码进行转换处理得到.ppk的文件。 按照步骤转换好以后再放到app上，显示了感叹号，感觉不太对劲，进行fetch操作时果然，提示Invalid Private Key. 好家伙，ppk的方式也不行，也不想再试了，那为什么用的好好的账密认证方式出了问题呢？\n我估计是最近github强制使用2FA的关系，登录账号需要经过两步验证，app应该是没有做这个异常处理，而且在app内也没有办法升级。\n于是我放弃了这个app，换了另一条路。\n安装git环境 在逛Stack Overflow时发现了Termux这个app，它是在Android上运行的一个终端软件，也就是直接敲命令在手机上安装git环境。\n打开app，执行以下命令安装：\n1 2 $ apt update $ apt install git 安装完以后，熟悉的操作方式就回来了：\n1 2 $ git --version git version 2.42.0 剩下的就不用多说了，ssh-keygen走一波，下面贴一下我遇到的问题和解决过程。\n操作过程 第一时间就是进入到项目目录，先看看自己在哪个目录：\n1 2 3 4 5 $ pwd /data/data/com.termux/files/home # 然后查看根目录都有些什么 $ ls / ls: cannot open directory \u0026#39;/\u0026#39;: Permission denied 竟然没权限，whoami一看，哦，看来还是root用习惯了，普通用户只拥有/data/data/com.termux目录下的权限，而/data/data之前的目录都没有权限。\n那怎么搞？没有权限我怎么知道我的项目在哪个路径下？？\n熟悉安卓开发的同学或者搞过机的同学就知道，我们在文件管理看到的根目录，是在/storage/emulated/0/下，我也是在折腾了一番以后才得知。\n这么长的路径，不行，我得设置成全局变量才行\n1 2 3 4 5 6 7 8 # 习惯用vim去编辑，其实还有别的方式 $ vim ~/.bash_profile The program vim is not installed. Install it by executing: pkg install vim or pkg install vim-gtk, after running pkg in x11-repo or pkg install vim-python 这里我执行了pkg install vim，然后你懂的。\n然后cd进项目路径，查看配置信息：\n1 2 3 $ git config --list fatal: detected dubious ownership in repository at \u0026#39;/xxx/xxx\u0026#39; To add an exception for this directory, call: git config --global --add safe.directory /xxx/xxx 跟着提示将我们的项目路径设置成安全目录就行。\n1 2 3 $ ssh-keygen -t rsa -C \u0026#34;your@email.com\u0026#34; The program ssh-keygen is not installed. Install it by executing: pkg install openssh 跟着提示执行pkg install openssh，然后遇到连续四个CANNOT LINK EXECUTABLE \u0026quot;ssh-keygen\u0026quot;: library \u0026quot;libcrypto.so.3\u0026quot; not found。\n这里需要执行pkg install openssl安装相关依赖，再重新执行安装命令就可以了。\n1 2 $ git fetch origin CANNOT LINK EXECUTABLE \u0026#34;/data/data/com.termux/files/usr/libexec/git-core/git-remote-https\u0026#34;: library \u0026#34;libssl.so.1.1\u0026#34; not found 解决：\n1 2 3 4 5 6 7 $ find /data/data/com.termux/files -name \u0026#39;libssl.so.*\u0026#39; /data/data/com.termux/files/usr/lib/openssl-1.1/libssl.so.1.1 /data/data/com.termux/files/usr/lib/libssl.so.3 # 如果没有的话，先执行 pkg install openssl1.1-tool # 添加环境变量 echo \u0026#34;export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile \u0026amp;\u0026amp; source ~/.bash_profile 新的问题：\n1 2 3 4 $ git fetch origin fatal unable to access \u0026#39;https://github.com/xxx.git\u0026#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream # 解决： $ git config --global http.version HTTP/1.1 参考 How to use Git on Android? - Stack Overflow 生成Git ssh公钥和私钥（ppk）文件 Termux-setup-storage - Termux Wiki library “libssl.so.1.1“ not found 安卓神器termux使用命令时的报错。_4ustn1ne的博客-CSDN博客 ","date":"2023-08-30T13:26:26+08:00","permalink":"https://ghbjayce.github.io/p/system/android/env/install-git/","title":"在android上安装git环境"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 概要 线性表 概念 特征 基本运算的功能描述 初始化 求表长 读取元素 定位 插入 删除 线性表的顺序存储结构——顺序表 概念 用C语言描述 运算实现的关键步骤和算法 容量 表长 插入 删除 定位 应用 实现简单算法 算法实现的分析 线性表的链式存储结构——单链表 特点和结构 基本概念 头指针 头结点 首结点 尾结点 空链表 用C语言描述 运算实现的关键步骤和算法 插入 删除 定位 综合应用 设计算法解决应用问题 顺序表和链表的优缺点、适用场景 循环链表和双向循环链表 特点和结构 用C语言描述 基本运算 插入 删除 线性表 概念 线性表Linear List是一种线性结构，它是由n（n ≥ 0）个数据元素组成的有穷序列，其中：\n数据元素又称为结点。 这里的n代表线性表的总结点个数，又称为表长。 当表长为0时，也就是线性表没有任何结点，称为空表，用 () 或 Ø 表示。 线性表通常表示成：(A1, A2, A3, ..., An)，其中： A1称为起始结点。 An称为终端结点。 A1是A2的直接前驱，A3是A2的直接后继，其他结点同理。 特征 线性表中结点之间具有一对一的关系。 非空表的情况下： 除了起始结点没有直接前驱（例：A1），其他的结点有且仅有一个直接前驱（例：A2、A3等）。 除了终端结点没有直接后继（例：An），其他的结点有且仅有一个直接后继（例：A1、A2等）。 基本运算的功能描述 以下的no指的是序号，文中所有提到的“位置”都是指序号。\n避免用i命名是怕和数组的下标混在一起，数组的下标是从0开始，而序号是从1开始。\n初始化Initiate(L)：建立一个空表L=()，L不包含任何结点。 求表长Length(L)：返回线性表L的长度，以下简称表L。 读取元素Get(L, no)：返回表L的第no个结点，当no超出Length(L) ≥ no ≥ 1范围，返回一特殊值。 定位Locate(L, x)：返回表L中第一个结点的值等于x值的序号，如果找不到则返回0。 插入Insert(L, x, no) ：两个步骤。 在表L的第no个结点之前插入一个新结点x，no的合法范围：Length(L) + 1 ≥ no ≥ 1。 表长度加1。 删除Delete(L, no)：两个步骤。 删除表L的第no个结点，no的合法范围：Length(L) ≥ no ≥ 1。 表长度减1。 顺序表 概念 顺序存储：将结点依次存放在计算机内存中一组连续的存储单元中，逻辑结构中相邻的结点它的存储位置也相邻。 顺序表：用顺序存储实现的线性表，一般使用数组来表示顺序表。 用C语言描述 假设线性表的数据元素的类型为DataType，顺序表的结构定义如下：\n1 2 3 4 5 6 7 const int Maxsize = 100; // 预先定义一个足够大的常数 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 顺序表的实际长度 } SeqList; // 顺序表类型名为SeqList SeqList L; // 定义L为一个顺序表 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const int Maxsize = 7; // 预先定义数组大小 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 线性表的实际长度 } SeqList; // 顺序表的类型 SeqList student; // student是顺序表的名称 运算 以下相关运算的代码已经整理好，放在了ghjayce/code-example - sequence list中，感兴趣的话可以clone到本地查看运行结果。\n插入 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SeqList insertSeqList(SeqList L, DataType x, int no) { if (L.length \u0026gt;= Maxsize) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;表已满\u0026#34;); exit(EXIT_FAILURE); } // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 2 if (no \u0026lt; 1 || no \u0026gt; L.length + 1) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;插入位置不正确\u0026#34;); exit(EXIT_FAILURE); } for (int i = L.length; i \u0026gt;= no; i--) { L.data[i] = L.data[i - 1]; } L.data[no - 1] = x; L.length++; return L; } 步骤：\n检查插入位置是否合法。 表容量，表满了以后不能再插入。 插入位置： 不能插入序号no = 0及之前的位置，no = 1的位置可以插入。 要插入的位置，它前面的位置不能是空的，也就是不能断开插入。 例：插入第5个位置，第4个位置是空的。 为插入位置腾出空位，从最后一个结点开始从后往前循环，将结点往后移一个位置，直到插入位置结束。 插入新的结点x，也就是序号no的位置，对应下标为：no-1。 表长度加一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n}{2}$。 插入算法中，元素的移动次数不仅与顺序表的长度n有关，还和插入的no位置有关：\n当插入位置是n+1时，移动次数为0。 当插入位置是n时，移动次数为1，这个称为首项（从存在的元素中选取，它也可以是尾项）。 当插入位置是n-1时，移动次数为2。 当插入位置是n-2时，移动次数为3。 \u0026hellip; 当插入位置是1时，移动次数为n，这个称为末项。 根据移动次数变化的规律可以看出：\n比较和移动次数的计算方式为：n - no + 1。 可插入的位置有：n + 1个。 这是个等差数列。 使用高斯求和公式可以得出总的移动次数为：$\\frac{(n + 1) \\times n}{2}$。 因此平均移动次数：$\\frac{总移动次数}{可插入位置}$也就是$\\frac{\\frac{(n + 1) \\times n}{2}}{n + 1}$约为$\\frac{n}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n删除 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 SeqList deleteSeqList(SeqList L, int no) { // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 1 if (no \u0026lt; 1 || no \u0026gt; L.length) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;非法位置\u0026#34;); exit(EXIT_FAILURE); } for (int i = no; i \u0026lt; L.length; i++) { L.data[i-1] = L.data[i]; } L.length--; return L; } 步骤：\n检查删除位置是否合法，不能是0及之前的位置，也不能是超出表长之后的位置。 覆盖结点，从删除位置开始，后一个结点移动到前一个位置，直到最后一个结点结束，即表示删除。 表长度减一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n-1}{2}$。 跟插入算法一样：\n当删除位置是n时，移动次数为0。 当删除位置是n-1时，移动次数为1。 当删除位置是n-2时，移动次数为2。 \u0026hellip; 当删除位置是1时，移动次数为n-1。 根据规律得出：\n移动次数的计算方式：n - no。 可删除的位置有：n个。 同样是等差数列。 使用高斯求和公式得出总的移动次数：$\\frac{(0 + n - 1) \\times n}{2}$。 平均移动次数：$\\frac{总移动次数}{可删除的位置}$也就是$\\frac{\\frac{(0 + n - 1) \\times n}{2}}{n}$约为$\\frac{n-1}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n定位 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 int locateSeqList(SeqList L, DataType x) { int i = 0; // 为了简化运算，这里只比对DataType里的id while ((i \u0026lt; L.length) \u0026amp;\u0026amp; (L.data[i].id != x.id)) { i++; } if (i \u0026lt; L.length) { return i + 1; } return 0; } 步骤：\n初始化一个下标值：0。 从头到尾逐个比对，数组中的结点是否与结点x相等： 不相等则继续循环。 相等则表示已经找到，停止循环。 返回查找结果。 表长 只需要返回L.length即可\n链表 概念 链表的结点：由数据域（数据元素）和指针域或者叫链域（表示数据元素之间的逻辑关系）组成。 数据域：相当于火车厢。 指针域：相当于连接火车厢的车钩。 链式存储：各个结点在内存中的存储位置并不一定连续，逻辑结构中相邻的结点其存储位置不一定相邻。 链表：用链式存储实现的线性表，所有结点通过指针链接形成链表Link List，结点之间可以重新链接。 单链表：每个结点由一个数据元素和一个指向下一个结点（后继结点）的next指针构成。 循环链表：单链表的基础上，尾结点的指针指向首结点。 双向循环链表：循环链表的基础上，每个结点增加一个指向上一个结点（前驱结点）的prio指针。 组成介绍： head：头指针变量，有两个作用： 它的值指向链表的第一个结点。 也可以用来命名链表，例如下图链表称为：表head、head表。 首结点：链表中第一个数据元素结点。 尾结点：也称终端结点，指链表中最后一个数据元素结点。 空指针：尾结点的指针域的值为NULL。 空链表：head等于NULL，表示链表无任何结点。 头结点：为了方便运算，在首结点之前增加一个相同类型的结点，如图C)。 表结点：除了头结点以后的结点。 用C语言描述 1 2 3 4 5 6 7 8 typedef struct node { DataType data; struct node *next; } Node, *LinkList; // Node，*LinkList都是结构体的别名，其中 // Node是指向struct node类型的别名 // *LinkList是指向Node类型的指针的别名 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct node { DataType data; // 数据域 struct node * next; // 指针域 } Node, *LinkList; // Node是链表结点的类型 LinkList head; // 定义一个全局变量，head是链表的名称 运算 以下相关运算的代码已经整理好，放在了ghjayce/code-example - link list中，感兴趣的话可以clone到本地查看运行结果。\n初始化 1 2 3 4 5 6 7 LinkList initLinkList() // 建立一个空的单链表 { LinkList head; // 定义局部变量，头指针 head = malloc(sizeof(Node)); // 动态构建一结点，它是头结点 head-\u0026gt;next = NULL; return head; } 步骤：\n基于LinkList结构，构建一个名为head的单链表。 通过给head分配内存、设置属性，此时head是一个头结点，next指针为NULL，表示链表为空。 返回这个链表的头结点。 求表长 1 2 3 4 5 6 7 8 9 10 11 12 int lengthLinkList(LinkList head) // 求单链表head的长度 { // 声明一个指向Node对象的名为point的指针变量，它指向head的头结点 Node *point = head; int count = 0; while (point-\u0026gt;next != NULL) { point = point-\u0026gt;next count++; } return count; } 步骤：\n指向head表的头结点。 初始化count计数。 从head头结点开始，检查头结点的下一个结点，也就是首结点： 结点不为空，此时point变成首结点，计数+1，依次往后检查下一个结点是否为NULL。 结点为NULL结束循环。 返回表长。 读取元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Node *getLinkList(LinkList head, int no) // 读取序号为第no个结点，读到返回结点 { Node *point; point = head-\u0026gt;next; int position = 1; while (point != NULL \u0026amp;\u0026amp; position \u0026lt; no) { point = point-\u0026gt;next; position++; } if (position == no) { return point; } return NULL; } 步骤：\n声明point指针变量，指向head表的首结点。 初始化position，也就是从第一个结点（位置1）开始查找。 检查point结点不能是空的，并且position要小于查找的no。 符合条件，表示还没找到，此时point变成下一个结点，position+1，重复步骤3。 不符合条件，结束循环，分为两种情况，可能遍历完整个链表都没找到或者提前找到了。 判断position是否等于no序号： 相等，表示已经找到，返回point结点。 不相等，表示没有找到，返回NULL值。 定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int locateLinkList(LinkList head, DataType x) // 在head表中找到第一个符合x结点的序号 { Node *locateNode; locateNode = head-\u0026gt;next; int no = 1; while (locateNode != NULL \u0026amp;\u0026amp; locateNode-\u0026gt;data != x) { locateNode = locateNode-\u0026gt;next; no++; } if (locateNode == x) { return no; } return 0; } 关键点：\n从首结点开始，当前结点不为空并且不等于要查找的值则继续检查下一个结点： 如果提前找到结点locateNode，循环结束。 如果遍历完链表依然没找到，locateNode等于尾结点，循环结束。 比对locateNode和x： 相等，就是找到了，返回locateNode所在的序号。 不相等，也就是没找到，返回0。 插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList insertLinkList(LinkList head, DataType x, int no) { Node *queryNode, *newNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL) { printf(\u0026#34;插入位置有误\u0026#34;); exit(EXIT_FAILURE); } newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = queryNode-\u0026gt;next; queryNode-\u0026gt;next = newNode; return head; } 关键点：\n找到要插入位置的前驱结点query： 生成一个新的结点newNode，按照Node结构分配内存。 newNode的next要指向query的next，数据域赋值为x也别忘了。 query的next指向newNode。 注意如果插入的位置为1，要做处理，避免取一个非法的前驱结点。 要对查找插入位置的结果做处理。 1.2和1.3的步骤不能调换，必须严格执行，不然会丢失query的next结点。 删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList deleteLinkList(LinkList head, int no) { Node *deleteNode, *queryNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL || queryNode-\u0026gt;next == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;删除的位置错误\u0026#34;); exit(EXIT_FAILURE); } deleteNode = queryNode-\u0026gt;next; queryNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); return head; } 关键点：\n和插入有点类似，也得先找到要查删除位置的前驱结点query，当然也要注意非法前驱的处理。 要对查找删除位置的结果做处理。 要删除的结点放到临时变量存起来，目的用于free释放内存空间。 把前驱结点query的next指向删除结点的next即可，如果删除结点是尾结点，那么query的next就是NULL。 创建 为了方便后续算法演示，这里用一个数组来构建单链表，再简化一下DataType的属性：\n1 2 3 4 5 6 int nums[6] = {4, 7, 2, 5, 2, 4}; typedef struct { int age; } DataType; 结合以上已实现的算法initLinkList()和insertLinkList()，实现一个创建链表的算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 LinkList createLinkListByEach(int *arr, int size) { LinkList point = initLinkList(); for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; insertLinkList(point, item, i+1); } return point; } // 调用 // 为了方便展示直接写6，size自动计算：sizeof(nums) / sizeof(nums[0]) createLinkListByEach(nums, 6); 缺点：每次插入结点都要遍历一次链表。\n尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList createLinkListByTailInsert(int *arr, int size) { LinkList head; Node *lastNode, *newNode; head = malloc(sizeof(Node)); lastNode = head; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; lastNode-\u0026gt;next = newNode; lastNode = newNode; } lastNode-\u0026gt;next = NULL; return head; } 优点：每次插入新结点都能从尾结点进行而不需要每次遍历整个链表。\n头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList createLinkListByHeadInsert(int *arr, int size) { LinkList head; Node *newNode; head = malloc(sizeof(Node)); head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; newNode-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = newNode; } return head; } 与尾插法算法一样，只是插入新结点是从头结点进行，最终链表的顺序与尾插法相反。\n删除重复结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 LinkList removeRepeatLinkList(LinkList head) { Node *searchNode; // 要查找的结点 Node *checkNode; // 要检查（比对）的结点 Node *deleteNode; // 要删除的结点 searchNode = head-\u0026gt;next; // 从首结点开始 while (searchNode != NULL) { // 关键，从首结点开始，循环检查当前结点的下一个结点 checkNode = searchNode; while(checkNode-\u0026gt;next != NULL) { if (searchNode-\u0026gt;data.age == checkNode-\u0026gt;next-\u0026gt;data.age) { deleteNode = checkNode-\u0026gt;next; checkNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); } else { checkNode = checkNode-\u0026gt;next; } } searchNode = searchNode-\u0026gt;next; } return head; } 关键点：\n从首结点开始遍历，取它的值与下一个结点的值进行比较，找到相等的值进行删除。 checkNode=searchNode; while(checkNode-\u0026gt;next != NULL)是关键之一。 其他链表 循环链表 带尾结点访问首结点的表示方式：rear-\u0026gt;next-\u0026gt;next，运算与单链表类似，不再赘述。\n双向循环链表 用类C语言来描述：\n1 2 3 4 5 6 7 struct dbnode { DataType data; struct dbnode *prior, *next; } typedef struct dbnode *dbpointer; typedef dbpointer DLinkList; 双向循环链表和单链表的运算差不多，主要提一下删除和插入运算的差异。\n删除算法的关键点：\n1 2 3 removeNode-\u0026gt;prior-\u0026gt;next = removeNode-\u0026gt;next; removeNode-\u0026gt;next-\u0026gt;prior = removeNode-\u0026gt;prior; free(removeNode); 第1行和第2行代码顺序颠倒也可以，不影响最终效果。\n插入算法的关键点：\n1 2 3 4 newNode-\u0026gt;prior = query; newNode-\u0026gt;next = query-\u0026gt;next; query-\u0026gt;next-\u0026gt;prior = newNode; query-\u0026gt;next = newNode; 注意query是指插入位置的前驱结点，以及这些语句的顺序。\n先接好新结点的prior和next指针的指向。 再将插入位置结点的prior指针指向新结点。 最后将query结点的next指针指向新结点。 顺序表和链表的比较 异同 存储方式： 顺序表： 使用连续的内存空间来存储结点。 需要预先分配存储空间，存储结点个数有上限。 链表： 结点由数据元素和指针组成，指针指向下一个结点，存储在内存空间连不连续都可以。 不需要预先分配存储空间，存储结点个数没有上限。 访问效率： 顺序表： 能根据索引快速定位结点，时间复杂度O(1)。 读取结点支持随机访问。 链表： 只能通过遍历链表，从头到尾逐个遍历查找目标结点，时间复杂度O(n)。 读取结点不支持随机访问。 运算（插入和删除）： 顺序表： 插入和删除需要移动后续的结点，以保证结点之间的连续性。 插入和删除操作之前需要查找定位，时间复杂度O(n)。 链表： 插入和删除只需要修改结点之间指针的指向关系，不需要移动结点。 跟顺序表一样需要查找定位，时间复杂度也是O(n)。 优缺点 顺序表： 优点： 随机访问效率高。 缺点： 插入和删除的操作代价高。 需要预先分配一块连续的内存空间。 存储结点个数有上限。 链表： 优点： 插入和删除的操作代价低。 对内存空间控制动态且灵活。 存储结点个数没有上限（取决于可用内存空间）。 缺点： 不支持随机访问。 相对要占用多一些内存空间来存放指针域。 适合场景 根据上面的优缺点可得知：\n顺序表：更适合读多写（插入和删除）少的场景。 链表：更适合写多读少的场景。 综合应用 待补充\u0026hellip;\n","date":"2023-08-29T14:46:12+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter2/","title":"第二章 线性表 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 P21 ~ 34（13页） 第二章 线性表 P35 ~ 58（23页） 第三章 栈、队列和数组 P59 ~ 92（33页） 第四章 树和二叉树 P93 ~ 128（35页） 第五章 图 P129 ~ 160（31页） 第六章 查找 P161 ~ 182（21页） 第七章 排序 P183 ~ 204（27页） 考试重点 阅读说明 本书 书名：《数据结构导论》 出版：外语教学与研究出版社 版本：2012年版 全书以类C语言来描述相关内容，例如：存储结构、算法等。 本文涉及知识点 数学知识 乘法分配率 对数 等差数列、高斯求和 概要 数据、数据元素和数据项 基本概念 三者的关系 数据的逻辑结构和存储结构 四种基本的逻辑结构和特点 集合 线性结构 树形结构 图结构 两种基本的存储结构 顺序存储 链式存储 逻辑结构与存储结构的关系 运算与逻辑结构的关系 算法分析 描述方法 评价因素 时间复杂度的分析方法 空间复杂度的分析方法 数据、数据元素和数据项 概念和联系 数据项：在数据表中指的是一个个的字段，又称字段或域，数据的最小标识单位。 数据元素：在数据表中相当于一行记录，又称结点，由若干个数据项组成。 数据：被计算机处理、存储的对象，由若干个数据元素组成。 数据的逻辑结构和存储结构 概念 数据结构：包含数据的逻辑结构、存储结构和基本运算。 逻辑结构：整个数据元素之间的逻辑关系。 逻辑关系：指单个数据元素之间的关联方式或邻接关系，也就是单个数据元素之间的组织形式。 存储结构：也称物理结构，数据的逻辑结构在计算机中的实现称为数据的存储结构。 简单点说：为了保存数据的逻辑结构到计算机中而实现的存储结构。 逻辑结构 四类基本的逻辑结构：\n集合：任意两个结点之间都没有邻接关系，组织形式松散，就像抽奖箱里的乒乓球。 结点之间除了同属一个集合，并没有别的关系。 线性结构：结点之间一个个依次相邻接排列，形成一条“链”，就像一条绳子上的多个绳结。 结点之间是一对一的相互关系。 树形结构：上层结点有多个下层结点，下层结点只有一个上层结点，具有分支、层次特性，就像一颗树。 结点之间是一对多的相互关系。 图结构：最为复杂的结构，任意两个结点都可以相邻接，就像地铁线路图、人与人之间的社交网络。 结点之间是多对多的相互关系。 存储结构 存储结构一般包括两个部分：\n需要存储的数据元素 结点之间的逻辑关系 实现结点之间的逻辑关系的存储结构，一般有四种形式，主要掌握顺序存储和链式存储：\n顺序存储：所有结点存储在一个连续的存储区域里，利用结点在存储器中的相对位置，来表示结点之间的逻辑关系。 链式存储：除了存储结点本身，还需要一个指针，指针指向有逻辑关系的结点，也就是利用指针表示结点之间的逻辑关系。 索引存储 散列存储 如何描述 怎么描述存储结构是哪种类型？哪种实现形式呢？分为两种方式：\n机器级：即存储结构在计算机存储器里的表示形式，以内存地址的方式。 语言级：即用程序设计语言中的类型说明、变量说明，例如，数据类型：数组、结构体和指针等。 运算 概念 运算是指在逻辑结构上施加的操作，也就是对逻辑结构的加工。\n这些运算操作包括：\n建立 查找 读取 插入 删除 等\u0026hellip; 算法分析 评价算法 评价算法好坏的因素分为几个方面：\n正确性：能正确地实现预定的功能，满足具体问题的需要。 易读性：易于阅读、理解和交流，便于调试、修改和扩充。 健壮性：能处理不同的输入环境，即使是非法数据，也不会产生预料不到的运行结果。 时空性：指算法的时间性能（所需计算量）和空间性能（所需存储量）。 时间复杂度 计算量 来算一算函数执行了几次\n例子A：\n1 2 3 4 5 int func1(void) { printf(\u0026#34;hello ghjayce\u0026#34;); return 0; } 共执行了2次，printf1次 + return1次\n例子B：\n1 2 3 4 5 6 7 int func2(int n) { for (int i = 0; i \u0026lt; n; ++i) { printf(\u0026#34;hello ghjayce\u0026#34;); } return 0; } 共执行了3n + 3次\n分析过程：\nint i = 0，由始至终仅会执行1次。 i \u0026lt; n，执行n + 1次。 ++i，执行n次。 printf，执行n次。 return，执行1次。 要估算某段代码的执行次数，可以用T(n)来表示：\nT：某段代码的总执行次数。 n：输入数据的规模大小或者数量。 也就是一个算法的计算量是问题规模n的函数，代入以上例子来表示：\n例子A：T(n) = 2 例子B：T(n) = 3n + 3 转换 得出代码的执行次数估算值后，需要转换成时间复杂度的表示方式，以下是转换规则：\n如果T(n)是常数的话，时间复杂度直接估算为 1。 如果T(n)不是常数的话，例如：常数 × n + 常数 仅保留最高次项，也就是常数 × n 常数化为1，也就是1 × n，这里的系数可以直接省略。 因此时间复杂度估算为：n。 表达方式还不完整，需要加上大O表示法，也称渐进表示法，例如：O(时间复杂度估算值)\n结合以上例子，那么时间复杂度表示为：\n例子A：O(1) 例子B：O(n) 如果代码量比较多或者函数调用比较多的情况下这样估算会相当麻烦，所以下面是简化估算过程：\n例子C：\n1 2 3 4 5 6 7 8 void func3(int n) { for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { printf(\u0026#34;hello ghjayce\u0026#34;); } } } 分析过程：\n里面的for循环的时间复杂度：n + 1 这里for的时间复杂度：n for里面的语句的时间复杂度：1 外面的for循环的时间复杂度：(n + 1) × n，也就是(n × n) + (n × 1)，即n² + n 最终时间复杂度为：O(n²)\n例子D：\n1 2 3 4 5 6 7 8 void func(int n) { for (int i = 0; i \u0026lt; n; ++1) { for (int j = i; j \u0026lt; n; ++j) { printf(\u0026#34;hello ghjayce\u0026#34;); } } } 最终时间复杂度为：O(n²)，待补充\u0026hellip;\n例子E：\n1 2 3 4 5 6 void func(int n) { for (int i = 1; i \u0026lt; n; i *=2) { printf(\u0026#34;hello ghjayce\u0026#34;); } } 最终时间复杂度为：O(logn)，待补充\u0026hellip;\n性能对比 常数阶：O(1) 对数阶：O(log2n)，log的底数可以省略不写，也就是：O(logn)，下面也是一样 线性阶：O(n) 线性对数阶：O(nlogn) 多项式阶：O(nc)，C为大于1的正整数，下面也是一样 平方阶：O(n²) 立方阶：O(n3) K次方阶：O(nk) 指数阶：O(Cn)，常见是O(2n) 以上时间复杂度，复杂程度和耗时从上往下依次增加，即越往下时间复杂度越高，所需耗时越多。\n通常认为，具有指数阶的算法是不可计算的，而阶数低于平方阶的算法是高效率的。\n另外，时间复杂度的性能还会受到输入数据的变化而有所影响，基于相同输入数据量的不同输入数据，分为：\n最坏时间复杂度：算法时间用量的最大值。 平均时间复杂度：算法时间用量的平均值。 空间复杂度 一个算法的空间复杂度定义为该算法所耗费的存储空间，它也是问题规模n的函数，记为： $$S(n)=O(g(n))$$ 其中，g(n)为问题规模n的某个函数。一个算法在执行期间所需的存储空间量分为：\n程序代码所占用的空间，对不同算法来说也不会有数量级的差别。 输入数据所占用的空间，由问题规模决定的，不随算法的不同而改变。 辅助变量所占用的空间，也称附加存储空间，它所占用的空间会受到问题规模和不同的算法所影响。 来个例子实践一下，假设，n=100。\n例子A：\n1 2 3 4 5 6 7 8 9 void f1(int a[], int n) { int i, temp; for (i = 0; i \u0026lt;= n/2; i++) { temp = a[i]; a[i] = a[n-1-i]; a[n-1-i] = temp; } } f1所需要的辅助变量为2个整型变量i和temp，与问题的规模无关，空间复杂度为：O(1)。\n例子B：\n1 2 3 4 5 6 7 8 void f2(int a[], int n) { int i, b[100];//随n的大小 for (i = 0; i \u0026lt;= n-1; i++) b[i] = a[n-1-1]; for (i = 0; i \u0026lt;= n-1; i++) a[i] = b[i]; } f2所需要的辅助变量为1个整型变量i和随n大小的数组b，b与问题的规模有关，空间复杂度为：O(n)。\n如果是递归调用呢？\n待补充\u0026hellip;\n参考 指数和对数 小学生也能看懂的时间复杂度 小学速算技巧15讲：简便计算，认知乘法分配率 ","date":"2023-08-20T16:36:20+08:00","image":"https://ghjayce.github.io/asset/blog/k13uqmFROI7ZE6i8K9HpMjAyNDAzMDFfMTM1MDM2.png","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter1/","title":"第一章 概论 - 《数据结构导论》笔记"},{"content":"前言 开头废话有点多，点我进入正题\n为什么想要搭建一个博客？ 说起来有很多方面的因素，最重要的目的是希望能够留下一些技术积累和记录可以给别人看，同时提升一下写作的能力，毕竟与平时记笔记的方式完全不同。\n虽然也没有什么人看🤷\n其实在此之前也有写过博客，比如早期使用heroku + php搭建的个人博客，因为需要不断开发完善功能，加上后来也不免费了，索性不折腾直接上博客网站上写博客，如：CSDN、Segmentfault等。\n但这些平台使用下来以后也发现了一些问题，总的来说就是不适合自己的使用，写文章的过程也不够简洁直接，不够纯粹。\n我理想中的博客是什么？ 专注于markdown的编写 支持全文检索 具有标签功能 能够归档文章 免费 支持永久存储 为什么选择了hugo？ 查阅资料得知，静态站点生成器有三种提的比较多，分别是：\njekyll，基于Ruby语言编写 hexo，基于Node.js编写 hugo，基于Go语言编写 之所以选择hugo，它是当中编译速度最快、文档相对友好、star数量还多，正好无意间找到Hugo Themes的主题，很好的契合了需求，就决定是它了。\n阅读前提 本文默认你已经掌握了以下的几个点：\n了解github pages并且会配置 熟悉使用git 通过该文章可以快速上手使用hugo，所以有一些内容不会详细展开。\n快速入门 安装Hugo 这里我用的是Mac系统，所以采用Homebrew的方式进行安装，其他安装方式自行查阅。\n1 2 brew install hugo hugo version 创建项目 1 2 3 hugo new site your-project-name cd your-project-name git init 由于我已经有git项目ghjayce.github.io，里面没有任何东西，所以这里我使用了hugo new site ghjayce --force，既不影响hugo的生成又不影响git的项目。\n执行完以后，你会得到以下的目录结构：\n1 2 3 4 5 6 7 8 9 ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── layouts ├── static └── themes 安装主题 由于新建的项目没有默认主题，我们从主题库把挑好的主题下载下来。\n1 2 3 4 5 6 git clone git@github.com:CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack cp -r ./themes/hugo-theme-stack/exampleSite/content/* ./content cp ./themes/hugo-theme-stack/exampleSite/config.yaml ./hugo.yaml rm -f ./hugo.toml # 以下是示例主题需要操作的命令，避免没有翻墙的情况下启动不了项目 rm -rf ./content/post/rich-content 站点配置文件为hugo.toml，支持三种后缀的格式：toml、yaml、json，这里我选择用yaml\nHello World 生成一篇文章。\n1 2 # 对应的生成位置：/your-project-name/content/post/first-post.md hugo new post/first-post.md 打开它写点内容。\n1 2 3 4 5 6 7 --- title: \u0026#34;First Post\u0026#34; date: 2023-06-20T17:45:58+08:00 draft: true --- # hello world 启动 1 2 # 执行成功以后，终端会出现server的地址，例如：http://localhost:1313/ hugo server --buildDrafts --buildDrafts的作用是草稿文章（对应文章中的draft: true属性）也进行生成，去除的话会跳过生成草稿。\n构建\u0026amp;发布 1 hugo 你会看到多出一个public目录，就是构建好以后的内容，里面的内容完全是静态的，放到站点下就能够访问。\n但是我们要发布到github page上，根目录只支持/docs，所以我们得把public改成docs，有两种方式：\n构建时加上参数：hugo --destination docs 在配置文件中加入参数：publicDirectory: docs 如果仓库只放public目录下的内容，那么可以忽略这里。\n版本说明 文中相关软件版本说明：\nhugo：v0.113.0 hugo-theme-stack：v3.16.0 参考 Quick Start | Hugo URL management | Hugo ","date":"2023-06-20T23:46:50+08:00","image":"https://ghjayce.github.io/asset/blog/hYbelawEIwhaejxWE2RNMjAyNDAyMjVfMTU1NTA2.png","permalink":"https://ghbjayce.github.io/p/static-site-generator/hugo/quick-start/","title":"hugo快速上手搭建一个静态博客"}]