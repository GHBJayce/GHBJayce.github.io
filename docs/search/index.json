[{"content":"目录 第一章 概论 第二章 线性表 第三章 栈、队列和数组 第四章 树和二叉树 第五章 图 第六章 查找 第七章 排序 阅读说明 本文涉及到的代码描述均为C语言。 概要 栈 概念 特征 用C语言描述 顺序栈 链栈 基本运算 初始化 栈空 栈满 进栈 出栈 取栈顶元素 应用 解决简单问题 队列 概念 特征 用C语言描述 顺序队列 循环队列 基本运算 初始化 队列空 队列满 入队列 出队列 取队列首元素 应用 解决简单问题 数组 一维和二维数组 逻辑结构 存储结构 存储位置计算 矩阵的压缩存储 特殊矩阵 对称矩阵 三角矩阵 上三角矩阵 下三角矩阵 稀疏矩阵 三元组表示法 简单的综合运用 栈 概念 栈Stack可以看作是特殊的线性表，特殊性在于基本运算是线性表运算的子集，是一种运算受限的线性表。而受限是指插入和删除运算限定在表的某一端进行。\n进栈：指插入运算。 出栈：指删除运算。 栈顶：允许进栈和出栈的一端。 栈底：栈顶的另一端。 空栈：不含任何数据元素的栈。 栈顶元素：处于栈顶位置的数据元素。 上溢：栈的容量已经满了，此时再进行进栈就会发生上溢。 下溢：空栈做出栈就会产生下溢，因为栈中没有任何数据元素。 栈是计算机科学中广泛使用的数据结构之一，例如：函数的嵌套调用和程序递归的处理都是用栈来实现的。\n特征 栈的修改原则是后进先出（Last In First Out），好比桌面上叠放着待清洗的碗碟，收拾以后的碗碟被放在栈顶，而在栈顶的碗碟会优先得到清洗。因此又称为后进先出线性表，简称后进先出表。\n生活中的例子 具有栈特征的生活场景：\n购物篮：顾客往购物篮放商品会放在栈顶，结账时从栈顶取出商品。 购物推车：顾客的购物车在结账完以后会被回收，叠放在栈顶，下一个顾客需要时会从栈顶取出。 射击：先装的子弹最后才被打出来，特殊子弹夹除外，例如左轮。 添饭：新加的米饭放在栈顶，栈顶的米饭先吃。 水杯加水：这个例子可能不太严谨，因为水流动的特性也有可能喝到非栈顶的水。 实现 栈的实现有两种方式：\n顺序栈：用一组连续的存储单元存放数据元素，通常用一个一维数组和一个记录栈顶位置的变量来实现顺序存储。 链栈：用带头结点的单链表实现，命名LS（linkStack），LS指向头结点，LS-\u0026gt;next指向栈顶结点，也是首结点，尾结点是栈底结点，通过各结点的指针连接组成栈。 栈的基本运算的功能描述：\n初始化InitStack(S)：构造一个空栈S。 判断栈空EmptyStack(S)：若为空栈返回1，否则返回0。 进栈Push(S, x)：将元素x插入栈S中，x成为栈顶元素。 出栈Pop(S)：删除栈顶元素。 取栈顶GetTop(S)：返回栈顶元素。 顺序栈 定义 顺序栈相关代码放在了GHBJayce/code-example - sequence stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 const int maxSize=10; // 顺序栈的容量 typedef struct sequenceStack { dataType data[maxSize]; // 存储栈中数据元素的数组 int top; // 指向栈顶位置 } seqStack; 初始化 1 2 3 4 5 6 seqStack init() { seqStack stack; stack.top = 0; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(seqStack *stack) { if (stack-\u0026gt;top == 0) { return 1; } return 0; } 栈满 1 2 3 4 5 6 7 int isFull(seqStack *stack) { if (stack-\u0026gt;top == maxSize-1) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 8 9 10 int push(seqStack *stack, dataType x) { if (isFull(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈已满\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top++; stack-\u0026gt;data[stack-\u0026gt;top] = x; return 1; } 出栈 1 2 3 4 5 6 7 8 9 int pop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } stack-\u0026gt;top--; return 1; } 取栈顶元素 1 2 3 4 5 6 7 8 dataType getTop(seqStack *stack) { if (isEmpty(stack)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;栈空\u0026#34;); exit(EXIT_FAILURE); } return stack-\u0026gt;data[stack-\u0026gt;top]; } 双栈 待补充\u0026hellip;\n链栈 定义 链栈相关代码放在了GHBJayce/code-example - link stack中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 typedef struct { int id; } dataType; typedef struct node { dataType data; struct node *next; } linkStack; 初始化 1 2 3 4 5 6 linkStack *init() { linkStack *stack = (linkStack *)malloc(sizeof(linkStack)); stack-\u0026gt;next = NULL; return stack; } 栈空 1 2 3 4 5 6 7 int isEmpty(linkStack *stack) { if (stack-\u0026gt;next == NULL) { return 1; } return 0; } 进栈 1 2 3 4 5 6 7 void push(linkStack *stack, dataType x) { linkStack *newNode = (linkStack *)malloc(sizeof(linkStack)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = stack-\u0026gt;next; stack-\u0026gt;next = newNode; } 出栈 1 2 3 4 5 6 7 8 9 10 int pop(linkStack *stack) { if (!isEmpty(stack)) { linkStack *removeNode = stack-\u0026gt;next; stack-\u0026gt;next = removeNode-\u0026gt;next; free(removeNode); return 1; } return 0; } 取栈顶元素 1 2 3 4 5 6 7 dataType *getTop(linkStack *stack) { if (isEmpty(stack)) { return NULL; } return \u0026amp;(stack-\u0026gt;next-\u0026gt;data); } 应用 1、将链栈中的结点进行逆置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 linkStack *reverse(linkStack *stack) { linkStack *newStack = init(); linkStack *stackNode = stack-\u0026gt;next; while (stackNode != NULL) { push(newStack, stackNode-\u0026gt;data); stackNode = stackNode-\u0026gt;next; } stackNode = stack-\u0026gt;next; while (!isEmpty(newStack)) { dataType *data = getTop(newStack); if (data != NULL) { stackNode-\u0026gt;data = *data; pop(newStack); } stackNode = stackNode-\u0026gt;next; } return stack; } 思路：\n遍历（逐个访问链表元素）要逆置的链栈（称为A链栈）的结点，将结点通过进栈的方式放到新的链栈（称为B链栈）中，此时B链表中结点的顺序已经与A链栈相反。 对B链栈进行逐一出栈，将出栈的结点按A链表的顺序对结点进行覆盖，完成逆置。 2、递归和栈，用递归实现阶乘函数\n待补充\u0026hellip;\n练习 1、设栈S的初始状态为空，若元素a、b、c、d、e、f依次进栈，得到的出栈序列是b、d、c、f、e、a，则栈S的容量至少是多少？\n答：至少3。\na进，b进，容量2。 b出，容量1。 c进，d进，容量3。 d出，c出，容量1。 e进，f进，容量3。 f出，e出，a出，容量0。 2、设一个链栈的输入序列为A、B、C，试写出所得到的所有可能得输出序列。\n答：共有5种可能的输出序列。\n输出ABC，A进，A出，B进，B出，C进，C出。 输出ACB，A进，A出，B进，C进，C出，B出。 输出BAC，A进，B进，B出，A出，C进，C出。 输出BCA，A进，B进，B出，C进，C出，A出。 输出CBA，A进，B进，C进，C出，B出，A出。 3、有一个整数序列，其输入顺序为20，30，90，-10，45，78，试利用栈将其输出序列改变为30，-10，45，90，78，20，试给出该整数序列进栈和出栈的操作步骤，用push(x)表示x进栈，pop(x)表示x出栈。\n答：\npush(20)，20 push(30)，20、30 pop(30)，20 push(90)，20、90 push(-10)，20、90、-10 pop(-10)，20、90 push(45)，20、90、45 pop(45)，20、90 pop(90)，20 push(78)，20、78 pop(78)，20 pop(20) 队列 概念 队列Queue，和栈一样可以看作是特殊的运动受限的线性表，受限在于插入和删除分别在两端进行。\n入队列：在队列尾部进行插入运算。 出队列：在队列首部进行删除运算。 队列首元素：队列首部第一个数据元素。 队列尾元素：队列尾部最后一个数据元素。 队列也是计算机科学中广泛使用的数据结构之一，例如：操作系统中进程调度、网络管理中的打印服务等都是用队列来实现的。\n特征 队列的修改原则是先进先出（First In First out），就像排队一样，但不允许插队，新加入的成员只能排在队列尾部，先加入的成员先离开队伍。\n生活中的例子 排队做核酸。 银行办业务。 排队上车/登机等。 实现 队列也有两种存储实现方式：\n顺序队列：由一个一维数组以及两个分别指向队列首部元素和队列尾部元素的指针。 链队列：由一个带头结点的单链表实现，头指针front指向链表的头结点，头结点的next指向队列首结点，尾指针rear指向队列的尾结点。 队列的基本运算的功能描述：\n队列初始化InitQueue(Q)：设置一个空队列Q。 判断队列为空EmptyQueue(Q)：若队列Q为空，返回1，否则返回0。 入队列EnQueue(Q, x)：将数据元素x从队尾一段插入队列。 出队列OutQueue(Q)：删除队列首元素。 取队列首元素GetHead(Q)：返回队列首元素的值。 顺序队列 定义 1 2 3 4 5 6 7 const int maxSize = 20; typedef struct sequenceQueue { dataType data[maxSize]; int front, rear; } seqQueue; seqQueue SQ; front表示队列首部，rear表示队列尾部，默认值均为0，也就是指向数组的0下标，该位置不存放数据元素。\n那么入队列的操作核心关键是：\n1 2 SQ.rear = SQ.rear+1; SQ.data[SQ.rear] = x; 出队列的操作：\n1 SQ.front = SQ.front+1; 这里出队列并不会去删除队列首元素，而是移动指向队列首部的指针。\n但是会存在一个问题，举一个例子：\na)为空队列，SQ.rear指向0的下标，SQ.front指向0的下标。 b)为20入队后，SQ.rear指向下标1，SQ.front为0。 c)为入队列30、40、50后的队列，SQ.rear为4，SQ.front为0。 d)为出队列20、30、40、50后的队列，SQ.rear为4，SQ.front为4。 e)为入队列60后，SQ.rear为5，SQ.front为4。 如果在e)的状态下，要做入队列的操作，SQ.rear将会超出数组下标的范围，也就是新元素没有办法入队列，但是1-4的位置明明是空的，数组的实际空间并没有沾满，这就是假溢出现象。\n另外还有一个问题是，队列空和队列满没有办法区分，就如a)和d)的情况。\n循环队列 为了解决顺序队列的假溢出问题，于是就有了循环队列，它将顺序队列数组的首尾进行相接，形成了一个环状，思路就是当入队列操作SQ.rear即将要超出数组下标范围的时候，将SQ.rear=0进行重置，也就是SQ.data[0]作为新的队列尾，这样新的元素就能够利用上空闲的空间，达到循环使用。\n至于没有办法区分队列空和队列满的解决方法有两种：\n为队列另设一个标志，也就是多加一个变量用作区分。 队列少用一个元素空间，当只剩最后一个空间时就认为队列满，也就是CQ.rear差一步就要追上CQ.front，如图b)，书中采用了该解决方法。 有点像MySQL redo log的checkpoint和write pos。\n定义 循环队列相关代码放在了GHBJayce/code-example - cycle queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 typedef struct cycleQueue { dataType data[maxSize]; int front, rear; } cycleQueue CQ; 按以上的解决思路，以下是几个操作的关键核心：\n入队列的操作：\n1 2 CQ.rear = (CQ.rear + 1) % maxSize; CQ.data[CQ.rear] = x; 出队列的操作：\n1 CQ.front = (CQ.front + 1) % maxSize; 队列满的条件：\n1 (CQ.rear + 1) % maxSize == CQ.front; 队列空的条件：\n1 CQ.rear == CQ.front; 初始化 1 2 3 4 5 void init(cycleQueue CQ) { CQ.front = 0; CQ.rear = 0; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(cycleQueue CQ) { if (CQ.front == CQ.rear) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 9 10 int push(cycleQueue CQ, dataType x) { if ((CQ.rear + 1) % maxSize == CQ.front) { printf(\u0026#34;\\s\\n\u0026#34;, \u0026#34;队列满\u0026#34;); exit(EXIT_FAILURE); } CQ.rear = CQ.rear + 1; CQ.data[CQ.rear] = x; return 1; } 出队列 1 2 3 4 5 6 7 8 int pop(cycleQueue CQ) { if (isEmpty(CQ)) { return 0; } CQ.front = (CQ.front + 1) % maxSize; return 1; } 取队列首元素 1 2 3 4 5 6 7 8 dataType getHead(cycleQueue *CQ) { dataType data; if (isEmpty(CQ)) { return data; } return CQ-\u0026gt;data[(CQ-\u0026gt;front + 1) % maxSize]; } 链队列 再重复一遍，链队列是一个带有头结点的单链表组成，队列首部的指针指向头结点，头指针指向首结点，队列尾部的指针指向尾结点，队列空的时候，队列首部和尾部的指针均指向头结点。\n链接的实现需要动态申请内存空间，所以不会出现队列满的情况。\n定义 链队列相关代码放在了GHBJayce/code-example - link queue中，感兴趣可以clone到本地查看运行结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int id; } dataType; typedef struct linkQueueNode { dataType data; struct linkQueueNode *next; } linkQueueNode; typedef struct linkQueue { linkQueueNode *front, *rear; } linkQueue; 初始化 1 2 3 4 5 6 7 8 9 10 linkQueue *init() { linkQueue *LQ = (linkQueue *)malloc(sizeof(linkQueue)); // 生成队列的头结点 linkQueueNode *node = (linkQueueNode *)malloc(sizeof(linkQueueNode)); LQ-\u0026gt;front = node; LQ-\u0026gt;rear = node; (LQ-\u0026gt;front)-\u0026gt;next = NULL; reutrn LQ; } 判断队列空 1 2 3 4 5 6 7 int isEmpty(linkQueue LQ) { if (LQ.rear == LQ.front) { return 1; } return 0; } 入队列 1 2 3 4 5 6 7 8 void push(linkQueue *LQ, dataType x) { linkQueueNode *newNode = (linkQueueNode *)malloc(sizeof(linkQueueNode)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = NULL; (LQ-\u0026gt;rear)-\u0026gt;next = newNode; LQ-\u0026gt;rear = newNode; } 出队列 1 2 3 4 5 6 7 8 9 10 11 12 13 void pop(linkQueue *LQ) { if (isEmpty(LQ)) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;队列空\u0026#34;); exit(EXIT_FAILURE); } linkQueueNode *deleteNode = LQ-\u0026gt;front-\u0026gt;next; LQ-\u0026gt;front-\u0026gt;next = deleteNode-\u0026gt;next; if (deleteNode-\u0026gt;next == NULL) { LQ-\u0026gt;rear = LQ-\u0026gt;front; } free(deleteNode); } 取队列首元素\n1 2 3 4 5 6 7 8 dataType *getHead(linkQueue *LQ) { if (isEmpty(LQ)) { return NULL; } linkQueueNode *node = LQ-\u0026gt;front-\u0026gt;next; return \u0026amp;(node-\u0026gt;data); } 应用 待补充\u0026hellip;\n数组 概念 数组array可以看成是线性表的一种推广，由一组相同类型的数据元素组成，并存储在一组连续的存储单元中。\n一维数组：又称向量。 二维数组：一维数组中的数据元素是一维数组，一般写成a[m][n]，可看作由m行n列组成的线性表。 三维数组：一维数组中的数据元素是二维数组。 n维数组：一维数组中数据元素为n-1维数组。 运算 通常只有两种基本运算：\n读：返回指定下标的数据元素。 写：修改指定下标的数据元素。 存储结构 一维数组数据元素的内存地址是连续的，而二维数组的数据元素有两种存储方法：\n以列序为主序的存储。 以行序为主序的存储，C语言编译数组采用的正是该方法。 存储结构演示和数组的逻辑结构插图.png（待补充\u0026hellip;）\n计算存储位置 有一个二维数组a[m][n]，每个数据元素占用k个存储单元大小，以行为主序，数组元素a[i][j]的存储位置是多少？要怎么计算？\nm：行数量。 n：列数量。 i：m行的下标。 j：n列的下标。 下标是从0开始，那么数据元素a[i][j]：\n该下标之前总共有：n * i + j + 1个数据元素，其中： 每行有n（列的数量）个元素。 在第i行，有i行元素，在第j列，有j+1个元素。 第一个元素a[0][0]与a[i][j]相差n * i + j + 1 - 1个位置。 a[i][j]的存储位置计算公式为： $$loc[i, j] = loc[0, 0] + (n * i + j) * k$$ 实战一下，例如：\n有一个二维数组a[10][20]，每个数据元素占用2个存储大小，数组的起始内存地址为2000，求：\na[5][10]的存储位置是多少？ 整理数据： m：10。 n：20。 i：5。 j：10。 k：2。 将数据套入公式：2000 + (20 * 5 + 10) * 2，存储位置最终为：2220。 a[8][19]呢？留给你来计算。 矩阵的压缩存储 待补充\u0026hellip;\n特殊矩阵 对称矩阵 三角矩阵 稀疏矩阵 综合运用 待补充\u0026hellip;\n","date":"2023-09-18T12:24:10+08:00","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter3/","title":"第三章 栈、队列和数组 - 《数据结构导论》笔记"},{"content":"概念 数列：按特定规律排列的一组数字的集合。 等差数列：指从第二项起，每一项与它的前一项的差都是同一个常数，这个常数称为公差。 例如：\n1、4、7、10、13、16、19 这是一组等差数列，每个数字之间相差3，其中：\n公差为：3。 首项（数列的第一个数字）是：1。 末项（数列的最后一个数字）是：19。 项数（数列的总数）：7。 数列的项（简称项）：数列中的一个个数字。 辨认 以下数列是否是等差数列？\n2、6、10、14、18、22，是 1、2、1、2、3、4、5、6，不是 1、2、4、8、16、32、64，不是 9、8、7、6、5、4、3、2，是 计算 求项的数 2、5、8、11、14、\u0026hellip;、?，求？第21项的数字是多少？\n如果项是最后一个也称为求末项\n分析：\n公差是3，找一下规律：\n5，序号2，和2之间差1个3。 8，序号3，和2之间差2个3（2+2个3）。 11，序号4，和2之间差3个3（2+3个3）。 14，序号5，和2之间差4个3（2+4个3）。 \u0026hellip; 根据规律问题变成了：序号21，2到底要加几个3？\n答案是：2 + (序号 - 1)个3，也就是2+20个3，所以第21项的数字是：62。\n因此得出公式：$$第n项的数 = 首项 + (n的序号 - 1) \\times 公差$$ 如果求第1个项的数字，也就是求首项，那么公式是： $$首项 = 末项 - (项数 - 1) ×公差$$\n求项的序号 5、8、11、14、17、20、\u0026hellip;、65是其中的第几项？\n如果项是最后一个也称为求项数\n直接套公式：$$某项的序号 = (某项的数 - 首项) \\div 公差 + 1$$ 公差是3，也就是：(65 - 5) / 3 + 1，65项的序号是：21。\n求和 2、4、6、8、10、12、14，这个数列各项加起来的和是多少？\n分析：\n倒序相加求和\n正序 S = 2 + 4 + 6 + 8 + 10 + 12 + 14 倒序 S = 14 + 12 + 10 + 8 + 6 + 4 + 2 2+14、4+12、6+10，正序和倒序的值加在一起都是相等的，于是可以写成：\n2S = (2 + 14) × 7 S = (2 + 14) × 7 ÷ 2 最终各项加起来的和是：56。\n得出公式，这个公式也称为高斯求和： $$和 = (首项 + 末项) \\times 项数 \\div 2$$\n参考 小学数学—计算之等差数列_哔哩哔哩_bilibili 小学奥数——高斯求和公式，简单问题的再思考 ","date":"2023-09-07T19:05:42+08:00","permalink":"https://ghbjayce.github.io/p/subject/math/sequence/arithmetic/","title":"什么是等差数列？"},{"content":"前言 一开始打算在手机上安装git，想到的是安装app，于是各种找，找到了有如：\nagit MGit \u0026hellip; 但是试过这些app以后发现要么BUG很多，要么根本不能正常使用，而且项目也很久没有更新了，只能另外再找别的app。\n机缘巧合下，让我找到了口袋git（com.aor.pocketgit）的app，正常使用了一段时间，最近再用的时候，频繁出现了Failed to fetch my_project.，没有办法fetch项目，也就没法继续使用了。\n开始我以为是账号密码的认证方式出了问题，于是我尝试换另一种认证方式——私钥，但是它的私钥是.ppk的格式，和ssh生成的密钥不太一样，一轮搜索以后：\n说是需要用到PuTTy的PuTTY Key Generator来对ssh的密码进行转换处理得到.ppk的文件。 按照步骤转换好以后再放到app上，显示了感叹号，感觉不太对劲，进行fetch操作时果然，提示Invalid Private Key. 好家伙，ppk的方式也不行，也不想再试了，那为什么用的好好的账密认证方式出了问题呢？\n我估计是最近github强制使用2FA的关系，登录账号需要经过两步验证，app应该是没有做这个异常处理，而且在app内也没有办法升级。\n于是我放弃了这个app，换了另一条路。\n安装git环境 在逛Stack Overflow时发现了Termux这个app，它是在Android上运行的一个终端软件，也就是直接敲命令在手机上安装git环境。\n打开app，执行以下命令安装：\n1 2 $ apt update $ apt install git 安装完以后，熟悉的操作方式就回来了：\n1 2 $ git --version git version 2.42.0 剩下的就不用多说了，ssh-keygen走一波，下面贴一下我遇到的问题和解决过程。\n操作过程 第一时间就是进入到项目目录，先看看自己在哪个目录：\n1 2 3 4 5 $ pwd /data/data/com.termux/files/home # 然后查看根目录都有些什么 $ ls / ls: cannot open directory \u0026#39;/\u0026#39;: Permission denied 竟然没权限，whoami一看，哦，看来还是root用习惯了，普通用户只拥有/data/data/com.termux目录下的权限，而/data/data之前的目录都没有权限。\n那怎么搞？没有权限我怎么知道我的项目在哪个路径下？？\n熟悉安卓开发的同学或者搞过机的同学就知道，我们在文件管理看到的根目录，是在/storage/emulated/0/下，我也是在折腾了一番以后才得知。\n这么长的路径，不行，我得设置成全局变量才行\n1 2 3 4 5 6 7 8 # 习惯用vim去编辑，其实还有别的方式 $ vim ~/.bash_profile The program vim is not installed. Install it by executing: pkg install vim or pkg install vim-gtk, after running pkg in x11-repo or pkg install vim-python 这里我执行了pkg install vim，然后你懂的。\n然后cd进项目路径，查看配置信息：\n1 2 3 $ git config --list fatal: detected dubious ownership in repository at \u0026#39;/xxx/xxx\u0026#39; To add an exception for this directory, call: git config --global --add safe.directory /xxx/xxx 跟着提示将我们的项目路径设置成安全目录就行。\n1 2 3 $ ssh-keygen -t rsa -C \u0026#34;your@email.com\u0026#34; The program ssh-keygen is not installed. Install it by executing: pkg install openssh 跟着提示执行pkg install openssh，然后遇到连续四个CANNOT LINK EXECUTABLE \u0026quot;ssh-keygen\u0026quot;: library \u0026quot;libcrypto.so.3\u0026quot; not found。\n这里需要执行pkg install openssl安装相关依赖，再重新执行安装命令就可以了。\n1 2 $ git fetch origin CANNOT LINK EXECUTABLE \u0026#34;/data/data/com.termux/files/usr/libexec/git-core/git-remote-https\u0026#34;: library \u0026#34;libssl.so.1.1\u0026#34; not found 解决：\n1 2 3 4 5 6 7 $ find /data/data/com.termux/files -name \u0026#39;libssl.so.*\u0026#39; /data/data/com.termux/files/usr/lib/openssl-1.1/libssl.so.1.1 /data/data/com.termux/files/usr/lib/libssl.so.3 # 如果没有的话，先执行 pkg install openssl1.1-tool # 添加环境变量 echo \u0026#34;export LD_LIBRARY_PATH=/data/data/com.termux/files/usr/lib/openssl-1.1\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile \u0026amp;\u0026amp; source ~/.bash_profile 新的问题：\n1 2 3 4 $ git fetch origin fatal unable to access \u0026#39;https://github.com/xxx.git\u0026#39;: HTTP/2 stream 1 was not closed cleanly before end of the underlying stream # 解决： $ git config --global http.version HTTP/1.1 参考 How to use Git on Android? - Stack Overflow 生成Git ssh公钥和私钥（ppk）文件 Termux-setup-storage - Termux Wiki library “libssl.so.1.1“ not found 安卓神器termux使用命令时的报错。_4ustn1ne的博客-CSDN博客 ","date":"2023-08-30T13:26:26+08:00","permalink":"https://ghbjayce.github.io/p/system/android/env/install-git/","title":"在android上安装git环境"},{"content":"目录 第一章 概论 第二章 线性表 第三章 栈、队列和数组 第四章 树和二叉树 第五章 图 第六章 查找 第七章 排序 概要 线性表 概念 特征 基本运算的功能描述 初始化 求表长 读取元素 定位 插入 删除 线性表的顺序存储结构——顺序表 概念 用C语言描述 运算实现的关键步骤和算法 容量 表长 插入 删除 定位 应用 实现简单算法 算法实现的分析 线性表的链式存储结构——单链表 特点和结构 基本概念 头指针 头结点 首结点 尾结点 空链表 用C语言描述 运算实现的关键步骤和算法 插入 删除 定位 综合应用 设计算法解决应用问题 顺序表和链表的优缺点、适用场景 循环链表和双向循环链表 特点和结构 用C语言描述 基本运算 插入 删除 线性表 概念 线性表Linear List是一种线性结构，它是由n（n ≥ 0）个数据元素组成的有穷序列，其中：\n数据元素又称为结点。 这里的n代表线性表的总结点个数，又称为表长。 当表长为0时，也就是线性表没有任何结点，称为空表，用 () 或 Ø 表示。 线性表通常表示成：(A1, A2, A3, ..., An)，其中： A1称为起始结点。 An称为终端结点。 A1是A2的直接前驱，A3是A2的直接后继，其他结点同理。 特征 线性表中结点之间具有一对一的关系。 非空表的情况下： 除了起始结点没有直接前驱（例：A1），其他的结点有且仅有一个直接前驱（例：A2、A3等）。 除了终端结点没有直接后继（例：An），其他的结点有且仅有一个直接后继（例：A1、A2等）。 基本运算的功能描述 以下的no指的是序号，文中所有提到的“位置”都是指序号。\n避免用i命名是怕和数组的下标混在一起，数组的下标是从0开始，而序号是从1开始。\n初始化Initiate(L)：建立一个空表L=()，L不包含任何结点。 求表长Length(L)：返回线性表L的长度，以下简称表L。 读取元素Get(L, no)：返回表L的第no个结点，当no超出Length(L) ≥ no ≥ 1范围，返回一特殊值。 定位Locate(L, x)：返回表L中第一个结点的值等于x值的序号，如果找不到则返回0。 插入Insert(L, x, no) ：两个步骤。 在表L的第no个结点之前插入一个新结点x，no的合法范围：Length(L) + 1 ≥ no ≥ 1。 表长度加1。 删除Delete(L, no)：两个步骤。 删除表L的第no个结点，no的合法范围：Length(L) ≥ no ≥ 1。 表长度减1。 顺序表 概念 顺序存储：将结点依次存放在计算机内存中一组连续的存储单元中，逻辑结构中相邻的结点它的存储位置也相邻。 顺序表：用顺序存储实现的线性表，一般使用数组来表示顺序表。 用C语言描述 假设线性表的数据元素的类型为DataType，顺序表的结构定义如下：\n1 2 3 4 5 6 7 const int Maxsize = 100; // 预先定义一个足够大的常数 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 顺序表的实际长度 } SeqList; // 顺序表类型名为SeqList SeqList L; // 定义L为一个顺序表 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const int Maxsize = 7; // 预先定义数组大小 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct { DataType data[Maxsize]; // 存放数据的数组 int length; // 线性表的实际长度 } SeqList; // 顺序表的类型 SeqList student; // student是顺序表的名称 运算 以下相关运算的代码已经整理好，放在了GHBJayce/code-example - sequence list中，感兴趣的话可以clone到本地查看运行结果。\n插入 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SeqList insertSeqList(SeqList L, DataType x, int no) { if (L.length \u0026gt;= Maxsize) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;表已满\u0026#34;); exit(EXIT_FAILURE); } // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 2 if (no \u0026lt; 1 || no \u0026gt; L.length + 1) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;插入位置不正确\u0026#34;); exit(EXIT_FAILURE); } for (int i = L.length; i \u0026gt;= no; i--) { L.data[i] = L.data[i - 1]; } L.data[no - 1] = x; L.length++; return L; } 步骤：\n检查插入位置是否合法。 表容量，表满了以后不能再插入。 插入位置： 不能插入序号no = 0及之前的位置，no = 1的位置可以插入。 要插入的位置，它前面的位置不能是空的，也就是不能断开插入。 例：插入第5个位置，第4个位置是空的。 为插入位置腾出空位，从最后一个结点开始从后往前循环，将结点往后移一个位置，直到插入位置结束。 插入新的结点x，也就是序号no的位置，对应下标为：no-1。 表长度加一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n}{2}$。 插入算法中，元素的移动次数不仅与顺序表的长度n有关，还和插入的no位置有关：\n当插入位置是n+1时，移动次数为0。 当插入位置是n时，移动次数为1，这个称为首项（从存在的元素中选取，它也可以是尾项）。 当插入位置是n-1时，移动次数为2。 当插入位置是n-2时，移动次数为3。 \u0026hellip; 当插入位置是1时，移动次数为n，这个称为末项。 根据移动次数变化的规律可以看出：\n移动次数的计算方式为：n - no + 1。 可插入的位置有：n + 1个。 这是个等差数列。 使用高斯求和公式可以得出总的移动次数为：$\\frac{(n + 1) \\times n}{2}$。 因此平均移动次数：$\\frac{总移动次数}{可插入位置}$也就是$\\frac{\\frac{(n + 1) \\times n}{2}}{n + 1}$约为$\\frac{n}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n删除 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 SeqList deleteSeqList(SeqList L, int no) { // 等同于：no \u0026lt;= 0 || no \u0026gt;= L.length + 1 if (no \u0026lt; 1 || no \u0026gt; L.length) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;非法位置\u0026#34;); exit(EXIT_FAILURE); } for (int i = no; i \u0026lt; L.length; i++) { L.data[i-1] = L.data[i]; } L.length--; return L; } 步骤：\n检查删除位置是否合法，不能是0及之前的位置，也不能是超出表长之后的位置。 覆盖结点，从删除位置开始，后一个结点移动到前一个位置，直到最后一个结点结束，即表示删除。 表长度减一。 分析：\n算法复杂度：O(n)。 平均移动次数：$\\frac{n-1}{2}$。 跟插入算法一样：\n当删除位置是n时，移动次数为0。 当删除位置是n-1时，移动次数为1。 当删除位置是n-2时，移动次数为2。 \u0026hellip; 当删除位置是1时，移动次数为n-1。 根据规律得出：\n移动次数的计算方式：n - no。 可删除的位置有：n个。 同样是等差数列。 使用高斯求和公式得出总的移动次数：$\\frac{(0 + n - 1) \\times n}{2}$。 平均移动次数：$\\frac{总移动次数}{可删除的位置}$也就是$\\frac{\\frac{(0 + n - 1) \\times n}{2}}{n}$约为$\\frac{n-1}{2}$。 如果我有理解错平均移动次数，请大佬随时斧正，联系我。\n定位 算法：\n1 2 3 4 5 6 7 8 9 10 11 12 int locateSeqList(SeqList L, DataType x) { int i = 0; // 为了简化运算，这里只比对DataType里的id while ((i \u0026lt; L.length) \u0026amp;\u0026amp; (L.data[i].id != x.id)) { i++; } if (i \u0026lt; L.length) { return i + 1; } return 0; } 步骤：\n初始化一个下标值：0。 从头到尾逐个比对，数组中的结点是否与结点x相等： 不相等则继续循环。 相等则表示已经找到，停止循环。 返回查找结果。 表长 只需要返回L.length即可\n链表 概念 链表的结点：由数据域（数据元素）和指针域或者叫链域（表示数据元素之间的逻辑关系）组成。 数据域：相当于火车厢。 指针域：相当于连接火车厢的车钩。 链式存储：各个结点在内存中的存储位置并不一定连续，逻辑结构中相邻的结点其存储位置不一定相邻。 链表：用链式存储实现的线性表，所有结点通过指针链接形成链表Link List，结点之间可以重新链接。 单链表：每个结点由一个数据元素和一个指向下一个结点（后继结点）的next指针构成。 循环链表：单链表的基础上，尾结点的指针指向首结点。 双向循环链表：循环链表的基础上，每个结点增加一个指向上一个结点（前驱结点）的prio指针。 组成介绍： head：头指针变量，有两个作用： 它的值指向链表的第一个结点。 也可以用来命名链表，例如下图链表称为：表head、head表。 首结点：链表中第一个数据元素结点。 尾结点：也称终端结点，指链表中最后一个数据元素结点。 空指针：尾结点的指针域的值为NULL。 空链表：head等于NULL，表示链表无任何结点。 头结点：为了方便运算，在首结点之前增加一个相同类型的结点，如图C)。 表结点：除了头结点以后的结点。 用C语言描述 1 2 3 4 5 6 7 8 typedef struct node { DataType data; struct node *next; } Node, *LinkList; // Node，*LinkList都是结构体的别名，其中 // Node是指向struct node类型的别名 // *LinkList是指向Node类型的指针的别名 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct { int num; // 学号 char name[8]; // 姓名 int age; // 年龄 } DataType; // 定义结点的类型 typedef struct node { DataType data; // 数据域 struct node * next; // 指针域 } Node, *LinkList; // Node是链表结点的类型 LinkList head; // 定义一个全局变量，head是链表的名称 运算 以下相关运算的代码已经整理好，放在了GHBJayce/code-example - link list中，感兴趣的话可以clone到本地查看运行结果。\n初始化 1 2 3 4 5 6 7 LinkList initLinkList() // 建立一个空的单链表 { LinkList head; // 定义局部变量，头指针 head = malloc(sizeof(Node)); // 动态构建一结点，它是头结点 head-\u0026gt;next = NULL; return head; } 步骤：\n基于LinkList结构，构建一个名为head的单链表。 通过给head分配内存、设置属性，此时head是一个头结点，next指针为NULL，表示链表为空。 返回这个链表的头结点。 求表长 1 2 3 4 5 6 7 8 9 10 11 12 int lengthLinkList(LinkList head) // 求单链表head的长度 { // 声明一个指向Node对象的名为point的指针变量，它指向head的头结点 Node *point = head; int count = 0; while (point-\u0026gt;next != NULL) { point = point-\u0026gt;next count++; } return count; } 步骤：\n指向head表的头结点。 初始化count计数。 从head头结点开始，检查头结点的下一个结点，也就是首结点： 结点不为空，此时point变成首结点，计数+1，依次往后检查下一个结点是否为NULL。 结点为NULL结束循环。 返回表长。 读取元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Node *getLinkList(LinkList head, int no) // 读取序号为第no个结点，读到返回结点 { Node *point; point = head-\u0026gt;next; int position = 1; while (point != NULL \u0026amp;\u0026amp; position \u0026lt; no) { point = point-\u0026gt;next; position++; } if (position == no) { return point; } return NULL; } 步骤：\n声明point指针变量，指向head表的首结点。 初始化position，也就是从第一个结点（位置1）开始查找。 检查point结点不能是空的，并且position要小于查找的no。 符合条件，表示还没找到，此时point变成下一个结点，position+1，重复步骤3。 不符合条件，结束循环，分为两种情况，可能遍历完整个链表都没找到或者提前找到了。 判断position是否等于no序号： 相等，表示已经找到，返回point结点。 不相等，表示没有找到，返回NULL值。 定位 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int locateLinkList(LinkList head, DataType x) // 在head表中找到第一个符合x结点的序号 { Node *locateNode; locateNode = head-\u0026gt;next; int no = 1; while (locateNode != NULL \u0026amp;\u0026amp; locateNode-\u0026gt;data != x) { locateNode = locateNode-\u0026gt;next; no++; } if (locateNode == x) { return no; } return 0; } 关键点：\n从首结点开始，当前结点不为空并且不等于要查找的值则继续检查下一个结点： 如果提前找到结点locateNode，循环结束。 如果遍历完链表依然没找到，locateNode等于尾结点，循环结束。 比对locateNode和x： 相等，就是找到了，返回locateNode所在的序号。 不相等，也就是没找到，返回0。 插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList insertLinkList(LinkList head, DataType x, int no) { Node *queryNode, *newNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL) { printf(\u0026#34;插入位置有误\u0026#34;); exit(EXIT_FAILURE); } newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = x; newNode-\u0026gt;next = queryNode-\u0026gt;next; queryNode-\u0026gt;next = newNode; return head; } 关键点：\n找到要插入位置的前驱结点query： 生成一个新的结点newNode，按照Node结构分配内存。 newNode的next要指向query的next，数据域赋值为x也别忘了。 query的next指向newNode。 注意如果插入的位置为1，要做处理，避免取一个非法的前驱结点。 要对查找插入位置的结果做处理。 1.2和1.3的步骤不能调换，必须严格执行，不然会丢失query的next结点。 删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList deleteLinkList(LinkList head, int no) { Node *deleteNode, *queryNode; if (no == 1) { queryNode = head; } else { queryNode = getLinkList(head, no-1); } if (queryNode == NULL || queryNode-\u0026gt;next == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;删除的位置错误\u0026#34;); exit(EXIT_FAILURE); } deleteNode = queryNode-\u0026gt;next; queryNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); return head; } 关键点：\n和插入有点类似，也得先找到要查删除位置的前驱结点query，当然也要注意非法前驱的处理。 要对查找删除位置的结果做处理。 要删除的结点放到临时变量存起来，目的用于free释放内存空间。 把前驱结点query的next指向删除结点的next即可，如果删除结点是尾结点，那么query的next就是NULL。 创建 为了方便后续算法演示，这里用一个数组来构建单链表，再简化一下DataType的属性：\n1 2 3 4 5 6 int nums[6] = {4, 7, 2, 5, 2, 4}; typedef struct { int age; } DataType; 结合以上已实现的算法initLinkList()和insertLinkList()，实现一个创建链表的算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 LinkList createLinkListByEach(int *arr, int size) { LinkList point = initLinkList(); for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; insertLinkList(point, item, i+1); } return point; } // 调用 // 为了方便展示直接写6，size自动计算：sizeof(nums) / sizeof(nums[0]) createLinkListByEach(nums, 6); 缺点：每次插入结点都要遍历一次链表。\n尾插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 LinkList createLinkListByTailInsert(int *arr, int size) { LinkList head; Node *lastNode, *newNode; head = malloc(sizeof(Node)); lastNode = head; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; lastNode-\u0026gt;next = newNode; lastNode = newNode; } lastNode-\u0026gt;next = NULL; return head; } 优点：每次插入新结点都能从尾结点进行而不需要每次遍历整个链表。\n头插法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LinkList createLinkListByHeadInsert(int *arr, int size) { LinkList head; Node *newNode; head = malloc(sizeof(Node)); head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; size; i++) { DataType item; item.age = arr[i]; newNode = malloc(sizeof(Node)); newNode-\u0026gt;data = item; newNode-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = newNode; } return head; } 与尾插法算法一样，只是插入新结点是从头结点进行，最终链表的顺序与尾插法相反。\n删除重复结点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 LinkList removeRepeatLinkList(LinkList head) { Node *searchNode; // 要查找的结点 Node *checkNode; // 要检查（比对）的结点 Node *deleteNode; // 要删除的结点 searchNode = head-\u0026gt;next; // 从首结点开始 while (searchNode != NULL) { // 关键，从首结点开始，循环检查当前结点的下一个结点 checkNode = searchNode; while(checkNode-\u0026gt;next != NULL) { if (searchNode-\u0026gt;data.age == checkNode-\u0026gt;next-\u0026gt;data.age) { deleteNode = checkNode-\u0026gt;next; checkNode-\u0026gt;next = deleteNode-\u0026gt;next; free(deleteNode); } else { checkNode = checkNode-\u0026gt;next; } } searchNode = searchNode-\u0026gt;next; } return head; } 关键点：\n从首结点开始遍历，取它的值与下一个结点的值进行比较，找到相等的值进行删除。 checkNode=searchNode; while(checkNode-\u0026gt;next != NULL)是关键之一。 其他链表 循环链表 带尾结点访问首结点的表示方式：rear-\u0026gt;next-\u0026gt;next，运算与单链表类似，不再赘述。\n双向循环链表 用类C语言来描述：\n1 2 3 4 5 6 7 struct dbnode { DataType data; struct dbnode *prior, *next; } typedef struct dbnode *dbpointer; typedef dbpointer DLinkList; 双向循环链表和单链表的运算差不多，主要提一下删除和插入运算的差异。\n删除算法的关键点：\n1 2 3 removeNode-\u0026gt;prior-\u0026gt;next = removeNode-\u0026gt;next; removeNode-\u0026gt;next-\u0026gt;prior = removeNode-\u0026gt;prior; free(removeNode); 第1行和第2行代码顺序颠倒也可以，不影响最终效果。\n插入算法的关键点：\n1 2 3 4 newNode-\u0026gt;prior = query; newNode-\u0026gt;next = query-\u0026gt;next; query-\u0026gt;next-\u0026gt;prior = newNode; query-\u0026gt;next = newNode; 注意query是指插入位置的前驱结点，以及这些语句的顺序。\n先接好新结点的prior和next指针的指向。 再将插入位置结点的prior指针指向新结点。 最后将query结点的next指针指向新结点。 顺序表和链表的比较 异同 存储方式： 顺序表： 使用连续的内存空间来存储结点。 需要预先分配存储空间，存储结点个数有上限。 链表： 结点由数据元素和指针组成，指针指向下一个结点，存储在内存空间连不连续都可以。 不需要预先分配存储空间，存储结点个数没有上限。 访问效率： 顺序表： 能根据索引快速定位结点，时间复杂度O(1)。 读取结点支持随机访问。 链表： 只能通过遍历链表，从头到尾逐个遍历查找目标结点，时间复杂度O(n)。 读取结点不支持随机访问。 运算（插入和删除）： 顺序表： 插入和删除需要移动后续的结点，以保证结点之间的连续性。 插入和删除操作之前需要查找定位，时间复杂度O(n)。 链表： 插入和删除只需要修改结点之间指针的指向关系，不需要移动结点。 跟顺序表一样需要查找定位，时间复杂度也是O(n)。 优缺点 顺序表： 优点： 随机访问效率高。 缺点： 插入和删除的操作代价高。 需要预先分配一块连续的内存空间。 存储结点个数有上限。 链表： 优点： 插入和删除的操作代价低。 对内存空间控制动态且灵活。 存储结点个数没有上限（取决于可用内存空间）。 缺点： 不支持随机访问。 相对要占用多一些内存空间来存放指针域。 适合场景 根据上面的优缺点可得知：\n顺序表：更适合读多写（插入和删除）少的场景。 链表：更适合写多读少的场景。 综合应用 待补充\u0026hellip;\n","date":"2023-08-29T14:46:12+08:00","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter2/","title":"第二章 线性表 - 《数据结构导论》笔记"},{"content":"目录 第一章 概论 第二章 线性表 第三章 栈、队列和数组 第四章 树和二叉树 第五章 图 第六章 查找 第七章 排序 阅读说明 本书 书名：《数据结构导论》 出版：外语教学与研究出版社 版本：2012年版 全书以类C语言来描述相关内容，例如：存储结构、算法等。 本文涉及知识点 数学知识 乘法分配率 对数 等差数列、高斯求和 概要 数据、数据元素和数据项 基本概念 三者的关系 数据的逻辑结构和存储结构 四种基本的逻辑结构和特点 集合 线性结构 树形结构 图结构 两种基本的存储结构 顺序存储 链式存储 逻辑结构与存储结构的关系 运算与逻辑结构的关系 算法分析 描述方法 评价因素 时间复杂度的分析方法 空间复杂度的分析方法 数据、数据元素和数据项 概念和联系 数据项：在数据表中指的是一个个的字段，又称字段或域，数据的最小标识单位。 数据元素：在数据表中相当于一行记录，又称结点，由若干个数据项组成。 数据：被计算机处理、存储的对象，由若干个数据元素组成。 数据的逻辑结构和存储结构 概念 数据结构：包含数据的逻辑结构、存储结构和基本运算。 逻辑结构：整个数据元素之间的逻辑关系。 逻辑关系：指单个数据元素之间的关联方式或邻接关系，也就是单个数据元素之间的组织形式。 存储结构：也称物理结构，数据的逻辑结构在计算机中的实现称为数据的存储结构。 简单点说：为了保存数据的逻辑结构到计算机中而实现的存储结构。 逻辑结构 四类基本的逻辑结构：\n集合：任意两个结点之间都没有邻接关系，组织形式松散，就像抽奖箱里的乒乓球。 结点之间除了同属一个集合，并没有别的关系。 线性结构：结点之间一个个依次相邻接排列，形成一条“链”，就像一条绳子上的多个绳结。 结点之间是一对一的相互关系。 树形结构：上层结点有多个下层结点，下层结点只有一个上层结点，具有分支、层次特性，就像一颗树。 结点之间是一对多的相互关系。 图结构：最为复杂的结构，任意两个结点都可以相邻接，就像地铁线路图、人与人之间的社交网络。 结点之间是多对多的相互关系。 存储结构 存储结构一般包括两个部分：\n需要存储的数据元素 结点之间的逻辑关系 实现结点之间的逻辑关系的存储结构，一般有四种形式，主要掌握顺序存储和链式存储：\n顺序存储：所有结点存储在一个连续的存储区域里，利用结点在存储器中的相对位置，来表示结点之间的逻辑关系。 链式存储：除了存储结点本身，还需要一个指针，指针指向有逻辑关系的结点，也就是利用指针表示结点之间的逻辑关系。 索引存储 散列存储 如何描述 怎么描述存储结构是哪种类型？哪种实现形式呢？分为两种方式：\n机器级：即存储结构在计算机存储器里的表示形式，以内存地址的方式。 语言级：即用程序设计语言中的类型说明、变量说明，例如，数据类型：数组、结构体和指针等。 运算 概念 运算是指在逻辑结构上施加的操作，也就是对逻辑结构的加工。\n这些运算操作包括：\n建立 查找 读取 插入 删除 等\u0026hellip; 算法分析 评价算法 评价算法好坏的因素分为几个方面：\n正确性：能正确地实现预定的功能，满足具体问题的需要。 易读性：易于阅读、理解和交流，便于调试、修改和扩充。 健壮性：能处理不同的输入环境，即使是非法数据，也不会产生预料不到的运行结果。 时空性：指算法的时间性能（所需计算量）和空间性能（所需存储量）。 时间复杂度 计算量 来算一算函数执行了几次\n例子A：\n1 2 3 4 5 int func1(void) { printf(\u0026#34;hello GHBJayce\u0026#34;); return 0; } 共执行了2次，printf1次 + return1次\n例子B：\n1 2 3 4 5 6 7 int func2(int n) { for (int i = 0; i \u0026lt; n; ++i) { printf(\u0026#34;hello GHBJayce\u0026#34;); } return 0; } 共执行了3n + 3次\n分析过程：\nint i = 0，由始至终仅会执行1次。 i \u0026lt; n，执行n + 1次。 ++i，执行n次。 printf，执行n次。 return，执行1次。 要估算某段代码的执行次数，可以用T(n)来表示：\nT：某段代码的总执行次数。 n：输入数据的规模大小或者数量。 也就是一个算法的计算量是问题规模n的函数，代入以上例子来表示：\n例子A：T(n) = 2 例子B：T(n) = 3n + 3 转换 得出代码的执行次数估算值后，需要转换成时间复杂度的表示方式，以下是转换规则：\n如果T(n)是常数的话，时间复杂度直接估算为 1。 如果T(n)不是常数的话，例如：常数 × n + 常数 仅保留最高次项，也就是常数 × n 常数化为1，也就是1 × n，这里的系数可以直接省略。 因此时间复杂度估算为：n。 表达方式还不完整，需要加上大O表示法，也称渐进表示法，例如：O(时间复杂度估算值)\n结合以上例子，那么时间复杂度表示为：\n例子A：O(1) 例子B：O(n) 如果代码量比较多或者函数调用比较多的情况下这样估算会相当麻烦，所以下面是简化估算过程：\n例子C：\n1 2 3 4 5 6 7 8 void func3(int n) { for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { printf(\u0026#34;hello GHBJayce\u0026#34;); } } } 分析过程：\n里面的for循环的时间复杂度：n + 1 这里for的时间复杂度：n for里面的语句的时间复杂度：1 外面的for循环的时间复杂度：(n + 1) × n，也就是(n × n) + (n × 1)，即n² + n 最终时间复杂度为：O(n²)\n例子D：\n1 2 3 4 5 6 7 8 void func(int n) { for (int i = 0; i \u0026lt; n; ++1) { for (int j = i; j \u0026lt; n; ++j) { printf(\u0026#34;hello GHBJayce\u0026#34;); } } } 最终时间复杂度为：O(n²)，待补充\u0026hellip;\n例子E：\n1 2 3 4 5 6 void func(int n) { for (int i = 1; i \u0026lt; n; i *=2) { printf(\u0026#34;hello GHBJayce\u0026#34;); } } 最终时间复杂度为：O(logn)，待补充\u0026hellip;\n性能对比 常数阶：O(1) 对数阶：O(log2n)，log的底数可以省略不写，也就是：O(logn)，下面也是一样 线性阶：O(n) 线性对数阶：O(nlogn) 多项式阶：O(nc)，C为大于1的正整数，下面也是一样 平方阶：O(n²) 立方阶：O(n3) K次方阶：O(nk) 指数阶：O(Cn)，常见是O(2n) 以上时间复杂度，复杂程度和耗时从上往下依次增加，即越往下时间复杂度越高，所需耗时越多。\n通常认为，具有指数阶的算法是不可计算的，而阶数低于平方阶的算法是高效率的。\n另外，时间复杂度的性能还会受到输入数据的变化而有所影响，基于相同输入数据量的不同输入数据，分为：\n最坏时间复杂度：算法时间用量的最大值。 平均时间复杂度：算法时间用量的平均值。 空间复杂度 一个算法的空间复杂度定义为该算法所耗费的存储空间，它也是问题规模n的函数，记为： $$S(n)=O(g(n))$$ 其中，g(n)为问题规模n的某个函数。一个算法在执行期间所需的存储空间量分为：\n程序代码所占用的空间，对不同算法来说也不会有数量级的差别。 输入数据所占用的空间，由问题规模决定的，不随算法的不同而改变。 辅助变量所占用的空间，也称附加存储空间，它所占用的空间会受到问题规模和不同的算法所影响。 来个例子实践一下，假设，n=100。\n例子A：\n1 2 3 4 5 6 7 8 9 void f1(int a[], int n) { int i, temp; for (i = 0; i \u0026lt;= n/2; i++) { temp = a[i]; a[i] = a[n-1-i]; a[n-1-i] = temp; } } f1所需要的辅助变量为2个整型变量i和temp，与问题的规模无关，空间复杂度为：O(1)。\n例子B：\n1 2 3 4 5 6 7 8 void f2(int a[], int n) { int i, b[100];//随n的大小 for (i = 0; i \u0026lt;= n-1; i++) b[i] = a[n-1-1]; for (i = 0; i \u0026lt;= n-1; i++) a[i] = b[i]; } f2所需要的辅助变量为1个整型变量i和随n大小的数组b，b与问题的规模有关，空间复杂度为：O(n)。\n如果是递归调用呢？\n待补充\u0026hellip;\n参考 指数和对数 小学生也能看懂的时间复杂度 小学速算技巧15讲：简便计算，认知乘法分配率 ","date":"2023-08-20T16:36:20+08:00","permalink":"https://ghbjayce.github.io/p/book/080901/02142/chapter1/","title":"第一章 概论 - 《数据结构导论》笔记"},{"content":"前言 开头废话有点多，点我进入正题\n为什么想要搭建一个博客？ 说起来有很多方面的因素，最重要的目的是希望能够留下一些技术积累和记录可以给别人看，同时提升一下写作的能力，毕竟与平时记笔记的方式完全不同。\n虽然也没有什么人看🤷\n其实在此之前也有写过博客，比如早期使用heroku + php搭建的个人博客，因为需要不断开发完善功能，加上后来也不免费了，索性不折腾直接上博客网站上写博客，如：CSDN、Segmentfault等。\n但这些平台使用下来以后也发现了一些问题，总的来说就是不适合自己的使用，写文章的过程也不够简洁直接，不够纯粹。\n我理想中的博客是什么？ 专注于markdown的编写 支持全文检索 具有标签功能 能够归档文章 免费 支持永久存储 为什么选择了hugo？ 查阅资料得知，静态站点生成器有三种提的比较多，分别是：\njekyll，基于Ruby语言编写 hexo，基于Node.js编写 hugo，基于Go语言编写 之所以选择hugo，它是当中编译速度最快、文档相对友好、star数量还多，正好无意间找到Hugo Themes的主题，很好的契合了需求，就决定是它了。\n阅读前提 本文默认你已经掌握了以下的几个点：\n了解github pages并且会配置 熟悉使用git 通过该文章可以快速上手使用hugo，所以有一些内容不会详细展开。\n快速入门 安装Hugo 这里我用的是Mac系统，所以采用Homebrew的方式进行安装，其他安装方式自行查阅。\n1 2 brew install hugo hugo version 创建项目 1 2 3 hugo new site your-project-name cd your-project-name git init 由于我已经有git项目ghbjayce.github.io，里面没有任何东西，所以这里我使用了hugo new site GHBJayce --force，既不影响hugo的生成又不影响git的项目。\n执行完以后，你会得到以下的目录结构：\n1 2 3 4 5 6 7 8 9 ├── archetypes │ └── default.md ├── assets ├── content ├── data ├── hugo.toml ├── layouts ├── static └── themes 安装主题 由于新建的项目没有默认主题，我们从主题库把挑好的主题下载下来。\n1 2 3 4 5 6 git clone git@github.com:CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack cp -r ./themes/hugo-theme-stack/exampleSite/content/* ./content cp ./themes/hugo-theme-stack/exampleSite/config.yaml ./hugo.yaml rm -f ./hugo.toml # 以下是示例主题需要操作的命令，避免没有翻墙的情况下启动不了项目 rm -rf ./content/post/rich-content 站点配置文件为hugo.toml，支持三种后缀的格式：toml、yaml、json，这里我选择用yaml\nHello World 生成一篇文章。\n1 2 # 对应的生成位置：/your-project-name/content/post/first-post.md hugo new post/first-post.md 打开它写点内容。\n1 2 3 4 5 6 7 --- title: \u0026#34;First Post\u0026#34; date: 2023-06-20T17:45:58+08:00 draft: true --- # hello world 启动 1 2 # 执行成功以后，终端会出现server的地址，例如：http://localhost:1313/ hugo server --buildDrafts --buildDrafts的作用是草稿文章（对应文章中的draft: true属性）也进行生成，去除的话会跳过生成草稿。\n构建\u0026amp;发布 1 hugo 你会看到多出一个public目录，就是构建好以后的内容，里面的内容完全是静态的，放到站点下就能够访问。\n但是我们要发布到github page上，根目录只支持/docs，所以我们得把public改成docs，有两种方式：\n构建时加上参数：hugo --destination docs 在配置文件中加入参数：publicDirectory: docs 如果仓库只放public目录下的内容，那么可以忽略这里。\n版本说明 文中相关软件版本说明：\nhugo：v0.113.0 hugo-theme-stack：v3.16.0 参考 Quick Start | Hugo URL management | Hugo ","date":"2023-06-20T23:46:50+08:00","image":"https://repository-images.githubusercontent.com/11180687/9d3d8200-abf2-11e9-803c-4cdfde0d22e5","permalink":"https://ghbjayce.github.io/p/static-site-generator/hugo/quick-start/","title":"hugo快速上手搭建一个静态博客"}]